<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/数据结构与算法 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 计算机/数据结构与算法 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>数据结构-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:21:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</guid>
      <description>整理磁盘时发现考研408时自己的笔记&#xA;第一章 绪论 Link to heading 1.1 数据结构的基本概念 Link to heading 数据：信息的载体 数据元素：数据的基本单位。一个数据元素可由若干个数据项组成 数据对象：具有相同性质的数据元素的集合 数据类型：是一个值的集合和定义在此集合上一组操作的总称。原子类型：值不可再分的数据类型；结构类型：值可以再分解的若干类型；抽象数据类型：抽象数据组织和与之相关的操作。 抽象数据类型：ADT，指一个数学模型以及定义在该模型上的一组操作。 数据结构=逻辑结构+存储结构+数据的运算 1.1.2 数据结构的三要素 Link to heading 逻辑结构：指数据元素之间的逻辑关系，如集合、线性结构、树形结构、图状结构或网状结构 数据的存储结构：指数据结构在计算机中的表示，也称物理结构。包括顺序存储、链式存储、索引存储和散列存储。 数据的运算：施加在数据上的运算包括运算的定义和实现。 第2章 线性表 Link to heading 2.1 线性表的定义和基本操作 Link to heading 线性表是具有相同数据类型的n个数据元素的有限序列。 逻辑上，每个元素有且只有一个直接前驱，有且只有一个直接后继（表头表尾元素例外）&#xA;使用顺序存储的时候即为顺序表。 使用链式存储即为链表。&#xA;2.2 线性表的顺序表示 Link to heading 线性表的顺序存储又称为顺序表，是一组地址连续的存储单元。特点是表中元素的逻辑顺序与物理顺序相同。 PS：动态分配并不是链式存储，同样属于顺序存储结构，只是分配的空间大小可以在运行时决定。 最主要的特点是随机访问，而且逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素。&#xA;插入，平均时间复杂度O(n) 删除，平均时间复杂度O(n) 按值顺序查找O(n)，二分可以到O(logn) 错题：线性表的顺序存储结构是一种顺序存取的存储结构。 这个是错误的，是随机存取的存储结构。顺序存取是一种读写方式，不是存储方式，有别于顺序存储。 PPS：表的元素从1开始计数，C中的数组从0开始计算。&#xA;题目： [2010真题]1. 设将n(n&amp;gt;1)个整数存放到1维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&amp;lt;p&amp;lt;n)个位置，即将R中的数据由(X0,X1,&amp;hellip;,Xn-1)变换为(Xp,Xp+1,&amp;hellip;,Xn-1,X0,X1,&amp;hellip;,Xp-1)。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 [2011年真题]2.一个长度为L（L&amp;gt;=1）的升序序列S，处在L/2个位置的数被称为中位数。例如，若序列S1=（11,13,15,17,19），则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在由两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求： (1)给出算法的基本思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;[2013年真题]3.已知一个整数序列A=(a0,a1,&amp;hellip;,an-1),其中0&amp;lt;=ai&amp;lt;n(0&amp;lt;i&amp;lt;n)。若存在ap1=ap2=&amp;hellip;=apm=x且m&amp;gt;n/2(0&amp;lt;=pk&amp;lt;n,1&amp;lt;=k&amp;lt;=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;注释有感： 读注释的效果应当同读伪代码的效果一样 如果代码的内容无法直观表述，就需要写注释。 题目答案： 1.</description>
    </item>
    <item>
      <title>数据结构-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:21:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</guid>
      <description>整理磁盘时发现考研408时自己的笔记&#xA;第一章 绪论 Link to heading 1.1 数据结构的基本概念 Link to heading 数据：信息的载体 数据元素：数据的基本单位。一个数据元素可由若干个数据项组成 数据对象：具有相同性质的数据元素的集合 数据类型：是一个值的集合和定义在此集合上一组操作的总称。原子类型：值不可再分的数据类型；结构类型：值可以再分解的若干类型；抽象数据类型：抽象数据组织和与之相关的操作。 抽象数据类型：ADT，指一个数学模型以及定义在该模型上的一组操作。 数据结构=逻辑结构+存储结构+数据的运算 1.1.2 数据结构的三要素 Link to heading 逻辑结构：指数据元素之间的逻辑关系，如集合、线性结构、树形结构、图状结构或网状结构 数据的存储结构：指数据结构在计算机中的表示，也称物理结构。包括顺序存储、链式存储、索引存储和散列存储。 数据的运算：施加在数据上的运算包括运算的定义和实现。 第2章 线性表 Link to heading 2.1 线性表的定义和基本操作 Link to heading 线性表是具有相同数据类型的n个数据元素的有限序列。 逻辑上，每个元素有且只有一个直接前驱，有且只有一个直接后继（表头表尾元素例外）&#xA;使用顺序存储的时候即为顺序表。 使用链式存储即为链表。&#xA;2.2 线性表的顺序表示 Link to heading 线性表的顺序存储又称为顺序表，是一组地址连续的存储单元。特点是表中元素的逻辑顺序与物理顺序相同。 PS：动态分配并不是链式存储，同样属于顺序存储结构，只是分配的空间大小可以在运行时决定。 最主要的特点是随机访问，而且逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素。&#xA;插入，平均时间复杂度O(n) 删除，平均时间复杂度O(n) 按值顺序查找O(n)，二分可以到O(logn) 错题：线性表的顺序存储结构是一种顺序存取的存储结构。 这个是错误的，是随机存取的存储结构。顺序存取是一种读写方式，不是存储方式，有别于顺序存储。 PPS：表的元素从1开始计数，C中的数组从0开始计算。&#xA;题目： [2010真题]1. 设将n(n&amp;gt;1)个整数存放到1维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&amp;lt;p&amp;lt;n)个位置，即将R中的数据由(X0,X1,&amp;hellip;,Xn-1)变换为(Xp,Xp+1,&amp;hellip;,Xn-1,X0,X1,&amp;hellip;,Xp-1)。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 [2011年真题]2.一个长度为L（L&amp;gt;=1）的升序序列S，处在L/2个位置的数被称为中位数。例如，若序列S1=（11,13,15,17,19），则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在由两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求： (1)给出算法的基本思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;[2013年真题]3.已知一个整数序列A=(a0,a1,&amp;hellip;,an-1),其中0&amp;lt;=ai&amp;lt;n(0&amp;lt;i&amp;lt;n)。若存在ap1=ap2=&amp;hellip;=apm=x且m&amp;gt;n/2(0&amp;lt;=pk&amp;lt;n,1&amp;lt;=k&amp;lt;=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;注释有感： 读注释的效果应当同读伪代码的效果一样 如果代码的内容无法直观表述，就需要写注释。 题目答案： 1.</description>
    </item>
    <item>
      <title>数据结构与算法复习</title>
      <link>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 07 Apr 2020 16:11:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;内容上主要是复习了B树和红黑树，其他的因为太简单所以就只是过了一下，没记录下来&#xA;数据结构与算法复习 Link to heading 不包括全部内容 基础部分包括大O记号和小o记号的意义，P问题和NP问题和NP hard问题 B树和B+树 AVL平衡树和红黑树 KMP&#xA;资料：&#xA;B站-内功心法，红黑树、平衡树、B树和B+树 清华大学邓俊辉-数据结构与算法，我计划把这篇与它的计算几何做两个观后笔记。 B树和B+树 Link to heading 资料来源：&#xA;MIT6.046 博客 M阶B树的特征：&#xA;非叶子结点最多只有M个分支 除根节点以外的非叶子结点分支数为上取整(M/2)到M。 关键字个数=分支数-1 所有叶子结点位于同一层 区别：&#xA;B树的关键字集合分布在整棵树中，而B+树的实际数据只在叶子节点中。因此B树的搜索有可能在非叶子结点结束。 因为B+树的所有数据都在叶子节点中，所以B+树的叶子节点会依据关键字的大小自小而大的顺序链接，可以进行顺序遍历。非叶子结点可以看作是索引，结点中仅含有子树中的最大或最小关键字。同一个数字会在不同结点中重复出现。 B+树的查询优势：&#xA;B+树的中间结点不保存数据，所以磁盘也能够容纳更多结点元素 B+树的查询必须查找到叶子节点，B树不必，因此B+树查找更加稳定，但并不慢 对于范围查找来说，B+树只需要遍历叶子节点链表（因为是顺序链接的），而B树需要重复进行中序遍历。 红黑树 Link to heading 参考资料2：简书-30张图了解红黑树 参考资料3：清华大学邓俊辉-红黑树演示 参考资料4：使用2-4树看待红黑树&#xA;AVL树：平衡二叉树，每个节点平衡因子的绝对值不超过1，即左右子树高度差不超过1。 最大的作用是使得二叉查找树更平衡，本质上是特殊的二叉查找树。 红黑树的性质：&#xA;每个结点不是红色就是黑色 不可能有连在一起的红色节点。 根节点一定是黑色root 每个红色节点的两个子节点都是黑色。叶子节点都是黑色。 为了满足性质，有三种变化：&#xA;红变黑，黑变红，保证根节点是黑色 左旋 右旋 所有插入的点默认为红色。（PS：叶子节点为黑色）为什么这么规定：因为红黑树中所有的点都是黑色，也是满足要求的，这样可能会造成问题。&#xA;变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子节点也是红色（叔叔结点）。 把父结点设为黑色 把叔叔也设为黑色 把祖父结点，也就是父节点的父节点设为红色 把指针定义到祖父结点设为当前要操作的分析的点变换的规则 左旋：当前父结点是红色，叔叔结点是黑色，且当前结点是右子树。左旋以父节点为左旋。 右旋：当前父结点是红色，叔叔结点是黑色，且当前的结点是左子树。右旋 把父节点变为黑色 把祖父节点变为红色 以租父节点旋转 重要例子： 红黑树 Link to heading 根据邓俊辉老师的思路来，之前那个人很多没有讲 3+4重构，AVL保持平衡的方式，因为涉及到3个结点和4个子树，被称为3+4重构。</description>
    </item>
    <item>
      <title>数据结构与算法复习</title>
      <link>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 07 Apr 2020 16:11:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;内容上主要是复习了B树和红黑树，其他的因为太简单所以就只是过了一下，没记录下来&#xA;数据结构与算法复习 Link to heading 不包括全部内容 基础部分包括大O记号和小o记号的意义，P问题和NP问题和NP hard问题 B树和B+树 AVL平衡树和红黑树 KMP&#xA;资料：&#xA;B站-内功心法，红黑树、平衡树、B树和B+树 清华大学邓俊辉-数据结构与算法，我计划把这篇与它的计算几何做两个观后笔记。 B树和B+树 Link to heading 资料来源：&#xA;MIT6.046 博客 M阶B树的特征：&#xA;非叶子结点最多只有M个分支 除根节点以外的非叶子结点分支数为上取整(M/2)到M。 关键字个数=分支数-1 所有叶子结点位于同一层 区别：&#xA;B树的关键字集合分布在整棵树中，而B+树的实际数据只在叶子节点中。因此B树的搜索有可能在非叶子结点结束。 因为B+树的所有数据都在叶子节点中，所以B+树的叶子节点会依据关键字的大小自小而大的顺序链接，可以进行顺序遍历。非叶子结点可以看作是索引，结点中仅含有子树中的最大或最小关键字。同一个数字会在不同结点中重复出现。 B+树的查询优势：&#xA;B+树的中间结点不保存数据，所以磁盘也能够容纳更多结点元素 B+树的查询必须查找到叶子节点，B树不必，因此B+树查找更加稳定，但并不慢 对于范围查找来说，B+树只需要遍历叶子节点链表（因为是顺序链接的），而B树需要重复进行中序遍历。 红黑树 Link to heading 参考资料2：简书-30张图了解红黑树 参考资料3：清华大学邓俊辉-红黑树演示 参考资料4：使用2-4树看待红黑树&#xA;AVL树：平衡二叉树，每个节点平衡因子的绝对值不超过1，即左右子树高度差不超过1。 最大的作用是使得二叉查找树更平衡，本质上是特殊的二叉查找树。 红黑树的性质：&#xA;每个结点不是红色就是黑色 不可能有连在一起的红色节点。 根节点一定是黑色root 每个红色节点的两个子节点都是黑色。叶子节点都是黑色。 为了满足性质，有三种变化：&#xA;红变黑，黑变红，保证根节点是黑色 左旋 右旋 所有插入的点默认为红色。（PS：叶子节点为黑色）为什么这么规定：因为红黑树中所有的点都是黑色，也是满足要求的，这样可能会造成问题。&#xA;变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子节点也是红色（叔叔结点）。 把父结点设为黑色 把叔叔也设为黑色 把祖父结点，也就是父节点的父节点设为红色 把指针定义到祖父结点设为当前要操作的分析的点变换的规则 左旋：当前父结点是红色，叔叔结点是黑色，且当前结点是右子树。左旋以父节点为左旋。 右旋：当前父结点是红色，叔叔结点是黑色，且当前的结点是左子树。右旋 把父节点变为黑色 把祖父节点变为红色 以租父节点旋转 重要例子： 红黑树 Link to heading 根据邓俊辉老师的思路来，之前那个人很多没有讲 3+4重构，AVL保持平衡的方式，因为涉及到3个结点和4个子树，被称为3+4重构。</description>
    </item>
  </channel>
</rss>
