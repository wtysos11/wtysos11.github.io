<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/问题 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%97%AE%E9%A2%98/</link>
    <description>Recent content in 计算机/问题 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E9%97%AE%E9%A2%98/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>多协程错误处理与errgroup</title>
      <link>http://wtysos11.github.io/posts/20220615_%E5%A4%9A%E5%8D%8F%E7%A8%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8Eerrgroup/</link>
      <pubDate>Wed, 15 Jun 2022 14:17:05 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220615_%E5%A4%9A%E5%8D%8F%E7%A8%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8Eerrgroup/</guid>
      <description>工作中碰上的对多个goroutine中错误处理的需要，以及之后发现的对于errgroup的学习</description>
    </item>
    <item>
      <title>多协程错误处理与errgroup</title>
      <link>http://wtysos11.github.io/posts/20220615_%E5%A4%9A%E5%8D%8F%E7%A8%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8Eerrgroup/</link>
      <pubDate>Wed, 15 Jun 2022 14:17:05 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220615_%E5%A4%9A%E5%8D%8F%E7%A8%8B%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E4%B8%8Eerrgroup/</guid>
      <description>工作中碰上的对多个goroutine中错误处理的需要，以及之后发现的对于errgroup的学习</description>
    </item>
    <item>
      <title>python命令行库如何实现子命令共享参数？</title>
      <link>http://wtysos11.github.io/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 02 Sep 2021 15:46:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/</guid>
      <description>比较python下的命令行库：argparse、click的区别，实现子命令共享参数的需求。</description>
    </item>
    <item>
      <title>python命令行库如何实现子命令共享参数？</title>
      <link>http://wtysos11.github.io/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/</link>
      <pubDate>Thu, 02 Sep 2021 15:46:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/</guid>
      <description>比较python下的命令行库：argparse、click的区别，实现子命令共享参数的需求。</description>
    </item>
    <item>
      <title>如何让pandas根据指定列的指进行partition</title>
      <link>http://wtysos11.github.io/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/</link>
      <pubDate>Sun, 22 Nov 2020 19:20:04 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/</guid>
      <description>问题描述 Link to heading 我拿到了一个维基百科的列表，其数据如下：&#xA;datehour title views 2015-10-17 13:00:00 UTC Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License 2 2015-06-01 14:00:00 UTC Dulce_Mar铆a 10 2015-06-01 21:00:00 UTC Dulce_Mar铆a 25 2015-06-01 06:00:00 UTC Dulce_Mar铆a 18 2015-08-30 12:00:00 UTC Portal:Current_events 116 UTF-8的问题暂且不谈，现在需要将其作为csv文件读入内存中，并且按照title分成不同的datehour-&amp;gt;views表，并按照datehour排序。将2015~2020的数据按照同样的操作进行处理，并将它们拼接成一张大表，最后将每一个title对应的表导出到csv，title写入到index.txt中。&#xA;##解决方案&#xA;朴素想法 Link to heading 最朴素的想法就是遍历一遍原表的所有行，构建一个字典，字典的每个key是title，value是两个list。不断将原有数据放入其中，然后到时候直接遍历keys，根据两个list构建pd，排序后导出。&#xA;更python的做法 Link to heading 朴素想法应该是够用的，但是不美观，不够pythonic，看着很别扭。于是我搜索了How to partition DataFrame by column value in pandas?&#xA;boolean index Link to heading stackoverflow里有人提问如何将离散数据进行二分类，把小于和大于某个值的数据分到两个DataFrame中。直接用df1 = df[df[&amp;quot;Sales&amp;quot;]&amp;gt;=s]这样的语句就可以完成。 但是这在我们的场景上并不太适用。当然，可以提前遍历一遍把title做成集合再循环遍历，不过这也不是很pythonic。&#xA;groupby Link to heading 同样是上面那个问题，有人提到可以使用groupby方法。groupby听着就很满足我的需求，它让我想起了SQL里面的同名功能。&#xA;df.groupby(&#39;ColumnName&#39;).groups可以显示所有的列中的元素。 df.groupby(&#39;ColumnName&#39;)可以进行遍历，结果是一个(name,subDF)的二元组，name为分组的元素名称，subDF为分组后的DataFrame 对df.</description>
    </item>
    <item>
      <title>如何让pandas根据指定列的指进行partition</title>
      <link>http://wtysos11.github.io/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/</link>
      <pubDate>Sun, 22 Nov 2020 19:20:04 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/</guid>
      <description>问题描述 Link to heading 我拿到了一个维基百科的列表，其数据如下：&#xA;datehour title views 2015-10-17 13:00:00 UTC Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License 2 2015-06-01 14:00:00 UTC Dulce_Mar铆a 10 2015-06-01 21:00:00 UTC Dulce_Mar铆a 25 2015-06-01 06:00:00 UTC Dulce_Mar铆a 18 2015-08-30 12:00:00 UTC Portal:Current_events 116 UTF-8的问题暂且不谈，现在需要将其作为csv文件读入内存中，并且按照title分成不同的datehour-&amp;gt;views表，并按照datehour排序。将2015~2020的数据按照同样的操作进行处理，并将它们拼接成一张大表，最后将每一个title对应的表导出到csv，title写入到index.txt中。&#xA;##解决方案&#xA;朴素想法 Link to heading 最朴素的想法就是遍历一遍原表的所有行，构建一个字典，字典的每个key是title，value是两个list。不断将原有数据放入其中，然后到时候直接遍历keys，根据两个list构建pd，排序后导出。&#xA;更python的做法 Link to heading 朴素想法应该是够用的，但是不美观，不够pythonic，看着很别扭。于是我搜索了How to partition DataFrame by column value in pandas?&#xA;boolean index Link to heading stackoverflow里有人提问如何将离散数据进行二分类，把小于和大于某个值的数据分到两个DataFrame中。直接用df1 = df[df[&amp;quot;Sales&amp;quot;]&amp;gt;=s]这样的语句就可以完成。 但是这在我们的场景上并不太适用。当然，可以提前遍历一遍把title做成集合再循环遍历，不过这也不是很pythonic。&#xA;groupby Link to heading 同样是上面那个问题，有人提到可以使用groupby方法。groupby听着就很满足我的需求，它让我想起了SQL里面的同名功能。&#xA;df.groupby(&#39;ColumnName&#39;).groups可以显示所有的列中的元素。 df.groupby(&#39;ColumnName&#39;)可以进行遍历，结果是一个(name,subDF)的二元组，name为分组的元素名称，subDF为分组后的DataFrame 对df.</description>
    </item>
  </channel>
</rss>
