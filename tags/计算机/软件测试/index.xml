<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/软件测试 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</link>
    <description>Recent content in 计算机/软件测试 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>软件测试复习</title>
      <link>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 06 Apr 2020 20:15:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;软件测试复习 Link to heading 对大三下学期的软件测试课程进行复习&#xA;第一章 Link to heading 计算机软件体系结构 Link to heading 软件体系结构是软件系统的结构、行为和属性的高级抽象，给出系统的组织结构和拓扑结构，规定系统需求和构成系统的元素之间的对应关系。&#xA;Layered Architecture：n层模型，比如TCP\IP使用的那种。例子：Presentation Layer-&amp;gt;Business Layer-&amp;gt; Persistent Layer-&amp;gt; Database Layer。核心思想是组件间的分离与功能上的聚合。 Event-Driven Architecture：常用于异步通信架构，由高度解耦合且单一目的的事件处理组件所构成。 MicroKernal Architecture：用于实现基于产品的应用的自然表示，即将大量第三方库插入进核心代码中。Core system提供了核心功能，plug-in module则可以是第三方库等能够轻松调换的代码。通过分离可以实现应用特性和具体实现的分离。 Microservices Architecture：微服务架构，面向服务的架构。按照单元分解，采用分布式架构，一般具有统一的用户交互层。 Space-Based Architecture：特定于解决扩展与并发问题。应用数据统一存储于内存中，同时通过扩展处理单元的方式实现应用处理能力的增加。 软件=程序+数据+文档+服务、 是能够完成预定性能和功能的、可执行的计算机指令。 软件需要有描述程序的操作和使用的文档。 1976: Algorithm+Data Structure = Programs&#xA;生产软件产品的基本步骤：软件规格说明、设计与实现、确认、演进。&#xA;软件开发方法：&#xA;面向数据流的结构化程序开发方法。指导思想是自顶向下，逐步求精；基本原则是功能的分解与抽象。很适合数据处理领域的问题。 面向数据结构的开发方法(Jackson方法)：描述问题的输入、输出数据结构，分析其对应性，设计相应的程序结构，从而给出问题的软件过程描述。以数据结构为驱动。 基于模型的方法，支持程序开发的形式化方法，把软件系统当作模型来给予描述，把软件的输入、输出看作模型对象，把这些对象在计算机内的状态看作该模型在对象上的操作。 面向对象的开发方法：指导思想是尽量按照人类认识世界的方法和思维方式来分析和解决问题。 第一章 1.2 软件工程生命周期 Link to heading 软件生命周期的6个阶段：&#xA;可行性分析与计划阶段：确认软件开发的总体目标、估计可利用的开发资源，最后提交可行性分析报告。 需求分析阶段：分析用户提出的要求 设计阶段：概要设计/逻辑设计（把各项软件需求转换成软件的体系结构）、详细设计/物理设计（按照概要设计分解的每个模块所要完成的工作进行具体的描述）、提交概要结构设计说明书等文档 实现阶段：完成源程序的编码、编译和运行调试、编写进度日报周报、测试计划、提交用户手册等 测试阶段：全面测试目标软件系统，并检查审阅已编制的文档。 运行与维护阶段：软件提交给用户后，在运行使用中得到持续的维护；改正性维护、适应性维护和完善性维护。 前五个阶段合称开发阶段。&#xA;软件生命周期模型 Link to heading 包括瀑布模型、VW模型、快速应用开发模型、原型模型、迭代模型、螺旋模型、喷泉模型、基于构建的开发模型、Rational统一过程模型、敏捷开发模型与极限编程。&#xA;瀑布模型 Link to heading 特征：</description>
    </item>
    <item>
      <title>软件测试复习</title>
      <link>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 06 Apr 2020 20:15:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;软件测试复习 Link to heading 对大三下学期的软件测试课程进行复习&#xA;第一章 Link to heading 计算机软件体系结构 Link to heading 软件体系结构是软件系统的结构、行为和属性的高级抽象，给出系统的组织结构和拓扑结构，规定系统需求和构成系统的元素之间的对应关系。&#xA;Layered Architecture：n层模型，比如TCP\IP使用的那种。例子：Presentation Layer-&amp;gt;Business Layer-&amp;gt; Persistent Layer-&amp;gt; Database Layer。核心思想是组件间的分离与功能上的聚合。 Event-Driven Architecture：常用于异步通信架构，由高度解耦合且单一目的的事件处理组件所构成。 MicroKernal Architecture：用于实现基于产品的应用的自然表示，即将大量第三方库插入进核心代码中。Core system提供了核心功能，plug-in module则可以是第三方库等能够轻松调换的代码。通过分离可以实现应用特性和具体实现的分离。 Microservices Architecture：微服务架构，面向服务的架构。按照单元分解，采用分布式架构，一般具有统一的用户交互层。 Space-Based Architecture：特定于解决扩展与并发问题。应用数据统一存储于内存中，同时通过扩展处理单元的方式实现应用处理能力的增加。 软件=程序+数据+文档+服务、 是能够完成预定性能和功能的、可执行的计算机指令。 软件需要有描述程序的操作和使用的文档。 1976: Algorithm+Data Structure = Programs&#xA;生产软件产品的基本步骤：软件规格说明、设计与实现、确认、演进。&#xA;软件开发方法：&#xA;面向数据流的结构化程序开发方法。指导思想是自顶向下，逐步求精；基本原则是功能的分解与抽象。很适合数据处理领域的问题。 面向数据结构的开发方法(Jackson方法)：描述问题的输入、输出数据结构，分析其对应性，设计相应的程序结构，从而给出问题的软件过程描述。以数据结构为驱动。 基于模型的方法，支持程序开发的形式化方法，把软件系统当作模型来给予描述，把软件的输入、输出看作模型对象，把这些对象在计算机内的状态看作该模型在对象上的操作。 面向对象的开发方法：指导思想是尽量按照人类认识世界的方法和思维方式来分析和解决问题。 第一章 1.2 软件工程生命周期 Link to heading 软件生命周期的6个阶段：&#xA;可行性分析与计划阶段：确认软件开发的总体目标、估计可利用的开发资源，最后提交可行性分析报告。 需求分析阶段：分析用户提出的要求 设计阶段：概要设计/逻辑设计（把各项软件需求转换成软件的体系结构）、详细设计/物理设计（按照概要设计分解的每个模块所要完成的工作进行具体的描述）、提交概要结构设计说明书等文档 实现阶段：完成源程序的编码、编译和运行调试、编写进度日报周报、测试计划、提交用户手册等 测试阶段：全面测试目标软件系统，并检查审阅已编制的文档。 运行与维护阶段：软件提交给用户后，在运行使用中得到持续的维护；改正性维护、适应性维护和完善性维护。 前五个阶段合称开发阶段。&#xA;软件生命周期模型 Link to heading 包括瀑布模型、VW模型、快速应用开发模型、原型模型、迭代模型、螺旋模型、喷泉模型、基于构建的开发模型、Rational统一过程模型、敏捷开发模型与极限编程。&#xA;瀑布模型 Link to heading 特征：</description>
    </item>
  </channel>
</rss>
