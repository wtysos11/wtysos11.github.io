<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/算法/排序算法 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 计算机/算法/排序算法 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;复现基础排序算法</title>
      <link>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 12 Mar 2021 09:56:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>复习一下基本的排序算法&#xA;快速排序 Link to heading 时间复杂度O(nlogn)，不稳定 这个写法是我刻在DNA里的，应该没什么大问题，除了比较抽象之外都还好。&#xA;#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; arr,int low,int high){ if(low==high) return cout&amp;lt;&amp;lt;low&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;high&amp;lt;&amp;lt;endl; int i = low; int j = high; int mid = (i+j)/2; int v = arr[mid]; do{ while(arr[i]&amp;lt;v) i++; while(arr[j]&amp;gt;v) j--; if(i&amp;lt;=j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++,j--; } cout&amp;lt;&amp;lt;&amp;#34;inside&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; }while(i&amp;lt;=j); if(i&amp;lt;high){ quickSort(arr,i+1,high); } if(j&amp;gt;low){ quickSort(arr,low,j-1); } } int main(void){ vector&amp;lt;int&amp;gt; arr{2,5,3,4,1,9,7}; quickSort(arr,0,arr.</description>
    </item>
    <item>
      <title>C&#43;&#43;复现基础排序算法</title>
      <link>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 12 Mar 2021 09:56:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>复习一下基本的排序算法&#xA;快速排序 Link to heading 时间复杂度O(nlogn)，不稳定 这个写法是我刻在DNA里的，应该没什么大问题，除了比较抽象之外都还好。&#xA;#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; arr,int low,int high){ if(low==high) return cout&amp;lt;&amp;lt;low&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;high&amp;lt;&amp;lt;endl; int i = low; int j = high; int mid = (i+j)/2; int v = arr[mid]; do{ while(arr[i]&amp;lt;v) i++; while(arr[j]&amp;gt;v) j--; if(i&amp;lt;=j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++,j--; } cout&amp;lt;&amp;lt;&amp;#34;inside&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; }while(i&amp;lt;=j); if(i&amp;lt;high){ quickSort(arr,i+1,high); } if(j&amp;gt;low){ quickSort(arr,low,j-1); } } int main(void){ vector&amp;lt;int&amp;gt; arr{2,5,3,4,1,9,7}; quickSort(arr,0,arr.</description>
    </item>
    <item>
      <title>C&#43;&#43;复现基础排序算法</title>
      <link>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 12 Mar 2021 09:56:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>复习一下基本的排序算法&#xA;快速排序 Link to heading 时间复杂度O(nlogn)，不稳定 这个写法是我刻在DNA里的，应该没什么大问题，除了比较抽象之外都还好。&#xA;#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; arr,int low,int high){ if(low==high) return cout&amp;lt;&amp;lt;low&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;high&amp;lt;&amp;lt;endl; int i = low; int j = high; int mid = (i+j)/2; int v = arr[mid]; do{ while(arr[i]&amp;lt;v) i++; while(arr[j]&amp;gt;v) j--; if(i&amp;lt;=j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++,j--; } cout&amp;lt;&amp;lt;&amp;#34;inside&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; }while(i&amp;lt;=j); if(i&amp;lt;high){ quickSort(arr,i+1,high); } if(j&amp;gt;low){ quickSort(arr,low,j-1); } } int main(void){ vector&amp;lt;int&amp;gt; arr{2,5,3,4,1,9,7}; quickSort(arr,0,arr.</description>
    </item>
  </channel>
</rss>
