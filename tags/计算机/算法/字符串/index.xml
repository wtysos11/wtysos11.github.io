<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/算法/字符串 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
    <description>Recent content in 计算机/算法/字符串 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 806: 写字符串需要的行数</title>
      <link>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</link>
      <pubDate>Tue, 12 Apr 2022 09:15:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</guid>
      <description>220412 每日一题，非常简单&#xA;class Solution { public: vector&amp;lt;int&amp;gt; numberOfLines(vector&amp;lt;int&amp;gt;&amp;amp; widths, string s) { int rest=0,linenum=1; for(int i=0;i&amp;lt;s.length();i++){ if(rest == 100 &amp;amp;&amp;amp; widths[s[i]-&amp;#39;a&amp;#39;]&amp;gt;0){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; continue; } rest += widths[s[i]-&amp;#39;a&amp;#39;]; if(rest&amp;gt;100){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; } } return vector&amp;lt;int&amp;gt;{linenum,rest}; } }; </description>
    </item>
    <item>
      <title>Leetcode 806: 写字符串需要的行数</title>
      <link>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</link>
      <pubDate>Tue, 12 Apr 2022 09:15:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</guid>
      <description>220412 每日一题，非常简单&#xA;class Solution { public: vector&amp;lt;int&amp;gt; numberOfLines(vector&amp;lt;int&amp;gt;&amp;amp; widths, string s) { int rest=0,linenum=1; for(int i=0;i&amp;lt;s.length();i++){ if(rest == 100 &amp;amp;&amp;amp; widths[s[i]-&amp;#39;a&amp;#39;]&amp;gt;0){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; continue; } rest += widths[s[i]-&amp;#39;a&amp;#39;]; if(rest&amp;gt;100){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; } } return vector&amp;lt;int&amp;gt;{linenum,rest}; } }; </description>
    </item>
    <item>
      <title>Leetcode 806: 写字符串需要的行数</title>
      <link>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</link>
      <pubDate>Tue, 12 Apr 2022 09:15:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220412_leetcode_806_%E5%86%99%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%9C%80%E8%A6%81%E7%9A%84%E8%A1%8C%E6%95%B0/</guid>
      <description>220412 每日一题，非常简单&#xA;class Solution { public: vector&amp;lt;int&amp;gt; numberOfLines(vector&amp;lt;int&amp;gt;&amp;amp; widths, string s) { int rest=0,linenum=1; for(int i=0;i&amp;lt;s.length();i++){ if(rest == 100 &amp;amp;&amp;amp; widths[s[i]-&amp;#39;a&amp;#39;]&amp;gt;0){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; continue; } rest += widths[s[i]-&amp;#39;a&amp;#39;]; if(rest&amp;gt;100){ rest = widths[s[i]-&amp;#39;a&amp;#39;]; linenum++; } } return vector&amp;lt;int&amp;gt;{linenum,rest}; } }; </description>
    </item>
    <item>
      <title>Leetcode 804: 唯一摩尔斯密码词</title>
      <link>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</link>
      <pubDate>Sun, 10 Apr 2022 16:30:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</guid>
      <description> Leetcode 804 唯一摩尔斯密码词 Link to heading 没什么难度，水题。如果不是每日一题不建议刷。&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; class Solution { public: int uniqueMorseRepresentations(vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;string&amp;gt; password{&amp;#34;.-&amp;#34;,&amp;#34;-...&amp;#34;,&amp;#34;-.-.&amp;#34;,&amp;#34;-..&amp;#34;,&amp;#34;.&amp;#34;,&amp;#34;..-.&amp;#34;,&amp;#34;--.&amp;#34;,&amp;#34;....&amp;#34;,&amp;#34;..&amp;#34;,&amp;#34;.---&amp;#34;,&amp;#34;-.-&amp;#34;,&amp;#34;.-..&amp;#34;,&amp;#34;--&amp;#34;,&amp;#34;-.&amp;#34;,&amp;#34;---&amp;#34;,&amp;#34;.--.&amp;#34;,&amp;#34;--.-&amp;#34;,&amp;#34;.-.&amp;#34;,&amp;#34;...&amp;#34;,&amp;#34;-&amp;#34;,&amp;#34;..-&amp;#34;,&amp;#34;...-&amp;#34;,&amp;#34;.--&amp;#34;,&amp;#34;-..-&amp;#34;,&amp;#34;-.--&amp;#34;,&amp;#34;--..&amp;#34;}; map&amp;lt;string,bool&amp;gt; exist; for(int i=0;i&amp;lt;words.size();i++){ string&amp;amp; word = words[i]; string origin; for(int j=0;j&amp;lt;word.length();j++){ origin = origin + password[word[j]-&amp;#39;a&amp;#39;]; } exist[origin]=true; } return exist.size(); } }; int main(void){ Solution s; vector&amp;lt;string&amp;gt; words; words.emplace_back(&amp;#34;gin&amp;#34;); words.emplace_back(&amp;#34;zen&amp;#34;); words.emplace_back(&amp;#34;gig&amp;#34;); words.emplace_back(&amp;#34;msg&amp;#34;); cout&amp;lt;&amp;lt;s.uniqueMorseRepresentations(words)&amp;lt;&amp;lt;endl; return 0; } </description>
    </item>
    <item>
      <title>Leetcode 804: 唯一摩尔斯密码词</title>
      <link>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</link>
      <pubDate>Sun, 10 Apr 2022 16:30:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</guid>
      <description> Leetcode 804 唯一摩尔斯密码词 Link to heading 没什么难度，水题。如果不是每日一题不建议刷。&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; class Solution { public: int uniqueMorseRepresentations(vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;string&amp;gt; password{&amp;#34;.-&amp;#34;,&amp;#34;-...&amp;#34;,&amp;#34;-.-.&amp;#34;,&amp;#34;-..&amp;#34;,&amp;#34;.&amp;#34;,&amp;#34;..-.&amp;#34;,&amp;#34;--.&amp;#34;,&amp;#34;....&amp;#34;,&amp;#34;..&amp;#34;,&amp;#34;.---&amp;#34;,&amp;#34;-.-&amp;#34;,&amp;#34;.-..&amp;#34;,&amp;#34;--&amp;#34;,&amp;#34;-.&amp;#34;,&amp;#34;---&amp;#34;,&amp;#34;.--.&amp;#34;,&amp;#34;--.-&amp;#34;,&amp;#34;.-.&amp;#34;,&amp;#34;...&amp;#34;,&amp;#34;-&amp;#34;,&amp;#34;..-&amp;#34;,&amp;#34;...-&amp;#34;,&amp;#34;.--&amp;#34;,&amp;#34;-..-&amp;#34;,&amp;#34;-.--&amp;#34;,&amp;#34;--..&amp;#34;}; map&amp;lt;string,bool&amp;gt; exist; for(int i=0;i&amp;lt;words.size();i++){ string&amp;amp; word = words[i]; string origin; for(int j=0;j&amp;lt;word.length();j++){ origin = origin + password[word[j]-&amp;#39;a&amp;#39;]; } exist[origin]=true; } return exist.size(); } }; int main(void){ Solution s; vector&amp;lt;string&amp;gt; words; words.emplace_back(&amp;#34;gin&amp;#34;); words.emplace_back(&amp;#34;zen&amp;#34;); words.emplace_back(&amp;#34;gig&amp;#34;); words.emplace_back(&amp;#34;msg&amp;#34;); cout&amp;lt;&amp;lt;s.uniqueMorseRepresentations(words)&amp;lt;&amp;lt;endl; return 0; } </description>
    </item>
    <item>
      <title>Leetcode 804: 唯一摩尔斯密码词</title>
      <link>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</link>
      <pubDate>Sun, 10 Apr 2022 16:30:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220410_leetcode_804_%E5%94%AF%E4%B8%80%E6%91%A9%E5%B0%94%E6%96%AF%E5%AF%86%E7%A0%81%E8%AF%8D/</guid>
      <description> Leetcode 804 唯一摩尔斯密码词 Link to heading 没什么难度，水题。如果不是每日一题不建议刷。&#xA;#include &amp;lt;iostream&amp;gt; #include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;queue&amp;gt; #include &amp;lt;map&amp;gt; using namespace std; class Solution { public: int uniqueMorseRepresentations(vector&amp;lt;string&amp;gt;&amp;amp; words) { vector&amp;lt;string&amp;gt; password{&amp;#34;.-&amp;#34;,&amp;#34;-...&amp;#34;,&amp;#34;-.-.&amp;#34;,&amp;#34;-..&amp;#34;,&amp;#34;.&amp;#34;,&amp;#34;..-.&amp;#34;,&amp;#34;--.&amp;#34;,&amp;#34;....&amp;#34;,&amp;#34;..&amp;#34;,&amp;#34;.---&amp;#34;,&amp;#34;-.-&amp;#34;,&amp;#34;.-..&amp;#34;,&amp;#34;--&amp;#34;,&amp;#34;-.&amp;#34;,&amp;#34;---&amp;#34;,&amp;#34;.--.&amp;#34;,&amp;#34;--.-&amp;#34;,&amp;#34;.-.&amp;#34;,&amp;#34;...&amp;#34;,&amp;#34;-&amp;#34;,&amp;#34;..-&amp;#34;,&amp;#34;...-&amp;#34;,&amp;#34;.--&amp;#34;,&amp;#34;-..-&amp;#34;,&amp;#34;-.--&amp;#34;,&amp;#34;--..&amp;#34;}; map&amp;lt;string,bool&amp;gt; exist; for(int i=0;i&amp;lt;words.size();i++){ string&amp;amp; word = words[i]; string origin; for(int j=0;j&amp;lt;word.length();j++){ origin = origin + password[word[j]-&amp;#39;a&amp;#39;]; } exist[origin]=true; } return exist.size(); } }; int main(void){ Solution s; vector&amp;lt;string&amp;gt; words; words.emplace_back(&amp;#34;gin&amp;#34;); words.emplace_back(&amp;#34;zen&amp;#34;); words.emplace_back(&amp;#34;gig&amp;#34;); words.emplace_back(&amp;#34;msg&amp;#34;); cout&amp;lt;&amp;lt;s.uniqueMorseRepresentations(words)&amp;lt;&amp;lt;endl; return 0; } </description>
    </item>
    <item>
      <title>Leetcode 796: 旋转字符串</title>
      <link>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 07 Apr 2022 19:21:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Leetcode第796题：旋转字符串，简单题</description>
    </item>
    <item>
      <title>Leetcode 796: 旋转字符串</title>
      <link>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 07 Apr 2022 19:21:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Leetcode第796题：旋转字符串，简单题</description>
    </item>
    <item>
      <title>Leetcode 796: 旋转字符串</title>
      <link>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
      <pubDate>Thu, 07 Apr 2022 19:21:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220407_leetcode_796_%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
      <description>Leetcode第796题：旋转字符串，简单题</description>
    </item>
    <item>
      <title>Leetcode 5: 最长回文子串</title>
      <link>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 05 Apr 2022 12:09:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>Leetcode第五题：最长回文子串</description>
    </item>
    <item>
      <title>Leetcode 5: 最长回文子串</title>
      <link>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 05 Apr 2022 12:09:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>Leetcode第五题：最长回文子串</description>
    </item>
    <item>
      <title>Leetcode 5: 最长回文子串</title>
      <link>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Tue, 05 Apr 2022 12:09:02 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>Leetcode第五题：最长回文子串</description>
    </item>
    <item>
      <title>【动态规划】最长公共子串问题</title>
      <link>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 11 Mar 2021 16:40:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</guid>
      <description>题目来源为：牛客网&#xA;题目有意思的地方在于，最长公共子串与最长连续公共子串都是比较经典的问题，但是这道题在其基础上加了限制。 首先这道题应该是最长连续公共子串问题，状态转移方程就不写了，挺简单的。就记录下最大的子串所在的位置的行坐标和列坐标，就能把子串拿到手。 但是对于O(nm)的动态规划所有点都会超时，这就很厉害了，目前通过的做法使用的是滑动窗口法，我还在研究。&#xA;代码大概长这样&#xA;/** * 滑动窗口算法 * * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ public static String LCS1(String str1, String str2) { // write code here StringBuilder sb = new StringBuilder(); int start = 0, end = 1; while (end &amp;lt; str1.length() + 1) { if (str2.contains(str1.substring(start, end))) { if (sb.length() &amp;lt; end - start) { sb.delete(0, sb.length()); sb.append(str1, start, end); } } else { //这个算法我曾经疑惑，假如出现start&amp;gt;end，程序不是会crash么 //通过debug发现，当start==end时，substring获取的是&amp;#34;&amp;#34;，此时contains必然为true //所以当start == end时，必然会走end++分支 start++; } end++; } if (sb.</description>
    </item>
    <item>
      <title>【动态规划】最长公共子串问题</title>
      <link>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 11 Mar 2021 16:40:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</guid>
      <description>题目来源为：牛客网&#xA;题目有意思的地方在于，最长公共子串与最长连续公共子串都是比较经典的问题，但是这道题在其基础上加了限制。 首先这道题应该是最长连续公共子串问题，状态转移方程就不写了，挺简单的。就记录下最大的子串所在的位置的行坐标和列坐标，就能把子串拿到手。 但是对于O(nm)的动态规划所有点都会超时，这就很厉害了，目前通过的做法使用的是滑动窗口法，我还在研究。&#xA;代码大概长这样&#xA;/** * 滑动窗口算法 * * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ public static String LCS1(String str1, String str2) { // write code here StringBuilder sb = new StringBuilder(); int start = 0, end = 1; while (end &amp;lt; str1.length() + 1) { if (str2.contains(str1.substring(start, end))) { if (sb.length() &amp;lt; end - start) { sb.delete(0, sb.length()); sb.append(str1, start, end); } } else { //这个算法我曾经疑惑，假如出现start&amp;gt;end，程序不是会crash么 //通过debug发现，当start==end时，substring获取的是&amp;#34;&amp;#34;，此时contains必然为true //所以当start == end时，必然会走end++分支 start++; } end++; } if (sb.</description>
    </item>
    <item>
      <title>【动态规划】最长公共子串问题</title>
      <link>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 11 Mar 2021 16:40:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/</guid>
      <description>题目来源为：牛客网&#xA;题目有意思的地方在于，最长公共子串与最长连续公共子串都是比较经典的问题，但是这道题在其基础上加了限制。 首先这道题应该是最长连续公共子串问题，状态转移方程就不写了，挺简单的。就记录下最大的子串所在的位置的行坐标和列坐标，就能把子串拿到手。 但是对于O(nm)的动态规划所有点都会超时，这就很厉害了，目前通过的做法使用的是滑动窗口法，我还在研究。&#xA;代码大概长这样&#xA;/** * 滑动窗口算法 * * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ public static String LCS1(String str1, String str2) { // write code here StringBuilder sb = new StringBuilder(); int start = 0, end = 1; while (end &amp;lt; str1.length() + 1) { if (str2.contains(str1.substring(start, end))) { if (sb.length() &amp;lt; end - start) { sb.delete(0, sb.length()); sb.append(str1, start, end); } } else { //这个算法我曾经疑惑，假如出现start&amp;gt;end，程序不是会crash么 //通过debug发现，当start==end时，substring获取的是&amp;#34;&amp;#34;，此时contains必然为true //所以当start == end时，必然会走end++分支 start++; } end++; } if (sb.</description>
    </item>
    <item>
      <title>KMP算法复习</title>
      <link>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Thu, 11 Mar 2021 15:09:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>太久没打了，刚好有道题用上了，就复习一下。 我觉得复到KMP应该就够用了，如果要AC自动机我直接死在那里。&#xA;参考资料 如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486&#xA;核心思想 Link to heading KMP算法要解决的问题是字符串匹配问题。给定原串S和模版串P，求解原串中是否存在子字符串与模版串相匹配。&#xA;最简单的想法就是暴力搜索，设原串S长度为n，模板串P长度为m，显然暴力的时间复杂度为O(nm)，非常慢。&#xA;KMP的想法是充分利用适配信息，其next数组的定义如下：next[i]表示在P[0:i]子串中，使前k个字符恰好等于后k个字符的最大的k，且k不能等于i+1（否则就等于它自己了） 这个数组的定义挺绕的，第一眼基本都不会反应过来，我就不插图了，只用文本表述一下（建议看图）。KMP的失配匹配，本质上就是把模版串向前伸，直到伸到前缀与后缀匹配为止，这实际上就是自己与自己匹配。因此这个k就是前缀与后缀相同的最大长度k。&#xA;因此next数组可以用如下方法求得&#xA;def getNxt(x): for i in range(x,0,-1): if p[0:i] == p[x-i+1:x+1]: return i return 0 nxt = [getNxt(x) for x in range(len(p))] 构建next数组的复杂度显然是O(m^2)的 使用next数组加速匹配&#xA;def search(p,s): tar = 0 # 主串中将要匹配的位置 pos = 0 # 子串中将要匹配的位置 while tar &amp;lt; len(s): if s[tar] == p[pos]: # 若两个字符相同，匹配成功，tar和pos各进一步 tar += 1 pos += 1 elif pos&amp;gt;0: # 失配，且pos&amp;gt;0，则next数组移动 pos = nxt[pos-1] else: # pos[0]也失配了，则主串前进 tar += 1 if pos == len(p): # pos走到了len(p)，匹配成功 print(tar-pos) # 输出起始地点 pos = nxt[pos-1] # 当作失配，继续下一次匹配 时间复杂度为O(n+m)，会比暴力方法小很多。</description>
    </item>
    <item>
      <title>KMP算法复习</title>
      <link>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Thu, 11 Mar 2021 15:09:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>太久没打了，刚好有道题用上了，就复习一下。 我觉得复到KMP应该就够用了，如果要AC自动机我直接死在那里。&#xA;参考资料 如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486&#xA;核心思想 Link to heading KMP算法要解决的问题是字符串匹配问题。给定原串S和模版串P，求解原串中是否存在子字符串与模版串相匹配。&#xA;最简单的想法就是暴力搜索，设原串S长度为n，模板串P长度为m，显然暴力的时间复杂度为O(nm)，非常慢。&#xA;KMP的想法是充分利用适配信息，其next数组的定义如下：next[i]表示在P[0:i]子串中，使前k个字符恰好等于后k个字符的最大的k，且k不能等于i+1（否则就等于它自己了） 这个数组的定义挺绕的，第一眼基本都不会反应过来，我就不插图了，只用文本表述一下（建议看图）。KMP的失配匹配，本质上就是把模版串向前伸，直到伸到前缀与后缀匹配为止，这实际上就是自己与自己匹配。因此这个k就是前缀与后缀相同的最大长度k。&#xA;因此next数组可以用如下方法求得&#xA;def getNxt(x): for i in range(x,0,-1): if p[0:i] == p[x-i+1:x+1]: return i return 0 nxt = [getNxt(x) for x in range(len(p))] 构建next数组的复杂度显然是O(m^2)的 使用next数组加速匹配&#xA;def search(p,s): tar = 0 # 主串中将要匹配的位置 pos = 0 # 子串中将要匹配的位置 while tar &amp;lt; len(s): if s[tar] == p[pos]: # 若两个字符相同，匹配成功，tar和pos各进一步 tar += 1 pos += 1 elif pos&amp;gt;0: # 失配，且pos&amp;gt;0，则next数组移动 pos = nxt[pos-1] else: # pos[0]也失配了，则主串前进 tar += 1 if pos == len(p): # pos走到了len(p)，匹配成功 print(tar-pos) # 输出起始地点 pos = nxt[pos-1] # 当作失配，继续下一次匹配 时间复杂度为O(n+m)，会比暴力方法小很多。</description>
    </item>
    <item>
      <title>KMP算法复习</title>
      <link>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Thu, 11 Mar 2021 15:09:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>太久没打了，刚好有道题用上了，就复习一下。 我觉得复到KMP应该就够用了，如果要AC自动机我直接死在那里。&#xA;参考资料 如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486&#xA;核心思想 Link to heading KMP算法要解决的问题是字符串匹配问题。给定原串S和模版串P，求解原串中是否存在子字符串与模版串相匹配。&#xA;最简单的想法就是暴力搜索，设原串S长度为n，模板串P长度为m，显然暴力的时间复杂度为O(nm)，非常慢。&#xA;KMP的想法是充分利用适配信息，其next数组的定义如下：next[i]表示在P[0:i]子串中，使前k个字符恰好等于后k个字符的最大的k，且k不能等于i+1（否则就等于它自己了） 这个数组的定义挺绕的，第一眼基本都不会反应过来，我就不插图了，只用文本表述一下（建议看图）。KMP的失配匹配，本质上就是把模版串向前伸，直到伸到前缀与后缀匹配为止，这实际上就是自己与自己匹配。因此这个k就是前缀与后缀相同的最大长度k。&#xA;因此next数组可以用如下方法求得&#xA;def getNxt(x): for i in range(x,0,-1): if p[0:i] == p[x-i+1:x+1]: return i return 0 nxt = [getNxt(x) for x in range(len(p))] 构建next数组的复杂度显然是O(m^2)的 使用next数组加速匹配&#xA;def search(p,s): tar = 0 # 主串中将要匹配的位置 pos = 0 # 子串中将要匹配的位置 while tar &amp;lt; len(s): if s[tar] == p[pos]: # 若两个字符相同，匹配成功，tar和pos各进一步 tar += 1 pos += 1 elif pos&amp;gt;0: # 失配，且pos&amp;gt;0，则next数组移动 pos = nxt[pos-1] else: # pos[0]也失配了，则主串前进 tar += 1 if pos == len(p): # pos走到了len(p)，匹配成功 print(tar-pos) # 输出起始地点 pos = nxt[pos-1] # 当作失配，继续下一次匹配 时间复杂度为O(n+m)，会比暴力方法小很多。</description>
    </item>
  </channel>
</rss>
