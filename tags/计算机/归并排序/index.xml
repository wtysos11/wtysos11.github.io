<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机/归并排序 on 实践出真知</title>
    <link>http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
    <description>Recent content in 计算机/归并排序 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <atom:link href="http://wtysos11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>统计序列中的逆序对</title>
      <link>http://wtysos11.github.io/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link>
      <pubDate>Wed, 17 Mar 2021 20:07:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid>
      <description>因为好像做过这个题目，所以稍微提一下。最简单的方式就是归并排序 题解 方法分别是归并排序和树状数组。&#xA;归并排序 Link to heading 代码来源：https://blog.csdn.net/afei__/article/details/82951905 我觉得这个写的好一些。并且官方题解里面是写反的，我一开始还看了半天。&#xA;public class Main { public static void main(String[] args) { int[] arr = new int[] { 2, 3, 8, 6, 1 }; int inversionCount = mergeSort(arr, 0, arr.length); printArray(arr); System.out.println(&amp;#34;inversionCount: &amp;#34; + inversionCount); } public static int mergeSort(int[] arr, int start, int end) { int inversionCount = 0; int length = end - start; if (length &amp;gt; 1) { // 长度大于1才需要排序 int mid = (start + end) / 2; inversionCount += mergeSort(arr, start, mid); // sort left inversionCount += mergeSort(arr, mid, end); // sort right inversionCount += merge(arr, start, mid, end); } return inversionCount; } public static int merge(int[] arr, int start, int mid, int end) { // check input if (arr == null || start &amp;lt; 0 || end &amp;gt; arr.</description>
    </item>
    <item>
      <title>统计序列中的逆序对</title>
      <link>http://wtysos11.github.io/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</link>
      <pubDate>Wed, 17 Mar 2021 20:07:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</guid>
      <description>因为好像做过这个题目，所以稍微提一下。最简单的方式就是归并排序 题解 方法分别是归并排序和树状数组。&#xA;归并排序 Link to heading 代码来源：https://blog.csdn.net/afei__/article/details/82951905 我觉得这个写的好一些。并且官方题解里面是写反的，我一开始还看了半天。&#xA;public class Main { public static void main(String[] args) { int[] arr = new int[] { 2, 3, 8, 6, 1 }; int inversionCount = mergeSort(arr, 0, arr.length); printArray(arr); System.out.println(&amp;#34;inversionCount: &amp;#34; + inversionCount); } public static int mergeSort(int[] arr, int start, int end) { int inversionCount = 0; int length = end - start; if (length &amp;gt; 1) { // 长度大于1才需要排序 int mid = (start + end) / 2; inversionCount += mergeSort(arr, start, mid); // sort left inversionCount += mergeSort(arr, mid, end); // sort right inversionCount += merge(arr, start, mid, end); } return inversionCount; } public static int merge(int[] arr, int start, int mid, int end) { // check input if (arr == null || start &amp;lt; 0 || end &amp;gt; arr.</description>
    </item>
  </channel>
</rss>
