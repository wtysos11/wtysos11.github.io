[{"categories":["算法"],"content":"一些思考 对于博客而言，最重要的是内容。对于内容而言，最麻烦的是组织。 在我十几年前开始写我的第一篇博客的时候，我就遇到了这个问题：我该基于什么原则来划分我的内容？早年的时候是QQ空间，它只支持按照某一个选定的类别进行划分。我在使用后不久就发现，有些内容注定是跨分类的，它们没有办法简单地被某一个分类约束。到初中以后，我开始在csdn上撰写我的内容，这时候我又遇到了一个问题：CSDN上的内容是按标签进行区分的，这使得整个博客看起来很散乱。 Hugo同时具备标签（tags）和目录（categories）。 就目前来说，我希望目录更多是以专题的形式呈现，就像是集合中的划分。 而标签则类似于提供给读者的快速搜索，对于某种内容一定会存在对应的标签，从而帮助他们迅速找到内容。 此外，由于相同的标签可能会同时出现在不同的专题中，对应的内容也有所区别。比如说同样是B树，在数据结构中会更侧重于算法，但是在数据库中可能会更侧重实现与优化。因此，标签会添加前缀，而前缀会尽量靠近目录。 展望：多级目录 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:0:0","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"目录 目前的目录（categories）： ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:1:0","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"内容集中 这部分的文章只是内容上的集中，并没有结构上的安排 科研 计算机论文阅读：目前的选择是将所有的论文放在一起，不同领域的论文采用前缀+标签的形式进行实现。 科研实验 计算机基础 计算机基础：与课程相关的内容，以及与基础相关的内容 计算机课程学习笔记：对一些在线课程学习的记录 面试相关 开源代码学习笔记（同时也是代码学习笔记，不只是开源）：对某些开源库或者开源代码进行学习的笔记。可能不够写成专门的专题，但需要归结一下。（in a word, learn something) 其他 操作实践 操作实践更注重可行性而不是重复性。 事件记录：遇到了某件事情，对其进行记录。可能无法重现，或者文章中的内容不足以重现，谁知道呢（一般是对某个bug的修复总结等） codebase：有部分可能需要重复的操作，需要进行留存 与操作实践相比，则部分操作可能经常要用到，更注重重复性。 问题 资源整理：网络上的资源整理 快速复习：写作的目的是为了将来某天能用上，所以进行了大量的删减和优化来帮助之后的自己快速复习掌握。 要求：必须配上对应的最小可重现示例，最好包括对应环境的配置信息。 英语学习 无关随笔 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:1:1","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"专题类型（泛专题） 泛专题的意思是同专题内的不同文章之间没有联系 算法（专题，与面试相关部分重合） 博客 编程相关 Go基础学习：在使用Go的过程中遇到了很多基础上的问题，算是入门之后对某些东西掌握不太充分后留下来的问题。 Java基础学习 Git学习：Git是非常重要的工具，但是一直以来我对其的了解都不够充分 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:1:2","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"专题类型（细专题） 细专题是系列类型，整体可以合成为一本书。 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:1:3","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"标签 tags ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:0","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"状态类 待完善：文章还需要继续改进，完成后该标签将被取消 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:1","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"应用类 考研 学习方法 学习笔记：在学习某件事情后记录下来的东西，一般涉及到外部链接等 网络文章笔记：对某个专栏或者某篇文章进行专门学习后留下的笔记 网络视频笔记 计算机书籍阅读笔记 实验报告：可以用来指导复现的文章 问题解答：从某个问题出发进行的实验 问题延申：从SO或者其他博客上的问题解答进行的进一步延申与探索 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:2","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"学术类 论文总结 综述文章 学术_数据集 科研方向 微服务调度 云资源调度 时间序列预测 RNN Transformer ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:3","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"技术类型 后端 深度学习 机器学习 强化学习 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:4","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"计算机基础 软件测试 数据结构与算法 操作系统 linux内核 linux网络 计算机网络 计算机组成 分布式系统 软件工程 开发模式 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:5","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"编程语言类 Go Java Python ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:6","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"算法 算法题解：OJ等的题解，要求必须包含解题思路+代码，详细的还要画图 算法学习：对部分算法的学习，可以包含例题 算法思考：可以不给出具体代码，只包含思考过程 具体算法与数据结构 数据结构 算法_红黑树 算法_B树 算法_图 经典算法 算法_排序算法 具体思想 算法_字符串：字符串相关的题目 算法_动态规划 算法_搜索 算法_分治法、算法_贪心法 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:7","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"工具与框架 IDE等工具 vscode git linux命令 云相关 vagrant kubernetes docker istio 其他工具 hugo 深度学习 tensorflow keras pytorch ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:8","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"其他类 工具记录 测评 安卓软件 心理学 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:2:9","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["算法"],"content":"自动工具 目前配置了travis，自动上传algolia的index.json，并将hugo产生的页面上传到gitpage仓库下。 ","date":"2022-04-06","objectID":"/posts/%E7%BD%AE%E9%A1%B6/:3:0","tags":null,"title":"置顶：博客文章组织，目录与标签","uri":"/posts/%E7%BD%AE%E9%A1%B6/"},{"categories":["操作实践"],"content":"pageview数据介绍 维基百科pageview数据是Wikimedia技术团队所维护的访问量数据集。该数据集自2015年五月启用，其具体的pageview定义为对某个网页内容的请求，会对爬虫和人类的访问量进行区分，粒度为小时级别，如下图： ","date":"2022-04-07","objectID":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/:1:0","tags":["学术_数据集"],"title":"Wikipedia pageview数据获取(bigquery)","uri":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/"},{"categories":["操作实践"],"content":"bigquery介绍 维基百科数据可以通过其API获取。但是API只能拿到每个页面天级别的数据或者全部页面小时级的数据，如果需要获取每个页面小时级的数据，则需要通过其原始数据文件进行分析。但是这部分文件的数量实在是太多了，因此使用bigquery是一个不错的选择。 ","date":"2022-04-07","objectID":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/:2:0","tags":["学术_数据集"],"title":"Wikipedia pageview数据获取(bigquery)","uri":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/"},{"categories":["操作实践"],"content":"bigquery请求 可以使用SQL命令对其进行请求。由于数据在bigquery中使用分区表的形式存放，因此每次请求一年的数据。 以下代码以2015年的数据请求为例： WARNING：Bigquery并不是免费的，每次请求可能需要消耗十几个GB的额度，请注意！ 获取全部数据 SELECTwiki,datehour,SUM(views)astotalViewsFROM`bigquery-public-data.wikipedia.pageviews_2015`WHEREdatehourBETWEEN\"2015-01-01\"AND\"2016-01-01\"GROUPBYdatehour,wiki;获取各个语言版本维基的首页数据。这个是因为大部分维基百科的页面数量都非常小 SELECT*FROM`bigquery-public-data.wikipedia.pageviews_2020`WHEREdatehourBETWEEN\"2020-01-01\"AND\"2021-01-01\"AND((wiki='en'AND(title='Main_Page'ORtitle='Special:Search'))OR(wiki='en.m'AND(title='Main_Page'ORtitle='Special:Search'))OR(wiki='zh'AND(title='Wikipedia:首页'ORtitle='Special:搜索'))OR(wiki='de'AND(title='Wikipedia:Hauptseite'ORtitle='Spezial:Suche'))OR(wiki='fr'AND(title='Wikipédia:Accueil_principal'ORtitle='Spécial:Recherche'))OR(wiki='ja'AND(title='メインページ'ORtitle='特別:検索'))OR(wiki='ru'AND(title='Заглавная_страница'ORtitle='Служебная:Поиск'))OR(wiki='ar'AND(title='الصفحة_الرئيسية'ORtitle='خاص:بحث'))OR(wiki='ca'AND(title='Portada'ORtitle='Especial:Cerca'))OR(wiki='it'AND(title='Pagina_principale'ORtitle='Speciale:Ricerca')));top100en_Leakage：英文维基百科2015年访问量最大的前100个页面数据，但是写错了，最后变成了访问量大于100的页面。 SELECTtitleFROM(SELECTtitle,AVG(views)ASperviewsFROM`bigquery-public-data.wikipedia.pageviews_2015`WHEREdatehourBETWEEN\"2015-07-12\"AND\"2015-07-13\"ANDwiki='en'GROUPBYtitle)WHEREperviews\u003e100;top100en：英文维基百科2015年访问量最大的前100个页面数据。 SELECTwiki.datehour,wiki.title,wiki.viewsFROM(SELECTinnerViewer.title,innerViewer.perviewsFROM(SELECTtitle,AVG(views)ASperviews,COUNT(*)asviewCountFROM`bigquery-public-data.wikipedia.pageviews_2015`WHEREdatehourBETWEEN\"2015-01-01\"AND\"2016-01-01\"ANDwiki='en'GROUPBYtitleORDERBYperviews)innerViewerWHEREinnerViewer.perviews\u003e500ANDviewCount\u003e3600LIMIT100)doc,`bigquery-public-data.wikipedia.pageviews_2019`aswikiWHEREwiki.datehourBETWEEN\"2019-01-01\"AND\"2020-01-01\"ANDwiki.title=doc.titleANDwiki.wiki='en';由于各种原因，总耗费折算为人民币超过一千元。当然，并没有超过谷歌给新用户的免费额度，所以实际上应该是没有花费。为了方便之后获取，我将其上传到百度云盘上了。 防止爬虫，链接使用了base64进行加密：aHR0cHM6Ly9wYW4uYmFpZHUuY29tL3MvMWJRbll2OFUyZTZKTi1NV3c0MjJDOWc=，提取码为p3o5。 ","date":"2022-04-07","objectID":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/:2:1","tags":["学术_数据集"],"title":"Wikipedia pageview数据获取(bigquery)","uri":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/"},{"categories":["操作实践"],"content":"进一步处理 写了个python程序进行进一步的处理，以获取每个页面的pageview访问数据。 目标为得到对应页面五年来的pageview数据并保存为csv文件。该csv文件至少有两列，一列为日期，一列为小时级别的访问量。 数据使用top100en数据为基础，放在E盘的wikidata中。 from datetime import datetime import pandas as pd import matplotlib.pyplot as plt import numpy as np import os os.chdir(r\"E:\\wikidata\") # 2015的版本作为基底 dirname = 'top100en' filename = '2015.csv' baseData = pd.read_csv(dirname+'\\\\'+filename,encoding='utf-8') grouped_result = baseData.groupby('title') # convert result to dictionary baseDict = {} for name,group in grouped_result: baseDict[name] = group # 开始遍历后面的所有年份 for year in range(2016,2021): keys = list(baseDict.keys()) filename = str(year)+'.csv' yearData = pd.read_csv(dirname+'\\\\'+filename,encoding='utf-8') grouped_result = yearData.groupby('title') # 遍历所有的keys，尝试将pandas DataFrame数据进行拼接 errorList = [] for key in keys: try: newDataFrame = grouped_result.get_group(key) #将获取到的新值与旧有数据进行拼接 baseDict[key] = pd.concat([baseDict[key],newDataFrame]) except KeyError: #如果该值没有找到，则会报这个错误。此时记录下来，循环结束后将其从baseData中删除 errorList.append(key) print(\"error_list of year {}is {}\".format(year,errorList)) print('Delete them') for errorItem in errorList: del baseDict[errorItem] # 获取数据 data = baseDict[\"Donald_Trump\"] # ! 此处修改需要获取的页面名称 data.sort_values(\"datehour\",inplace=True) outputData = data[\"views\"].to_numpy() print(\"数据长度\",len(data)) # 进行改写 newDF = data[[\"datehour\",\"views\"]] newDF.columns = [\"datetime\",\"view\"] newDF[\"datetime\"] = newDF[\"datetime\"].apply(lambda x: datetime.strptime(x,\"%Y-%m-%d%H:%M:%S %Z\").strftime(\"%Y%m%d%H\")) newDF.to_csv(\"result.csv\",index=False) # 导出 ","date":"2022-04-07","objectID":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/:3:0","tags":["学术_数据集"],"title":"Wikipedia pageview数据获取(bigquery)","uri":"/posts/20220407_wikipedia_pageview%E6%95%B0%E6%8D%AE/"},{"categories":["算法"],"content":"310 最小高度树 每日一题 4月6日 给定一个树的各个边，要求选择根节点，使得树的高度最小 初步的想法是使用广度优先搜索，对于每一个根节点进行尝试，找到最小的那个。因为广度优先搜索的复杂度为O(n)，因此整体复杂度为O(n^2) #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003e#include \u003cqueue\u003eusing namespace std; struct Graph{ vector\u003cvector\u003cint\u003e\u003e arr; int node_num; Graph(int n, vector\u003cvector\u003cint\u003e\u003e edges){ this-\u003enode_num = n; this-\u003earr = vector\u003cvector\u003cint\u003e\u003e(n,vector\u003cint\u003e()); for(int i=0;i\u003cedges.size();i++){ int s,t; s = edges[i][0]; t = edges[i][1]; arr[s].push_back(t); arr[t].push_back(s); } } int bfs_maxlength(int node){ // bfs distance from node queue\u003cint\u003e q; vector\u003cint\u003e distance(this-\u003enode_num,-1); distance[node] = 0; q.push(node); int max_distance = 0; while(!q.empty()){ int cur_node = q.front(); q.pop(); for(int i=0;i\u003cthis-\u003earr[cur_node].size();i++){ int dest_node = this-\u003earr[cur_node][i]; if(distance[dest_node] == -1){ q.push(dest_node); distance[dest_node] = distance[cur_node] + 1; if(distance[dest_node] \u003e max_distance){ max_distance = distance[dest_node]; } } } } return max_distance; } }; class Solution { public: vector\u003cint\u003e findMinHeightTrees(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges) { if(n==1){ return vector\u003cint\u003e{0}; }else if(n==2){ return edges[0]; } Graph graph(n,edges); vector\u003cint\u003e result; int min_dist = n; for(int i=0;i\u003cn;i++){ int dist = graph.bfs_maxlength(i); // cout\u003c\u003c\"node \"\u003c\u003ci\u003c\u003c\" has dist \"\u003c\u003cdist\u003c\u003cendl; if(dist \u003c min_dist){ min_dist = dist; result = vector\u003cint\u003e{i}; }else if(dist == min_dist){ result.push_back(i); } } return result; } }; int main() { Solution s; vector\u003cvector\u003cint\u003e\u003e edges; edges.push_back(vector\u003cint\u003e{0,1}); edges.push_back(vector\u003cint\u003e{0,2}); edges.push_back(vector\u003cint\u003e{0,3}); edges.push_back(vector\u003cint\u003e{3,4}); edges.push_back(vector\u003cint\u003e{4,5}); // edges.push_back(vector\u003cint\u003e{1,2}); // edges.push_back(vector\u003cint\u003e{1,3}); // for(int i=0;i\u003cedges.size();i++){ // for(int j=0;j\u003cedges[i].size();j++){ // cout\u003c\u003cedges[i][j]\u003c\u003c\" \"; // } // cout\u003c\u003cendl; // } vector\u003cint\u003e result(s.findMinHeightTrees(edges.size()+1,edges)); // cout\u003c\u003cresult.size()\u003c\u003cendl; for(int i=0;i\u003cresult.size();i++){ cout\u003c\u003cresult[i]\u003c\u003cendl; } return 0; } 不出意外，直接超时。 看了一下题解，感觉自己有很多地方没有想到。 有两个应该想到的定理，一个是最大树的高度一定为最长距离的一半，另外一个是根节点一定在这个最大距离上。因此问题转换为如何求出这个最大距离。 最大距离的求解很简单，但是证明起来很麻烦，这里就不放了。原证明为算法导论9-1的解答，求解过程大致为： 从任意点出发，找到距离其最大的节点x 从节点x出发，找到距离其最大的节点y x-y即为树的直径，其路径最大。 这个是leetcode官方给的题解，如果有证明的话后面其实可以不用写了……这道题还可以用树形DP，不过我实在没弄明白。 class Solution { public: int findLongestNode(int u, vector\u003cint\u003e \u0026 parent, vector\u003cvector\u003cint\u003e\u003e\u0026 adj) { int n = adj.size(); queue\u003cint\u003e qu; vector\u003cbool\u003e visit(n); qu.emplace(u); visit[u] = true; int node = -1; while (!qu.empty()) { int curr = qu.front(); qu.pop(); node = curr; for (auto \u0026 v : adj[curr]) { if (!visit[v]) { visit[v] = true; parent[v] = curr; qu.emplace(v); } } } return node; } vector\u003cint\u003e findMinHeightTrees(int n, vector\u003cvector\u003cint\u003e\u003e\u0026 edges) { if (n == 1) { return {0}; } vector\u003cvector\u003cint\u003e\u003e adj(n); for (auto \u0026 edge : edges) { adj[edge[0]].emplace_back(edge[1]); adj[edge[1]].emplace_back(edge[0]); } vector\u003cint\u003e parent(n, -1); /* 找到与节点 0 最远的节点 x */ int x = findLongestNode(0, parent, adj); /* 找到与节点 x 最远的节点 y */ int y = findLongestNode(x, parent, adj); /* 求出节点 x 到节点 y 的路径 */ vector\u003cint\u003e path; parent[x] = -1; while (y != -1) { path.emplace_back(y); y = parent[y]; } int m = path.size(); if (m % 2 == 0) { return {path[m / 2 - 1], path[m / 2]}; } else { return {path[m / 2]}; } } }; ","date":"2022-04-07","objectID":"/posts/20220407_leetcode_310_%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/:1:0","tags":["算法题解"],"title":"Leetcode 310: 最小高度树","uri":"/posts/20220407_leetcode_310_%E6%9C%80%E5%B0%8F%E9%AB%98%E5%BA%A6%E6%A0%91/"},{"categories":["算法"],"content":"5 最长回文子串 找到的题解： https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0005.最长回文子串.md https://leetcode-cn.com/problems/longest-palindromic-substring/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-bao-gu/ 对于给定的字符串，返回其最长的回文子串。难度倒是不高，就是比较麻烦。 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:0","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"朴素暴力写法 最先想到的当然是朴素的暴力写法：从头开始枚举所有的子串，直到找到回文子串 #include \u003ciostream\u003e using namespace std; bool judgePalindrome(string s){ for(int i=0;i\u003cs.length()/2;i++){ if(s[i]!=s[s.length()-i-1]){ return false; } } return true; } class Solution { public: string longestPalindrome(string s) { int longest_length = 0; int longest_pos = 0; for(int i=0;i\u003cs.length();i++){ // 重复尝试所有的开头 // 然后尝试枚举长度，长度最小为当前的最大长度 for(int j=s.length()-i;j\u003elongest_length;j--){ //判断是否为回文子串 bool result = judgePalindrome(s.substr(i,j)); if(result){ longest_pos = i; longest_length = j; break; } } } return s.substr(longest_pos,longest_length); } }; int main() { Solution s; cout\u003c\u003cs.longestPalindrome(\"abccb\")\u003c\u003cendl; return 0; } 复杂度为O(n^3)，n为字符串长度。结果不出意外的超时了。 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:1","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"缓存探索回文点写法 另外的一个想法是，既然要判断最长的回文子串，那首先要回文。要回文，首先要相等。因此先跑一遍，用字典记录下所有字符以及其相等的位置。（已知字符仅包括数字和英文字母） 一个想法是，根据所有的相等情况从大到小枚举可能的回文点范围，并记录下回文点的位置，做一次探测。 考虑到回文子串的嵌套特性同一回文点记录回文中心和回文上界，如果长度为偶数则记录0.5。 这样，构建回文相等map的复杂度为O(n)，探索所有的相等可能性为O(n^2)，叠加上对回文串的检查一样是O(n^3)。只是由于进行了很多记忆，并且只在相等情况下搜索，因此常数项相对来说会小很多。 这个思路的一个基本想法是：对于一个更长的字符串，如果以其中心点的更小长度内曾经探明没有回文子串，那么这个子串一定不回文。 #include \u003ciostream\u003e#include \u003cmap\u003e#include \u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; bool judgePalindrome(string s){ for(int i=0;i\u003cs.length()/2;i++){ if(s[i]!=s[s.length()-i-1]){ return false; } } return true; } class Solution { public: string longestPalindrome(string s) { int longest_length = 0; int longest_pos = 0; map\u003cchar,vector\u003cint\u003e\u003e store; map\u003cdouble,int\u003e record; // record[i]=j表示在回文点i上探索过的最大长度为j for(int i=0;i\u003cs.length();i++){ store[s[i]].push_back(i); } for ( const auto \u0026myPair : store ) { // 遍历所有的key // cout\u003c\u003cmyPair.first\u003c\u003cendl; auto arr = myPair.second; if(arr.size()\u003c=1) { continue; } // for(int i=0;i\u003carr.size();i++){ // cout\u003c\u003carr[i]\u003c\u003c\" \"; // } // cout\u003c\u003cendl; for(int i=0;i\u003carr.size();i++){ for(int j=i+1;j\u003carr.size();j++){ int pos1 = arr[i]; int pos2 = arr[j]; double mid_point = (double)(pos1+pos2)/2; int cur_length = ceil(pos2-mid_point); // 如果在record中有，就不进行记录 bool isRecord = false; if(record.find(mid_point)!=record.end()){ if(record[mid_point]\u003c=cur_length){ isRecord = true; } } if(isRecord) { continue; } else if(pos2-pos1+1\u003clongest_length){ continue; } // 无记录，则进行搜索 bool result = judgePalindrome(s.substr(pos1,pos2-pos1+1)); if(result){ longest_length = pos2-pos1+1; longest_pos = pos1; }else{ // 如果小的字符串内部没有回文，那么更大的长度也不会有 record[mid_point] = cur_length; } } } } if(longest_length==0){ longest_length = 1; longest_pos = 0; } return s.substr(longest_pos,longest_length); } }; 结果挺一般的，也就属于做出来的级别 执行用时：708 ms, 在所有 C++ 提交中击败了8.91%的用户 内存消耗：322.3 MB, 在所有 C++ 提交中击败了28.12%的用户 通过测试用例：180 / 180 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:2","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"动态规划做法 此外，由于回文子串的可扩展性，是具备最优子结构的。因此这道题可以考虑用动态规划来做 确定dp数组的大小，以及其内容，代表的含义 写dp的递推公式 dp的初始值是多少 dp应该如何开始遍历，或者采用记忆化搜索的形式？ 举个例子推导dp数组 按照这个思路： 确定dp数组：dp[i,j]表示字符串[i,j]是否为回文子字符串，其内容为true/false 递推公式（默认i≤j) i==j时，dp[i,j]=true s[i]≠s[j]时，false s[i]=s[j]时，如果其子区间[i+1,j-1]同样回文，则可以递推，反之则不行。也即当dp[i+1,j-1]为true时可以递推 初始值为false，全部为匹配 确定执行顺序（注意边界）：第一个维度需要依赖其后的信息，第二个维度需要依赖前一个的信息。如果横轴为第一个维度，纵轴为第二个维度。 当前为九宫格的中心，则计算出当前结果需要从右下角算出。即遍历顺序为从最右下角向上计算。从下到上，从右到左。因此第一个维度。 执行范围为九宫格的左上三角形。这里可以设置，所有不在当前dp维度内的均为true 尝试一下手填abb 正确 #include \u003ciostream\u003e#include \u003cvector\u003e using namespace std; class Solution { public: string longestPalindrome(string s) { vector\u003cvector\u003cbool\u003e\u003e dp(s.length(),vector\u003cbool\u003e(s.length(),false)); int longest_pos = 0; int longest_length = 1; for(int j=0;j\u003cs.length();j++){ for(int i=j;i\u003e=0;i--){ if(i==j){ dp[i][j]=true; } else if((s[i]==s[j] \u0026\u0026 dp[i+1][j-1]) || (s[i]==s[j] \u0026\u0026 i+1 \u003e j-1 )){ dp[i][j]=true; } // if(dp[i][j]){ // cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cj\u003c\u003c\" \"\u003c\u003cs.substr(i,j-i+1)\u003c\u003cendl; // } if(dp[i][j] \u0026\u0026 j-i+1\u003elongest_length){ longest_length = j-i+1; longest_pos = i; } } } return s.substr(longest_pos,longest_length); } }; int main() { Solution s; cout\u003c\u003cs.longestPalindrome(\"cbbd\")\u003c\u003cendl; return 0; } 执行用时：428 ms, 在所有 C++ 提交中击败了**34.57%**的用户 内存消耗：29.4 MB, 在所有 C++ 提交中击败了**48.89%**的用户 通过测试用例：180 / 180 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:3","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"双指针方法 该方法的想法是尝试扩展。回文字符串一定是从某个中心出发的，这个中心可能是一个字符或者两个字符，因此总共应该有n+n-1个中心。 class Solution { public: int left = 0; int right = 0; int maxLength = 0; string longestPalindrome(string s) { int result = 0; for (int i = 0; i \u003c s.size(); i++) { extend(s, i, i, s.size()); // 以i为中心 extend(s, i, i + 1, s.size()); // 以i和i+1为中心 } return s.substr(left, maxLength); } void extend(const string\u0026 s, int i, int j, int n) { while (i \u003e= 0 \u0026\u0026 j \u003c n \u0026\u0026 s[i] == s[j]) { if (j - i + 1 \u003e maxLength) { left = i; right = j; maxLength = j - i + 1; } i--; j++; } } }; 执行用时：16 ms, 在所有 C++ 提交中击败了**91.46%**的用户 内存消耗：7.1 MB, 在所有 C++ 提交中击败了**79.68%**的用户 通过测试用例：180 / 180 一下子快了很多 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:4","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["算法"],"content":"马拉车算法 另外有一个专门的算法****Manacher's Algorithm****\r该算法可以解决最长回文子字符串问题，时间复杂度为线性\r```cpp\r#include \u003ciostream\u003e\r#include \u003cvector\u003e\r#include \u003cstring\u003e\r#include \u003calgorithm\u003e\rusing namespace std;\rstring preprocess(string s){\rint n=s.length();\rif(n==0){\rreturn \"^$\";\r}\rstring ret = \"^\";\rfor(int i=0;i\u003cn;i++){\rret = ret + \"#\" + s[i];\r}\rret += \"#$\";\rreturn ret;\r}\rclass Solution {\rpublic:\rstring longestPalindrome(string s) {\rstring T = preprocess(s);\rint n = T.length();\rvector\u003cint\u003e P(n,0);\rint C=0,R=0;\rfor(int i=1;i\u003cn-1;i++){\rint i_mirror=2*C-i;\rif(R\u003ei){\rP[i] = min(R-i,P[i_mirror]);\r}else{\rP[i] = 0;\r}\rwhile(T[i+1+P[i]] == T[i-1-P[i]]){\rP[i] ++;\r}\rif(i+P[i]\u003eR){\rC=i;\rR=i+P[i];\r}\r}\rint maxLen = 0;\rint centerIndex = 0;\rfor(int i=1;i\u003cn-1;i++){\rif(P[i] \u003e maxLen){\rmaxLen = P[i];\rcenterIndex = i;\r}\r}\rint start = (centerIndex - maxLen) / 2;\rreturn s.substr(start,maxLen);\r}\r};\rint main() {\rSolution s;\rcout\u003c\u003cs.longestPalindrome(\"cbbd\")\u003c\u003cendl;\rreturn 0;\r}\r```\r执行用时：**84 ms**, 在所有 C++ 提交中击败了**62.05%**的用户\r内存消耗：**312.5 MB**, 在所有 C++ 提交中击败了**28.35%**的用户\r通过测试用例：**180 / 180**\r但是这个算法实在是有点复杂 ","date":"2022-04-05","objectID":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/:1:5","tags":["算法题解","算法_字符串"],"title":"Leetcode 5: 最长回文子串","uri":"/posts/20220405_leetcode_5_%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"categories":["操作实践"],"content":"可能用到的链接与参考资料： source，应用的代码 istio ingress gateway，本文其实就是这篇文章的特化版本 ","date":"2021-10-30","objectID":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/:0:0","tags":["kubernetes","实验报告"],"title":"istio应用对外访问极速入门","uri":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["操作实践"],"content":"引言 istio所提供的可观测性对于微服务来说是非常重要的。但是在搭建istio下的服务的时候，总是会出现各种各样的问题。笔者在构建简单服务的时候也是碰到了无数奇怪的情况，而且每次构建环境的时候都差不多是一样的体验。 为此我还是将本次构建环境的过程写下来。所使用的应用是基于go iris的FFT代码，用于模拟CPU敏感的微服务组件。代码均已上传到github仓库上，希望能对后来者，特别是初学者有所助益。 本文的目标： 帮助读者了解ingress gateway的工作内容 扩展原有httpbin为自定义服务 ","date":"2021-10-30","objectID":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/:1:0","tags":["kubernetes","实验报告"],"title":"istio应用对外访问极速入门","uri":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["操作实践"],"content":"ingressgateway ingressgateway应该是istio的入口服务，可以进行负载均衡与进一步的流量控制。其在k8s中主要通过service表现其功能，使用kubectl get svc/istio-ingressgateway -n=istio-system -o=yaml可以导出其配置信息。 apiVersion:v1kind:Servicemetadata:annotations:kubectl.kubernetes.io/last-applied-configuration:|{\"apiVersion\":\"v1\",\"kind\":\"Service\",\"metadata\":{\"annotations\":{},\"labels\":{\"a pp\":\"istio-ingressgateway\",\"install.operator.istio.io/owning-resource\":\"unknown\",\"i nstall.operator.istio.io/owning-resource-namespace\":\"istio-system\",\"istio\":\"ingress gateway\",\"istio.io/rev\":\"default\",\"operator.istio.io/component\":\"IngressGateways\",\" operator.istio.io/managed\":\"Reconcile\",\"operator.istio.io/version\":\"1.11.2\",\"releas e\":\"istio\"},\"name\":\"istio-ingressgateway\",\"namespace\":\"istio-system\"},\"spec\":{\"port s\":[{\"name\":\"status-port\",\"port\":15021,\"protocol\":\"TCP\",\"targetPort\":15021},{\"name\":\"http2\",\"port\":80,\"protocol\":\"TCP\",\"targetPort\":8080},{\"name\":\"https\",\"port\":443,\" protocol\":\"TCP\",\"targetPort\":8443},{\"name\":\"tcp\",\"port\":31400,\"protocol\":\"TCP\",\"tar getPort\":31400},{\"name\":\"tls\",\"port\":15443,\"protocol\":\"TCP\",\"targetPort\":15443}],\"s elector\":{\"app\":\"istio-ingressgateway\",\"istio\":\"ingressgateway\"},\"type\":\"LoadBalanc er\"}}creationTimestamp:\"2021-09-07T09:59:49Z\"labels:app:istio-ingressgatewayinstall.operator.istio.io/owning-resource:unknowninstall.operator.istio.io/owning-resource-namespace:istio-systemistio:ingressgatewayistio.io/rev:defaultoperator.istio.io/component:IngressGatewaysoperator.istio.io/managed:Reconcileoperator.istio.io/version:1.11.2release:istioname:istio-ingressgatewaynamespace:istio-systemresourceVersion:\"8269056\"uid:914b2deb-1018-4dfd-81ff-3f2d94db2f72spec:allocateLoadBalancerNodePorts:trueclusterIP:10.110.100.72clusterIPs:- 10.110.100.72externalTrafficPolicy:ClusterinternalTrafficPolicy:ClusteripFamilies:- IPv4ipFamilyPolicy:SingleStackports:- name:status-portnodePort:30479port:15021protocol:TCPtargetPort:15021- name:http2nodePort:30001port:80protocol:TCPtargetPort:8080- name:httpsnodePort:30477port:443protocol:TCPtargetPort:8443- name:tcpnodePort:30465port:31400protocol:TCPtargetPort:31400- name:tlsnodePort:31772port:15443protocol:TCPtargetPort:15443selector:app:istio-ingressgatewayistio:ingressgatewaysessionAffinity:Nonetype:LoadBalancerstatus:loadBalancer:{}虽然是LoadBalancer类型，但是因为实验室是本地环境，也没有额外去配置Nginx，所以并没有external IP。此时ingressgateway的IP可以由export INGRESS_HOST=$(kubectl get po -l istio=ingressgateway -n istio-system -o jsonpath='{.items[0].status.hostIP}')语句获取。 主要的工作端口是http2，80-\u003e8080，这里使用NodePort将其导出进行使用：export INGRESS_PORT=$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"http2\")].nodePort}') ","date":"2021-10-30","objectID":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/:2:0","tags":["kubernetes","实验报告"],"title":"istio应用对外访问极速入门","uri":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["操作实践"],"content":"应用部署 应用构建比较简单，源代码本身也不复杂。在打包完成镜像后，就需要开始写yaml文件将应用部署上k8s。 需要注意的是： 必须确保所有的资源都在同一个namespace中。主要是复制的时候容易漏掉 由于httpbin的名称比较容易搞混，我给不同的资源使用了不同的名称。有一些内容必须要对应上。（yaml中有些项是数组，我为了简单起见我就省略了） 在Deployment中spec.selector.matchLabels必须与spec.template.metadata.labels中的一个labels匹配上 Service的targetPort和Deployment的spec.containers.ports.containerPort必须一致 Service的port和VirtualService的spec.http.route.destination.port.number必须一致，而且VirtualService的spec.http.route.destination.port.host必须是该Service的名称（我特意写成了不同的名称） Gateway的port必须和ingressgateway的port对应（这里与http2的端口对应） apiVersion:v1kind:Namespacemetadata:name:wty-istiolabels:istio-injection:enabled ---apiVersion:v1kind:Servicemetadata:name:wtyfft-svcnamespace:wty-istiospec:selector:app:wtyfft-appports:- protocol:TCPport:8000targetPort:8080---apiVersion:apps/v1kind:Deploymentmetadata:name:wtyfft-deploylabels:app:wtyfft-deploy-labelnamespace:wty-istiospec:replicas:3selector:matchLabels:app:wtyfft-apptemplate:metadata:annotations:prometheus.io/port:\"8080\"prometheus.io/scrape:\"true\"prometheus.io/path:\"/metrics\"labels:app:wtyfft-appspec:containers:- name:wtyfft-container-nameimage:registry.cn-hangzhou.aliyuncs.com/wtysos11/wty-fft:0.0.1imagePullPolicy:IfNotPresentports:- containerPort:8080resources:requests:memory:\"128Mi\"cpu:\"100m\"limits:memory:\"256Mi\"cpu:\"200m\"---apiVersion:networking.istio.io/v1alpha3kind:Gatewaymetadata:name:wtyfft-gatewaynamespace:wty-istiospec:selector:istio:ingressgateway# use Istio default gateway implementationservers:- port:number:80name:httpprotocol:HTTPhosts:- \"*\"---apiVersion:networking.istio.io/v1alpha3kind:VirtualServicemetadata:name:wtyfft-vsnamespace:wty-istiospec:hosts:- \"*\"gateways:- wtyfft-gatewayhttp:- match:- uri:prefix:/fft- uri:exact:\"/metrics\"route:- destination:host:wtyfft-svcport:number:8000","date":"2021-10-30","objectID":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/:3:0","tags":["kubernetes","实验报告"],"title":"istio应用对外访问极速入门","uri":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["操作实践"],"content":"后记 其实看例子的话就没什么困难的地方了。原来的httpbin比bookinfo的例子要好不少，我在httpbin的基础上再改了一点。希望之后的实验顺利吧。 ","date":"2021-10-30","objectID":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/:4:0","tags":["kubernetes","实验报告"],"title":"istio应用对外访问极速入门","uri":"/posts/20211030_istio%E5%BA%94%E7%94%A8%E5%AF%B9%E5%A4%96%E8%AE%BF%E9%97%AE%E6%9E%81%E9%80%9F%E5%85%A5%E9%97%A8/"},{"categories":["开源代码学习笔记"],"content":" 今天碰上了需要使用Conv1d的场景，但是对于in_channel，out_channel和kernel_size所影响的Conv1d层而进行的操作还是十分的迷惑，因此写下此篇文章记录自己的学习过程。 ","date":"2021-09-27","objectID":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/:0:0","tags":["python","学习笔记","pytorch"],"title":"Conv1d原理解析","uri":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"categories":["开源代码学习笔记"],"content":"公式 官方文档 ![formula](/assets/20210927 conv1d/Conv1d_formula.png) 从公式可以看出，输入到Conv1d中的数据有三个维度，第一个维度N一般是batch_size，第二个维度一般为in_channel，第三个维度为序列的时间维度，在NLP中为词向量大小；输出维度基本相同，但是输出的第二个维度为out_channel。 公式限定了第i个bathc_size中输出的第j个channel。在计算过程中，bias自然不必多讲，求和内的k指遍历所有的in_channel，然后使用对应的权重和指定的输入向量进行卷积操作。 ","date":"2021-09-27","objectID":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/:1:0","tags":["python","学习笔记","pytorch"],"title":"Conv1d原理解析","uri":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"categories":["开源代码学习笔记"],"content":"计算例子 如果懂的人已经可以看懂这条公式了，可是我不懂……所以还是用例子来说明一下 import torch import torch.nn as nn test_layer = nn.Conv1d(in_channels=3, out_channels=2, kernel_size=4) # 设计一个测试层，不同数据不一样，方便后面查阅 print(test_layer.weight.shape) # [2,3,4]，即公式中的weight。对于每一个out_channel和in_channel的对应，都有一个kernel_size大小的卷积核 test_data = torch.rand(1,3,10) # 输入测试数据，3个channel，时间维为10 # 概要测试 output = test_layer(test_data) print(output.shape) # [1,2,7] 2为out_channel，7为L_out，具体计算公式可参见官方文档 # 具体计算，以out(0, 0, 0)为例，即Ni=0, Coutj=0的第一个元素 print(output[0,0]) # [0.2545, 0.3342, 0.3826, 0.1345, 0.0378, 0.2512, 0.2467] print(test_data[0,0],test_data[0,1],test_data[0,2]) # tensor([0.4535, 0.6660, 0.1077, 0.7335, 0.8431, 0.2407, 0.2267, 0.1635, 0.8010, 0.5360]) # tensor([0.5334, 0.7020, 0.7540, 0.7194, 0.9105, 0.2495, 0.3046, 0.3894, 0.6813, 0.0660]) # tensor([0.5396, 0.6200, 0.7067, 0.9654, 0.8220, 0.8894, 0.5200, 0.9175, 0.6874, 0.8831]) print(test_layer.weight[0,0], test_layer.weight[0,1],test_layer.weight[0,2]) # tensor([-0.1468, -0.0057, 0.0926, 0.0263], grad_fn=\u003cSelectBackward\u003e) # tensor([ 0.1042, 0.0158, 0.2408, -0.0116], grad_fn=\u003cSelectBackward\u003e) # tensor([ 0.0223, -0.2104, 0.1971, -0.0318], grad_fn=\u003cSelectBackward\u003e ## 第0个元素的计算，即为所有的in_channel与weight上对应的kernel_size做卷积的结果 a1 = torch.sum(test_layer.weight[0,0]*test_data[0,0,0:4]) a2 = torch.sum(test_layer.weight[0,1]*test_data[0,1,0:4]) a3 = torch.sum(test_layer.weight[0,2]*test_data[0,2,0:4]) print(a1+a2+a3) # tensor(0.1890, grad_fn=\u003cAddBackward0\u003e) ## 但是第0个元素 output[0,0,0] = 0.2545，不对啊……这是因为少了bias。加上bias[0]就对了 print(test_layer.bias) # tensor([ 0.0655, -0.1095], requires_grad=True) # 另外一个例子，output(0, 1, 2)，即out_channel=1的第二个元素，值为0.3290 print(output[0,1]) print(test_data[0,0],test_data[0,1],test_data[0,2]) print(test_layer.weight[1,0], test_layer.weight[1,1],test_layer.weight[1,2]) a1 = torch.sum(test_layer.weight[1,0]*test_data[0,0,2:6]) a2 = torch.sum(test_layer.weight[1,1]*test_data[0,1,2:6]) a3 = torch.sum(test_layer.weight[1,2]*test_data[0,2,2:6]) print(a1+a2+a3) # 0.4385，减去bias[1](-0.1095)，结果正确 ","date":"2021-09-27","objectID":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/:2:0","tags":["python","学习笔记","pytorch"],"title":"Conv1d原理解析","uri":"/posts/20210927_conv1d%E5%87%BD%E6%95%B0%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"},{"categories":["无关随笔"],"content":"《心流，最优体验心理学》 ","date":"2021-09-24","objectID":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/:1:0","tags":["心理学","学习笔记","读书笔记"],"title":"《心流：最优体验心理学》读书笔记与自我思考","uri":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/"},{"categories":["无关随笔"],"content":"前言 得知心流是在研一入学前，老师和我们上的第一次课的时候。当时导师非常语重心长地跟我们说，希望我们能够在工作的过程中发现乐趣，进入到心流状态，从中收获更多的东西。当时还以为是老板为了让我们产出更多内容大的鸡血所以没放在心上^_^，但是后来在微信实习的两个多月中，我切实地感受到了心流的力量，并为之沉迷。 回到学校之后，我在读被科研所困，局促于一室之内，有种终日不得自由的感觉。很偶然的一次机会，我在微信读书上看到了这本书（我还是挺感谢自己发现微信读书这个软件的，买了会员免费读书的感觉就和在图书馆中随便抽一本书一样，阅读体验还是挺好的），给我带来了很多的思考。 这本书也不算厚，微信读书这边记录我总共的阅读时间也就三个多小时，虽然在现实时间中我断断续续读了大概一个多星期。初看这本书的时候我以为是那种庸俗的成功学、教育学鸡汤，充斥着看上去有意义但是完全没有用的废话和自我感动的桥段。但是我在翻看序言的时候就被深深地吸引住了，郑也夫先生直言不讳在序言的第一页抨击出版商将中译本不断更名造成全方位的混乱，直斥其尸位素餐，确实让我有些诧异。（虽然后来了解到他的一些生平之后发现这些其实也不算什么）序言中郑先生是从幸福的角度切入的，探讨了幸福是什么，如何获得幸福，确实让我对这本书有了更浓厚的兴趣。精神熵的提法也确实让人耳目一心，与最近我所看到的的san值也有类似的地方。如此，虽然这本书的第一印象给我不算好，我最终还是将其读完了。 ","date":"2021-09-24","objectID":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/:1:1","tags":["心理学","学习笔记","读书笔记"],"title":"《心流：最优体验心理学》读书笔记与自我思考","uri":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/"},{"categories":["无关随笔"],"content":"心流是什么 在通过这本书了解心流之前，我个人比较推荐阅读赵昱鲲序言的第二篇，从精神熵的角度切入。生命在熵增的世界中是熵减的奇迹，从无序系统中构建有序，而心流就是精神世界中的生命，让思维从混沌变得更有方向、更有结构。 心流的本质 心流的本质，我认为是对意识的控制。在我的理解中，心流是人们为了探求幸福所探索出的方法。我很难描述幸福是什么，但是我觉得我可以比较容易地描述不幸的感觉。按照马斯洛的需求金字塔，在基本的生存问题得到解决后，人们就会追求新的需求和新的愿望。对于生活在丛林的原始人来说是很难有不幸的感觉，因为他们朴素的欲望得不到满足，没有选择；但是对于现代人来说，我们永远在追求着生活品质的提高，将心力放在新的牧宝上，不能享受现在，与知足的快乐绝缘。也正是因为如此，拥有更多的物质并不能让人感到幸福，过多的选择更可能人让人感到疲惫。 第二章中的《内在失序》一节我个人在最近一段时间是比较能够体会。所有失序的现象，痛苦、焦虑、恐惧等，强迫我的注意力集中到了错误的方向，那些能够快速获得多巴胺的方向，比如电子游戏等。哪怕是我非常清楚我现在应该干什么，我在意识上也完全无法动弹。就如书中所提到的，“精神能量窒息了”。这种内在失序的现象就是精神熵增加的情况，也类似于克苏鲁世界体系下的san值降低，导致自我解体，使得效率大打折扣。 心流的定义 心流，就是让意识重新回归结构化，降低精神熵的一种行为方法。我在一开始看到这的时候第一反应就是冥想。事实上，冥想确实能强化人掌控心流的能力，增强人的注意力，让人能做回自己意识的主人。但是没有冥想也不要紧，心流的原理应该是意识运作的原理，我个人理解为“原初的快乐”。 这本书更多是从自我的角度出发，从个人来说，自己就是世界的全部。书中对此给出了例子： 古希腊哲学家埃皮克提图曾说：“人害怕的其实是自己对事物的看法，而非事物本身。”罗马哲学家皇帝马可·奥勒留也曾写道：“外界事物令你痛苦并不是因为它们打扰你，而是肇因于你对它们的判断，而你有能力立刻消弭那种判断。” 所谓的痛苦与快乐也无外乎是个人的意识，尽管很多人认为其与物质世界有很大的关联，但是这种关联其实同样取决于意识。比如说有很多人认为穷人是痛苦的，但事实上许多第三世界国家的人民幸福指数并不低。如果询问上一辈人，在他们早期贫困的时候往往生活也是充满着很多的乐趣，反而是富裕了之后很多人会感觉到无聊与疲倦。 心流的定义，要从意识运行的机制出发。意识每时每刻都在处理着外界输入的信息，并做出决断，如此的能力被称为注意力。意识是一个圆形的循环，注意力塑造着自我，也被自我塑造，塑造的效果来源于意识的反馈。心流，通过控制意识的走向，降低精神熵，使得意识收到的信息与当前的行动目标一致，用积极的反馈来强化自我，从而产生更多的注意力，照顾内心与外在环境的平衡。 心流的结果 心流的结果是生活中的最优体验，这里可以引用序五中所引用的米哈赖教授的一段话： 最优体验是人穿梭于具体的世界与遥远的心智国度间的过程；具体的生活犹如在泥沼中行走，心智的世界则是人类理解生活的灵光。人透过苦涩的生活，尤愿召唤更复杂的心智来理解生活，两者交织成一个整体。这种整体性是由简单的认知到“自我”的复杂化，使我们的心灵不再乞求于简单容易的思考，而是进入自我的彻底私密的体验，先完成主体的思考，再回来俯视自己，使自身在生活与意识之间来回地整合。就在这个过程中，我们产生了“喜悦”。 总体而言，就是精神熵的有序 ","date":"2021-09-24","objectID":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/:1:2","tags":["心理学","学习笔记","读书笔记"],"title":"《心流：最优体验心理学》读书笔记与自我思考","uri":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/"},{"categories":["无关随笔"],"content":"如何追求心流 书中第三章 心流的构成要素中《构成心流体验的要素》中的一些例子能比较好的帮助理解心流的含义，同时明确如何达成心流。作者的研究发现是，无论活动如何，在进行得极其顺利的时候，当事人的感觉总是相似的。这种感觉不分文化、现代化程度、社会阶级、年龄与性别。如此感觉，称之为心流，也即最优体验。 总体来说，作者认为乐趣包含八项元素： 面临一份可完成的工作。（可行性） 能全身关注于这件事情（专注） 有明确的目标 即使的反馈 能深入而毫不牵强地投入到行动之中，日常生活的忧虑与沮丧都因此一扫而空 充满乐趣的体验使人能自由控制自己的行动 进入忘我状态，但在心流之后自我感觉又会变得强烈。 时间感发生改变，几小时犹如几分钟，几分钟可能变得几小时。 这些元素并不总是出现，但是总是特点明显。日常中最容易达到的心流就是游戏，无论何种游戏，我都有听过“感觉时间变快”的经验，甚至自己也亲身体会过打开《文明》之后一晚上转瞬即逝，太阳马上就再度升起的感觉。 总体来说，要达到心流，必须有以下几个条件： 具备挑战性的活动 这里的“挑战性”，我个人认为是带来乐趣，或者至少不会无聊。就像是拧螺丝，如果单纯地去拧，那只是机械性的劳动。但如果去考虑如何拧地更快更好，如何拧地更久，甚至跟人去比赛，那在一些人眼中就和枯燥乏味无关了，变得有挑战性起来。 明确的目标与即使回馈 如果是挑战性是前提，这一点应当是关键。如果目标不明确，人就会迷茫；如果目标不可达到，人就会恐慌。 即使回馈也很重要。就像很多系统文数据化一些常见的数据读者可以从中感觉到爽点，或是游戏的常见套路，人们总是喜欢获得而讨厌失去，并索求着更多。某种程度上也可以说贪婪是人的本性了^_^。 全身贯注 人们最常述及的心流体验的特征就是，在心流中会把生活中所有不快乐的事情忘得一干二净。 掌握自如 所有对心流的典型描述都提到“控制感”——或说得更精确一点儿，它不像日常生活，时时要担心事态会失控。 这里指的更多是控制的可能性，而不是实际的情况。就比如说攀岩的时候，攀岩者可能会出现失误，但这并不妨碍他感觉自己能掌握下一步的动作。 作者最后还提到了一点：目标不假外求。即“自成目标”，做一件事不追求未来的报酬，做这件事本身就是最大的回馈。具体的做法可以参考原书的第四章：《如何在日常生活中寻找心流？》。从这一部分可以感觉到，游戏与心流之间的密切联系。正如我小时候所梦想的那样，能不能用玩游戏的方式来学习？事实上，如果能从学习本身获得乐趣，学习又和玩耍有何区别（毕竟都在获得多巴胺） ","date":"2021-09-24","objectID":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/:1:3","tags":["心理学","学习笔记","读书笔记"],"title":"《心流：最优体验心理学》读书笔记与自我思考","uri":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/"},{"categories":["无关随笔"],"content":"一切其他的想法 自己的目标是什么。正如序四所提到的，心流只是一个方法，它背后更大的逻辑是，我应该通过锻炼控制自己的意识，去获得真正的幸福。心流只是手段，目标应当是追求幸福。但如果走上了错误的目标，即使处在心流之中，也不过是如履薄冰，战战兢兢。 作者其实也并没有提及真正的幸福，而是描述了各种各样的乐趣：感官的乐趣、思维的乐趣、工作的乐趣、人际关系的乐趣、从挫折中获得的乐趣，以及，生命的意义。 生命的意义是十分复杂的，我现在也不知道该如何描述自己的意义。但我觉得作者对于建立复杂意义的四个阶段描述的很好： 在最初，每个人都只是想到求生、保持身体及其基本牧宝的完整性。追求舒适、生存、享乐。 当这些得到充分保障后，人可以扩张意义系统，包容家人、邻居、宗教、种族或者国家等团体的世界观和价值观。虽然会要求个人认同传统的标准和规范，但仍然能提升其复杂性 个人主义的反省，个人再次转向内心，从自我寻求权威与价值标准的新基础。不在盲目认同，开始发展独立自主的善恶观念。人生的主要目标变为追求成长、进步和实现潜能。 脱离自我，认同他人及宇宙共同的价值观，让自己的利益融入到大我的利益中。 我对第二点和第四点的理解为，第二点只是无意识地盲从，充其量是愿意牺牲，但是不会去思考真实性，追求真理。到了第四点的时候，会重新认识到个人的成长应该依托于社会，提示到大我与小我之间的关系，会寻找正确的解法，而不是看上去最正确的解法。 写下此文，希望自己在今后的生活中不要忘记此时此刻的所思所想，能够沉下心来追求真正的幸福。在最后，与即为序言作者一样，感谢中信出版社，这本书终于不会被叫做《当下的幸福》或者《快乐的真意》这种一看我就不想读的名字了（虽然在读完本书之后我觉得这两个名字取得也还挺贴切的）。也希望读者能掌握心流，引导自己的思维来追求自己所认为的幸福。 ","date":"2021-09-24","objectID":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/:1:4","tags":["心理学","学习笔记","读书笔记"],"title":"《心流：最优体验心理学》读书笔记与自我思考","uri":"/posts/20210924_%E5%BF%83%E6%B5%81%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%8E%E7%A0%94%E7%A9%B6%E6%80%9D%E8%80%83/"},{"categories":["开源代码学习笔记"],"content":"torch.einsum ","date":"2021-09-09","objectID":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/:1:0","tags":["python","学习笔记","pytorch"],"title":"torch.einsum函数学习","uri":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["开源代码学习笔记"],"content":"简单例子 基础知识见csdn，这篇博客写的比较好。简而言之，einsum就是爱因斯坦求和简记法的实现，这里引用该文的一个例子，非常好懂。 print(a_tensor) tensor([[11, 12, 13, 14], [21, 22, 23, 24], [31, 32, 33, 34], [41, 42, 43, 44]]) print(b_tensor) tensor([[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3], [4, 4, 4, 4]]) # 'ik, kj -\u003e ij'语义解释如下： # 输入a_tensor: 2维数组，下标为ik, # 输入b_tensor: 2维数组，下标为kj, # 输出output：2维数组，下标为ij。 # 隐含语义：输入a,b下标中相同的k，是求和的下标，对应上面的例子2的公式 output = torch.einsum('ik, kj -\u003e ij', a_tensor, b_tensor) print(output) tensor([[130, 130, 130, 130], [230, 230, 230, 230], [330, 330, 330, 330], [430, 430, 430, 430]]) ","date":"2021-09-09","objectID":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/:1:1","tags":["python","学习笔记","pytorch"],"title":"torch.einsum函数学习","uri":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["开源代码学习笔记"],"content":"高维案例 但是对于高维案例来说，这个简记法就么那么直观了。同样引用原文的例子 a = np.arange(60.).reshape(3,4,5) b = np.arange(24.).reshape(4,3,2) # 语义解析： # 输入a：3阶张量，下标为ijk # 输入b: 3阶张量，下标为jil # 输出o: 2阶张量，下标为k和l # 隐含语义：对i,j进行求和，公式附于代码之后： o = np.einsum('ijk,jil-\u003ekl', a, b) print(o) array([[4400., 4730.], [4532., 4874.], [4664., 5018.], [4796., 5162.], [4928., 5306.]]) # 验证： print(np.sum(a[:,:,0]*b[:,:,0].T)) 4400.0 print(np.sum(a[:,:,1]*b[:,:,0].T)) 4532.0 上述式子从k,l -\u003e kl可以猜想到其计算过程o[k,l] = a[i,j,k] * b[j,i,l]，然后每个元素分别计算出对应的值。 ","date":"2021-09-09","objectID":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/:1:2","tags":["python","学习笔记","pytorch"],"title":"torch.einsum函数学习","uri":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["开源代码学习笔记"],"content":"更加复杂 但是对于更复杂的例子，就需要进一步思考。下面对于Informer中的attention计算为例子进行进一步学习。 queries = torch.arange(0,120).view(2,3,4,5) keys = torch.arange(0,120).view(2,3,4,5) values = torch.arange(0,120).view(2,3,4,5) B, L, H, E = queries.shape _, S, _, D = values.shape scores = torch.einsum(\"blhe,bshe-\u003ebhls\", queries, keys) result = torch.zeros_like(scores) for b in range(B): for l in range(L): for h in range(H): for s in range(S): for e in range(E): result[b,h,l,s] += queries[b,l,h,e]*keys[b,s,h,e] # result[b,h,l,s] = torch.sum(queries[b,l,h,:]*keys[b,s,h,:]) 从这个例子中可以看出求和符号的计算。 ","date":"2021-09-09","objectID":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/:1:3","tags":["python","学习笔记","pytorch"],"title":"torch.einsum函数学习","uri":"/posts/20210909_torch.einsum%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["开源代码学习笔记"],"content":"torch.roll函数是真的比较难以理解，我觉得之后我碰上可能也不一定能转过弯来，因此写一篇博客记录一下。 torch.roll的文档在这里。从官方文档可以看到，torch.roll(input,shifts,dims)中的三个参数意思都是比较明确的，input即为输入的tensor，shifts表示位移的距离，dims为位移的方向。其中shifts和dims既可以为数字，也可以为元组。 其中最让人困惑的莫过于dims，特别是在高维（大于3维）的时候，基本上感觉怎么移动都不对味。比如我目前需要对一个形状为（batch_size, time_length, feature_size）的向量在时间维度上进行迁移，感觉就怎么都不对。 官方例子的改版： import torch x = torch.arange(0,9).view(3,3) # tensor([[0, 1, 2], # [3, 4, 5], # [6, 7, 8]]) torch.roll(x,-1,1) # tensor([[2, 3, 1], # [5, 6, 4], # [8, 9, 7]]) print(x[:,0]) # tensor([1, 4, 7]) 可以看到，上面这个例子在dim=1的维度进行操作，而最终这个维度上是没有发生变化的（其他维度上均发生位移）。 在三维上的例子 x = torch.arange(0,27).view(3,3,3) # tensor([[[ 0, 1, 2], # [ 3, 4, 5], # [ 6, 7, 8]], # [[ 9, 10, 11], # [12, 13, 14], # [15, 16, 17]], # [[18, 19, 20], # [21, 22, 23], # [24, 25, 26]]]) x = torch.roll(x,-1,1) # tensor([[[ 3, 4, 5], # [ 6, 7, 8], # [ 0, 1, 2]], # [[12, 13, 14], # [15, 16, 17], # [ 9, 10, 11]], # [[21, 22, 23], # [24, 25, 26], # [18, 19, 20]]]) # 效果是等价的 # \u003e\u003e\u003e torch.roll(x[0],-1,0) # tensor([[3, 4, 5], # [6, 7, 8], # [0, 1, 2]]) 通过最后的备注语句可以看到，在三维的情况下相当于是对二维的情况进行了广播，这里用PPT简单画了一下。其中的dim=1相当于图中的y-z平面。因此可以显而易见的看到，沿dim=1进行roll，相当于是把y-z平面顺次平移。 ","date":"2021-09-09","objectID":"/posts/20210909_torch.roll%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/:0:0","tags":["python","学习笔记","pytorch"],"title":"torch.roll函数学习","uri":"/posts/20210909_torch.roll%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0/"},{"categories":["问题"],"content":"本文参考这篇文章，比较了argparse、click的区别。尽管只用某一个也不是不可以，但我觉得我还是挺有必要进行一下对应的对比。 本文的目标： 本文计划实现一个带有子命令的命令行工具，同时带有全局级别的配置参数（比如数据文件地址等）。在这个前提下使用不同的标准来比较所提到的三个命令行库。 （原本计划把docopt也顺便学习一下的，但实在是没什么必要，这次就算了吧。) 下文将按照参考文章的目录进行组0织，我觉得它这个组织格式还挺有道理的 ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:0:0","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"简要介绍 分别用三种来实现子命令下共享嵌套的情况（自己动手），均失败。 目标场景：SO上的同款问题。对于给定的子命令read和write，父命令有一个--format参数，如何使得python main.py read --format=xxx成立。 ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:1:0","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"click click的写法依赖于decorator @click.command()声明子命令 @click.option('--xxx',default=x,help=xxx)与@click.argument('argumentName')声明参数 @click.group()用来实现嵌套命令 # click.group示例，执行python main.py initdb，python main.py dropdb即可，但是--debug只能在子命令下执行 import click @click.group() @click.option('--debug',default=False) def cli(debug): click.echo(f'Debug mode is {debug}') @click.command() def initdb(): click.echo('Initialized the database') @click.command() def dropdb(): click.echo('Dropped the database') cli.add_command(initdb) cli.add_command(dropdb) if __name__ == '__main__': cli() ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:1:1","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"argparse 在argparse中，子命令的实现是通过add_subparsers来实现的 import argparse def do_command_one(arg): print('command1', arg) print(arg.cmd1_option1) print(arg.foo) def do_command_two(arg): print('command1', arg) print(arg.cmd1_option1) print(arg.cmd1_option2) if __name__ == '__main__': parser = argparse.ArgumentParser() parser.add_argument('--foo', type=str) subparsers = parser.add_subparsers(help='Functinos') parser_1 = subparsers.add_parser('model', help='This is function about model') parser_1.add_argument('--cmd1_option1', type=str) parser_1.set_defaults(func=do_command_one) parser_2 = subparsers.add_parser('model2', help='This is function about model') parser_2.add_argument('--cmd2_option1', type=str) parser_2.set_defaults(func=do_command_two) args = parser.parse_args() if args.func: args.func(args) 上面这个即为我第一次学习argparse写的实例。这个脚本文件声明了两个子命令：model和model2，model会有一个命令行参数--cmd1_option1，model2会有一个命令行参数--cmd2_option1，同时全局会有一个参数--foo。 此外，使用set_defaults来设置了子命令的处理函数，以应对可能需要进行单独处理的情况。 唯一的问题是，全局参数的实现比价违背一般的习惯。python main.py --foo=\"test\" model --cmd1_option1=\"test2\" 才能通过，如果把--foo放在子命令之后是无法识别的。 (pythonProject) wutianyang@TIANYANGWU-MB0  ~/PycharmProjects/commandTest  python main.py model --cmd1_option1=\"test\" --foo=\"123\" usage: main.py [-h] [--foo FOO] {model,model2} ... main.py: error: unrecognized arguments: --foo=123 除此之外，这种写法只允许运行子命令的程序才能够通过编译，这个应该是写法的问题。 ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:1:2","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"实现需求 需求本身是很简单的，最关键的一点就是子命令之间要共享部分全局参数 ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:2:0","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"argparse SO上这个回答还挺不错的。执行python main.py create -p=\"db\"，从效果上来说确实是与预期一致。 import argparse # Same main parser as usual parser = argparse.ArgumentParser() # Usual arguments which are applicable for the whole script / top-level args parser.add_argument('--verbose', help='Common top-level parameter', action='store_true', required=False) # Same subparsers as usual subparsers = parser.add_subparsers(help='Desired action to perform', dest='action') # Usual subparsers not using common options parser_other = subparsers.add_parser(\"extra-action\", help='Do something without db') # Create parent subparser. Note `add_help=False` and creation via `argparse.` parent_parser = argparse.ArgumentParser(add_help=False) parent_parser.add_argument('-p', help='add db parameter', required=True) # Subparsers based on parent parser_create = subparsers.add_parser(\"create\", parents=[parent_parser], help='Create something') # Add some arguments exclusively for parser_create parser_update = subparsers.add_parser(\"update\", parents=[parent_parser], help='Update something') # Add some arguments exclusively for parser_update if __name__ == '__main__': arg = parser.parse_args() print(arg) print(arg.action) # action print(arg.p) # db ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:2:1","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["问题"],"content":"click click中也有类似的写法，不过是基于decorator改造的，也挺有意思的。SO问题。主要是我对于decorator也没什么研究，之后有时间了再进一步学习。 ","date":"2021-09-02","objectID":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/:2:2","tags":["python","学习笔记"],"title":"python命令行库如何实现子命令共享参数？","uri":"/posts/20210902_python%E5%91%BD%E4%BB%A4%E8%A1%8C%E7%A8%8B%E5%BA%8F%E5%AD%90%E5%91%BD%E4%BB%A4%E5%85%B1%E4%BA%AB%E5%8F%82%E6%95%B0/"},{"categories":["codebase"],"content":"机器选择使用华为云的两台x86虚拟机，HECS相对来说便宜一点。这回不用实验室的机器了，希望华为云的机子能给点力。 gist，如果只是要安装k8s可以参考这个脚本。可能还是有点问题（我是在root下跑完的），sudo支持上可能有遗漏的地方。 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:0:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"创建用户 useradd -g root wty usermod -a -G sudo wty 创建/home/wty ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:1:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"更新软件 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:2:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"更新apt 换源，更新apt（可以省略，华为云内网速度应该更快一些） deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:2:1","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"安装并配置zsh sudo apt-get install zsh安装zsh 执行sh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"进行配置 (国内)gitee镜像 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:2:2","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"安装并配置git git config --global user.name \"wtysos11\" git config --global user.email wtysos11@163.com ssh-keygen -t rsa -C \"wtysos11@163.com\" 上传公钥到github ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:2:3","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"安装docker https://yeasy.gitbook.io/docker_practice/install/ubuntu https://docs.docker.com/engine/install/ubuntu/ 使用脚本安装 curl -fsSL get.docker.com -o get-docker.sh sudo sh get-docker.sh --mirror Aliyun usermod -aG docker $USER 参考官方教程配置docker root用户执行service docker start启动进程 普通用户执行sudo groupadd docker创建用户组 sudo usermod -aG docker $USER加入用户组 重新登陆，或者执行newgrp docker 执行docker run hello-world尝试安装是否成功 配置镜像加速：阿里云。由于使用了阿里云，就不进行docker login了。 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:3:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"安装kubernetes ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:4:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"配置apt仓库 参考，配置apt仓库并安装对应的二进制组件（如果对版本没有要求可以不进行指定） sudo apt-get update \u0026\u0026 sudo apt-get install -y apt-transport-https curl https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add - cat \u003c\u003c EOF \u003e /etc/apt/sources.list.d/kubernetes.list deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main EOF sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl # sudo apt-get install -y kubelet=1.23.4-00 kubeadm=1.23.4-00 kubectl=1.23.4-00 启动kubelet，运行情况检查 systemctl status kubelet查看情况 journalctl -xeu kubelet输出日志 遇到问题：kubelet shutdown 报错信息\"Failed to run kubelet\" err=\"failed to run Kubelet: misconfiguration: kubelet cgroup driver: \\\"systemd\\\" is different from docker cgroup driver: \\\"cgroupfs\\\"\" 从报错信息来看，应该是docker的cgroup driver和kubelet的cgroup driver不一致的问题。 参考SO的解决方案，在docker的配置文件(/etc/docker/daemon.json)中加上了\"exec-opts\": [\"native.cgroupdriver=systemd\"]，然后使用sudo systemctl restart docker即可（PS：即使是新开启的docker也必须执行） 遇到问题：failed to load kubelet config file Aug 26 16:17:48 k8s-master systemd[1]: kubelet.service: Service hold-off time over, scheduling restart. Aug 26 16:17:48 k8s-master systemd[1]: kubelet.service: Scheduled restart job, restart counter is at 87. -- Subject: Automatic restarting of a unit has been scheduled -- Defined-By: systemd -- Support: http://www.ubuntu.com/support -- -- Automatic restarting of the unit kubelet.service has been scheduled, as the result for -- the configured Restart= setting for the unit. Aug 26 16:17:48 k8s-master systemd[1]: Stopped kubelet: The Kubernetes Node Agent. -- Subject: Unit kubelet.service has finished shutting down -- Defined-By: systemd -- Support: http://www.ubuntu.com/support -- -- Unit kubelet.service has finished shutting down. Aug 26 16:17:48 k8s-master systemd[1]: Started kubelet: The Kubernetes Node Agent. -- Subject: Unit kubelet.service has finished start-up -- Defined-By: systemd -- Support: http://www.ubuntu.com/support -- -- Unit kubelet.service has finished starting up. -- -- The start-up result is RESULT. Aug 26 16:17:48 k8s-master kubelet[27908]: E0826 16:17:48.885345 27908 server.go:206] \"Failed to load kubelet config file\" err=\"failed to load Kubelet config file /var/lib/k ubelet/config.yaml, error failed to read kubelet config file \\\"/var/lib/kubelet/config.yaml\\\", error: open /var/lib/kubelet/config.yaml: no such file or directory\" path=\"/var/ lib/kubelet/config.yaml\" Aug 26 16:17:48 k8s-master systemd[1]: kubelet.service: Main process exited, code=exited, status=1/FAILURE Aug 26 16:17:48 k8s-master systemd[1]: kubelet.service: Failed with result 'exit-code'. Aug 26 16:17:59 k8s-master systemd[1]: kubelet.service: Service hold-off time over, scheduling restart. Aug 26 16:17:59 k8s-master systemd[1]: kubelet.service: Scheduled restart job, restart counter is at 88. -- Subject: Automatic restarting of a unit has been scheduled -- Defined-By: systemd -- Support: http://www.ubuntu.com/support -- 报错信息主要是failed to load kubelet config file 参考issue/65863的一个回答。不过这个问题可以直接通过kubeadm init解决（简单来说就是不用管） 其他问题 kubeadm: Configuring a cgroup driver提到v1.22版本中，如果用户没有指定cgroupDriver的会默认为systemd。目前我用的正是1.22.1版本，应该是这个值没有设置为cgroupfs的问题 # kubeadm-config.yamlkind:ClusterConfigurationapiVersion:kubeadm.k8s.io/v1beta3kubernetesVersion:v1.22.1---kind:KubeletConfigurationapiVersion:kubelet.config.k8s.io/v1beta1cgroupDriver:cgroupfs","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:4:1","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"通过kubeadm安装k8s集群 官网教程，还是比较推荐的，唯一的问题就是没有考虑到国内访问不到谷歌的问题 预先配置 交换与防火墙 top内查看是否开启交换，开了要关闭 关闭防火墙 网络 官网“允许iptables检查桥接流量”一节提到lsmod | grep br_netfilter来检查br_netfilter模块被加载 cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 配置cgroup为systemd kubelet这边可以不用管，默认是systemd。需要按照[kubelet shutdown](#遇到问题：kubelet shutdown)内的操作来修改容器运行时的cgroup，不然Kubelet会启动不了。（按照官方的说法，不建议修改kubelet的cgroup为cgroupfs） 正式安装 可以参考我之前配置时的教程。不过当时并没有做可重复性相关的验证。 首先使用kubeadm config images list列出kubeadm所需要的所有镜像 k8s.gcr.io/kube-apiserver:v1.22.1 k8s.gcr.io/kube-controller-manager:v1.22.1 k8s.gcr.io/kube-scheduler:v1.22.1 k8s.gcr.io/kube-proxy:v1.22.1 k8s.gcr.io/pause:3.5 k8s.gcr.io/etcd:3.5.0-0 k8s.gcr.io/coredns/coredns:v1.8.4 执行以下命令进行安装： sudo kubeadm init --apiserver-advertise-address=10.186.117.4 --pod-network-cidr=10.244.0.0/16 --token-ttl=0 --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers 命令参考：官方，也可以在命令行下查看。 apiserver-advertise-address：这个参数指定了监听的API地址。若没有设置，则使用默认网络接口。我使用的是华为云的服务器，这里填master节点的地址即可（要求能被其他节点访问到） apiserver-bind-port：这个参数指定了API服务器暴露出的端口号，默认是6443。 pod-network-cidr：规定了pod能够使用的IP地址段。我之前用的是16位子网掩码，但是现在给的子网就是24位掩码，我也不确定使用其他子网能不能行……先保险起见吧。 kubernetes-version：指定kubeadm安装的kubernetes版本。这个是很重要的，因为默认情况下kubeadm会安装与它版本相同的kubernetes版本，而由于国内的网络问题，每次都需要重新下载一遍镜像，非常的麻烦。如果之后版本使用这个脚本，可以加上--kubernetes-version=v1.19.2 image-repository：默认是\"k8s.gcr.io\"。我觉得如果修改这个可以不用像之前那样从阿里云下载下来后手动tag。可以使用kubeadm config images pull --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers，参考 token-ttl：令牌被删除前的时间，默认是24h。kubeadm初始化完毕后会生成一个令牌，让其他节点能够加入集群，过时之后这个令牌会自动删除。如果设置为0之后令牌就永不过期。 这一步的难点在于如何设置pod-network-cidr，参数的作用。根据官方教程的说法，Pod网络与任何主机网络不得有重叠。但是目前我看到的很多教程都是在主机局域网络下构建的。比如说三台主机都在192.168.1.1/16子网，而pod网络也在同样的子网下。 这个参数的设置似乎与所使用的CNI有关系： flannel，要求的参数为--pod-network-cidr=10.244.0.0/16 calico，要求的参数为--pod-network-cidr=192.168.0.0/16 本文采用flannel，一个很重要的原因是因为服务器的子网与pod的子网部分重叠，可能存在风险，以及flannel似乎更容易部署一些。 值得注意的是，在coredns镜像中，只有x.x.x，而没有vx.x.x，所以需要手动改一下。也可以参考zhangguanzhang的工具来直接同步 如果image-repository不可用可以考虑下面的脚本 ######################################################################### # File Name: pull_master_image.sh # Description: pull_master_image.sh # Author: zhangyi # mail: 450575982@qq.com # Created Time: 2019-07-31 21:38:14 ######################################################################### #!/bin/bash kube_version=:v1.22.1 kube_images=(kube-proxy kube-scheduler kube-controller-manager kube-apiserver) addon_images=(etcd:3.5.0-0 coredns:1.8.4 pause:3.5) for imageName in ${kube_images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version docker image tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version k8s.gcr.io/$imageName$kube_version docker image rm registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version done for imageName in ${addon_images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName docker image tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName docker image rm registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName done 之后，需要执行这三条命令，其作用是将kubectl所需要的配置文件拉到用户目录下并设置访问权限。（不执行的话kubectl是无法正常工作的） mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config 有时可能需要显示配置export KUBECONFIG=$HOME/.kube/config。 如果是使用root用户需要设置export KUBECONFIG=/etc/kubernetes/admin.conf。 使用kubectl get pods -n=kube-system可以查看所有的系统容器，这时候coredns可能没有运行，这个没有关系，等flannel装上之后就好了。 untaint 对于小集群，必须要执行kubectl taint nodes --all node-role.kubernetes.io/master-，不然调度的时候会少一台机子。 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:4:2","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"安装flannel 参考flannel官方教程， curl -fsSL https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml \u003e kube-flannel.yml下载配置文件 kubectl apply -f kube-flannel.yml 日志记录： ➜ ~ kubectl apply -f kube-flannel.yml Warning: policy/v1beta1 PodSecurityPolicy is deprecated in v1.21+, unavailable in v1.25+ podsecuritypolicy.policy/psp.flannel.unprivileged created clusterrole.rbac.authorization.k8s.io/flannel created clusterrolebinding.rbac.authorization.k8s.io/flannel created serviceaccount/flannel created configmap/kube-flannel-cfg created daemonset.apps/kube-flannel-ds created 可能出现的问题： flannel需要镜像quay.io/coreos/flannel:v0.14.0，之前安装的时候没有办法抓下来。不过这次成功搞下来了，可能是阿里云的镜像服务又更进一步了？ 此时，k8s的安装就基本完成了，后续就自由发挥了。 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:4:3","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"istio安装 按照官网指南安装即可，这个版本的istio安装基本不会出现问题 ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:5:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["codebase"],"content":"其他问题 安装flannel时提示open /run/systemd/resolve/resolv.conf: no such file or directory，经过检查发现是节点的systemd-resolved出现问题，systemctl status systemd-resolved中状态为Inactive。直接使用systemctl restart systemd-resolved重启对应的DNS服务即可。 端口问题。因为在内网配置了比较严格的安全策略，需要手动打开但偶才能正常工作。其中kubernetes的api-server默认是在6443端口下工作，istio则需要15021端口。而且coreDNS需要UDP53端口……如果可以的话测试环境建议全打开，鬼知道是在哪里被卡的。 新节点加入：在之后还有节点要加入的话，可以在主节点执行kubeadm token create --print-join-command ","date":"2021-08-25","objectID":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/:6:0","tags":["实验报告","kubernetes"],"title":"华为云服务器ubuntu18.04环境下构建k8s多机集群","uri":"/posts/20210825_ubuntu%E4%B8%8B%E6%9E%84%E5%BB%BAk8s%E5%A4%9A%E6%9C%BA%E9%9B%86%E7%BE%A4/"},{"categories":["博客"],"content":" 前面可能比较啰嗦，属于前言部分。如果要看博客构建的具体细节请到“构建过程”一节。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:0:0","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"构建之初 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:0","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"博客写作历程 QQ空间 我在非常久之前就开始写博客了，最早的时候是在QQ空间上。我印象中我应该是2004年开始上小学，所以是三年级开始进行连载。一直以来我觉得我都不是很愿意用语言和别人表达自己的观点，因此在很长一段时间内我都是通过博客来记录自己的想法。由于我记忆力也不是很好，博客对于我来说更像是外接硬盘，而不是而别人交流的手段。通过阅读之前写的博客，我能够很快了解到自己之前的想法。这个习惯也延续到了今天。 CSDN 在初中的时候，一次很偶然的机会，麻玉国老师在某次电脑课之后说有课后对编程有兴趣的同学可以之后留下来，在那堂编程课之后我开始接触编程，开始在CSDN上连载博客，参加NOIP。尽管对编程还是很感兴趣的，一直以来也没拿什么奖，甚是可惜。即使后来从七十五种毕业去了华附，当时的华附的信息学社在校内的五大学科竞赛中也是打酱油水平。与其他学科动不动出个国家集训队的辉煌成绩（包括天文，王远浩的国际天文银牌我一直记忆尤新，大佬大佬）相比，信息学社属于省一都要看年份的苦逼水平。没人教，也没什么动力学，我在水了个省二之后就去准备高考了。CSDN上那段时间也记录了我在一些OJ上的题解。 迷茫期 到了大三以后，CSDN变得越来越累赘，各种各样的推荐、广告层出不穷。最关键的是，csdn上的文章质量也越来越差，我曾经不止一次听人说过-csdn能优化搜索结果的说法。因此我开始尝试在博客园、知乎、简书上连载，但感觉都很麻烦。这段时间内对我印象最深的是中山大学的潘茂林老师，我现在也还在他所在的实验室内工作。潘老师算是我在中大这4+2年内少有的几个真正教了我一些东西的老师，尽管在科研上并不出色，但在教学理念上潘老师确实算的上是很有特色。我记得他在2017年左右就开设了服务计算，开始教golang、docker和kubernetes相关的内容，这在整个国内都算得上是非常前言。他的Unity3D设计课程也让我印象比较深刻，通过Unity游戏设计教授设计模式的方式让人耳目一新。我个人还是希望中山大学除了科研之外，应该多聘请一些想潘老师这种在教学上有一家之长的老师来负责学生的教学工作。 github issue ……扯远了，在潘老师的课程中，我第一次非常大量地使用markdown来编写文字资料。markdown的好处是够简单，尽管我之前大一大美赛的时候也学习过latex，但是将latex作为写文章的习惯对于我来说还是太过困难了（当然，我听说MIT某位著名大佬能以跟上讲课的速度用latex记笔记）。跟vim一样，latex的特点实在过于鲜明，我不太希望在日常中使用它。因此，我开始在github上用markdown来编写资料。 最开始的时候是在github仓库内部，但是在仓库内就不得不遇到一个问题：我必须有完整的Git环境才能够开始写文档。但是很多时候我并不一定有这个环境，有了git提交环境其实也懒得打开文本编辑器。最开始只是偷懒，使用issue来进行写作，并在之后将内容同步到仓库上去。有一天我突然在想，issue有着完整的label支持，用起来比csdn舒服多了，我为什么不直接使用issue来写文章呢？ 如此，就有了我用了很久的博客。其实最开始还有一个，但是因为涉及到一些秘密信息被我转成private了。 github issue的问题 但是使用issue也有一个问题，它必须联网才能访问。在之前在仓库内写作的时候，对网络其实并没有很高的要求。但是issue必须要联网才能更新，甚至是获取之前的功能。由于在国内，即使连着梯子，有些时候对github的访问速度也是存在问题，特别是图片经常加载不出来，这给我带来了很大的麻烦。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:1","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"此博客的缘由 其实这才是这个博客真正意义上的第一篇文章，此前的文章都是从其他地方迁移过来的。 在腾讯实习的这些天内，我在KM社区上看到了很多有价值的文章，也阅读了很多大佬们记录下来的经验分享与总结。随着我工作和学习的不断深入，我愈发感觉到自己学习能力的界限，于是有了将自己的想法更多记录下来的冲动。之前的github issue除了访问的问题之外，也存在着github停止服务带来丢失的风险。因此，我捡起了两年前自己使用过的github.io，并用hugo来构建静态博客页面：wtysos11.github.io 博客名为实践出真知，也是警示自己无论何时都不能脱离实践，空对空的看待、讨论问题。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:1:2","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"构建过程 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:0","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"hugo设置 本博客使用了hugo loveit主题，hugo的入门实在过于简单，也不是本文讨论的重点。详情可以阅读loveit主题提供的入门文档。hugo设置上的主要难点在于配置文件config.toml，对此，可以参考我博客仓库的对应配置文件config.toml。入门文档的2.3基础配置一节中提供了loveit所采用的默认设置，但是实践发现很多的默认设置是需要手动粘贴到配置文件中才能够实现其功能的。 languages：多语言设置相关，下文会介绍 params：主要的设置部分 params.footer：主页下标，在国内要注意ICP备案。我之前搞过，这次就不备案了，太麻烦了。 params.search：搜索相关，会在algolia搜索设置详细说明 params.social：社交相关，会在首页的最上方以图标的形式显示社交媒体联系方式 params.page：文章相关，比如评论就是在这里开启的 menu：菜单设置。在languages设置后会被覆盖 author：需要在此处设置作者，之后文章中就可以不用设置了 sitemap：SEO设置相关，在让博客被google等搜索引擎收录一节会提到 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:1","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"前置参数 loveit支持很多前置参数，主要需要注意的有几点： summary：主页所显示的摘要。这个没有直接出现在“前置参数”一节，而是在后面提到了 featuredImage：所谓的特色图片，就是在文章在主页时上面会附上的图片。 lastmod：上次修改内容的日期时间。这个完全不会出现，不知道被改成什么了。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:2","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"图片插入问题 目前loveit还不支持ResourcePage，因此所有的图片必须放在/static/asserts目录下。在编译之后，/static内的所有文件会直接被放在根目录下，此时图片设置为/asserts/foldername/xxx.png即可，比如本文前面的图片就是用这种方式插入的。这样做的话之后做CDN也会方便一些，设置一个全局变量统一替换掉就可以了。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:3","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"评论设置 本文采用utterances作为评论设置，配置文件如下： [params.page.comment] enable = true [params.page.comment.utterances] enable = true # owner/repo repo = \"wtysos11/hugo-blog-comment\" issueTerm = \"pathname\" label = \"\" lightTheme = \"github-light\" darkTheme = \"github-dark\" utterances配置起来非常简单，它使用github仓库的issue功能来作为评论存储的位置，因此也不需要额外的配置。 参考官网，做法如下： 创建一个新的仓库，比如上文中我使用的是hugo-blog-comment'; 安装utterances app，在对应的那个仓库安装就好了; 按如上将信息加入到配置文件中，就可以了。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:4","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"多语言设置 hugo自身支持了多语言设置，只需要修改根目录下的config.toml即可完成对应语言的设置（默认语言）在设置了多语言之后，/content/posts中的文章中对应的多语言版本会被解析。比如test.en.md会被en识别到，而其他文章依旧会处于简体中文状态。具体效果可以参考官方demo。 如下为本博客在此时所采用的多语言设置参数： languageCode = \"zh-CN\" # 默认语言由此决定 [languages] [languages.en] weight = 1 title = \"Practise make perfect\" # title必须重新写，会覆盖掉之前的 languageCode = \"en\" languageName = \"English\" [[languages.en.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"Posts\" url = \"/posts/\" # URL是可以重复的 title = \"\" weight = 1 [[languages.en.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"Tags\" url = \"/tags/\" title = \"\" weight = 2 [[languages.en.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"Categories\" url = \"/categories/\" title = \"\" weight = 3 [languages.en.params] description = \"Blog of backend technology\" keywords = [\"go\",\"kubernetes\"] [languages.zh-cn] weight = 2 title = \"实践出真知\" # 网站语言, 仅在这里 CN 大写 languageCode = \"zh-CN\" languageName = \"简体中文\" # 是否包括中日韩文字 hasCJKLanguage = true [[languages.zh-cn.menu.main]] identifier = \"posts\" pre = \"\" post = \"\" name = \"文章\" url = \"/posts/\" title = \"\" weight = 1 [[languages.zh-cn.menu.main]] identifier = \"tags\" pre = \"\" post = \"\" name = \"标签\" url = \"/tags/\" title = \"\" weight = 2 [[languages.zh-cn.menu.main]] identifier = \"categories\" pre = \"\" post = \"\" name = \"分类\" url = \"/categories/\" title = \"\" weight = 3 [languages.zh-cn.params] description = \"后端技术博客\" keywords = [\"go\",\"kubernetes\"] ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:2:5","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"之后的问题 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:0","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"algolia搜索设置 loveit支持两种搜索：lunr和algolia。lunr性能实在堪忧，特别是对于中文而言基本上不能用。因此我还是配置了algolia，社区版10000条（不知道是按什么计算的，反正肯定不是按文章）搜索项，每月10000次搜索，对于小网站来说也够用了。之后我打算抽空自己用微服务写一个，到时候和博客挂在一起。 操作： 前往官网注册账号 在左侧第二个Indices下选择New，创建Index（我的名称为myblog） 在API Keys上拿到Search-Only API Key作为searchKey和Application ID作为appID。 [params.search] enable = true type = \"algolia\" contentLength = 4000 placeholder = \"\" maxResultLength = 10 snippetLength = 50 highlightTag = \"em\" absoluteURL = false [params.search.algolia] index = \"myblog\" appID = \"46GYFZ8M81\" searchKey = \"10948d6f4e69e7991b7a4f9cb5095f13\" [outputs] home = [\"HTML\", \"RSS\", \"JSON\"] # 这个一定要带上JSON，不然不会产生对应的JSON文件 每次hugo命令之后会产生/public/index.json文件，需要将这个文件上传到algolia中 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:1","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"用travis进行自动化部署 algolia的问题在于每次录入新文章之后都需要更新index.json，实在是太过麻烦，本文选择使用atomic-algolia来自动产生对应的文件。 自行安装Node 在当前目录下执行npm init（一路回车即可），然后npm install atomic-algolia 修改package.json，在scripts中加入\"algolia\":\"atomic-algolia\"。最终应该如下 \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" \u0026\u0026 exit 1\", \"algolia\": \"atomic-algolia\" }, 在.env中输入对应的信息，其中ALGOLIA_ADMIN_KEY在之前algolia的AppID页面内。千万不要让ALGOLIA_ADMIN_KEY出现在github仓库内 ALGOLIA_APP_ID=46GYFZ8M81\rALGOLIA_INDEX_NAME=myblog\rALGOLIA_INDEX_FILE=public/index.json\rALGOLIA_ADMIN_KEY=XXX 如果不想配置自动化部署的话，每次就执行一遍npm run algolia即可 下面配置travis。在仓库内放入.travis.yml文件 # ref: https://gaojila.github.io/hugo%E4%BD%BF%E7%94%A8algolia%E6%90%9C%E7%B4%A2/language:gogo:- \"1.13\"# 指定Golang 1.13install:# 安装最新的hugo- wget https://github.com/gohugoio/hugo/releases/download/v0.87.0/hugo_0.87.0_Linux-64bit.deb- sudo dpkg -i hugo*.deb# 安装搜索插件- npm install atomic-algolia --save-devscript:# 运行hugo命令- hugo# 生成索引命令- echo \"ALGOLIA_ADMIN_KEY=$ALGOLIA_ADMIN_KEY\" \u003e\u003e .env- npm run algoliaafter_script:# 部署- git config --global user.name \"wtysos11\"- git config --global user.email \"wtysos11@163.com\"# - git config --global credential.helper \"store --file=.git/credentials\"# - echo \"https://${GITHUB_TOKEN}:@github.com\" \u003e .git/credentials- cd ./public- git add .- git commit -m \"Update Blog By TravisCI With Build $TRAVIS_BUILD_NUMBER\"# Github Pages- git push https://wtysos11:${GITHUB_TOKEN}@${GH_REF} HEAD:masterdeploy:provider:pages# 重要，指定这是一份github pages的部署配置skip-cleanup:true# 重要，不能省略local-dir:public# 静态站点文件所在目录# target-branch: master # 要将静态站点文件发布到哪个分支github-token:$GITHUB_TOKEN# 重要，$GITHUB_TOKEN是变量，需要在GitHub上申请、再到配置到Travis# fqdn: # 如果是自定义域名，此处要填keep-history:true# 是否保持target-branch分支的提交记录on:branch:master# 博客源码的分支然后在travis官网内注册，对所有仓库（或者指定仓库也可以）安装对应的app。 参考官方指导获取github token并配置，再按照同样的方式配置ALGOLIA_ADMIN_KEY和GH_REF（比如github.com/wtysos11/wtysos11.github.io.git） 这里需要注意的是Settings好像不会在第一次的时候被刷出来，我第一次进到仓库页面时是没有的。要从上面的Dashboard内进入到Active repositories，再按对应仓库右侧的详情才能第一次进入，不知道是不是bug。 完成之后只需要提交即可。上述方法是没有git init的，因为我是使用git submodule来关联两个仓库的。如果没有这种关联的话需要先git init，然后在git push后加上-f参数。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:2","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"让博客被google等搜索引擎收录 Google等的SEO设置，让博客显示在这些页面上 首先可以在搜索引擎上输入site:wtysos11.github.io来检查是否被收录，一般刚放上去都是没有的。可以按照以下步骤 注册SEO 选择放静态页面，并下载 把拿到的静态页面丢到/static文件夹下面 可以先hugo serve看一下能不能访问 更新 确认能访问后在SEO页面进行确认 一般是没什么问题的。 sitemap问题：一般sitemap都是默认配置好的，如果没有用多语言版本则在/sitemap.xml下；否则在对应的多语言版本下，比如/zh-cn/sitemap.xml。需要注意的是google search console在配置sitemap的时候会有Couldn’t fetch的问题，这个好像是个bug，而且也没什么解决方案。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:3","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"DNS污染问题 国内有些时候会出现github.io访问不到的问题，如果ping对应网址会发现指向了127.0.0.1。 首先检查dns，命令行输入nslookup xxx.github.io，如果解析的IP正确，那直接ipconfig /flushdns即可 否则，选择其他的DNS，比如阿里云的223.5.5.5这些，然后再刷DNS 再不行只能配hosts了，这里就不展开了。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:4","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"图片本地编辑问题 由于前面提到，图片使用的是相对本地的路径，如果不加配置的话是无法再本地环境（比如typora或者vscode）下正确预览图片的。没有所见即所得会比较麻烦。配置的话，typora可以选择设置图片根目录，按下图一样选择，然后将图片根目录设置为根目录的/static即可。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:3:5","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["博客"],"content":"展望 自定义SCSS：loveit主题美化 标签的进一步丰富：目前标签没有办法被归类，其实还挺麻烦的 最关键的还是内容。不是为了写博客而写博客，而是为了自身的积累而写博客。博客应该作为手段而不是目的。 ","date":"2021-08-25","objectID":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/:4:0","tags":["实验报告","hugo"],"title":"hugo loveit构建github page博客","uri":"/posts/20210825_%E5%8D%9A%E5%AE%A2%E6%9E%84%E5%BB%BA%E8%AE%B0%E5%BD%95/"},{"categories":["Go基础学习"],"content":"最近在SO上找到了一个很有意思的问题： 这个问题是关于一个指针在外部函数的赋值，当然，解决方法也很简单。 type userIP net.IP func main() { var u *userIP u.defaultIP() fmt.Printf(\"%v\\n\", u) } func (u *userIP) defaultIP() { defaultIP := userIP(\"127.0.0.1\") u = \u0026defaultIP } 但是为什么会这样？如果是学过C风格指针的话应该会发现这条语句是很奇怪的，从语法上讲u中存放的地址会被改变，但是实际上它并不会改变（PS：原来的这个代码需要修改一下，不然会有dereference nil的错误） ","date":"2021-07-15","objectID":"/posts/20210715_%E5%85%B3%E4%BA%8Egolang%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/:0:0","tags":["Go","问题延申"],"title":"关于golang中指针赋值的问题","uri":"/posts/20210715_%E5%85%B3%E4%BA%8Egolang%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["Go基础学习"],"content":"修改后的例子 package main import ( \"fmt\" \"net\" ) type userIP net.IP func main() { s:= userIP(\"123.2.2.1\") var u *userIP = \u0026s fmt.Printf(\"address of s %p\\n\",\u0026s) fmt.Printf(\"what's in u? u = %p, \u0026u = %p\\n\",u,\u0026u) fmt.Println(\"In main function\") fmt.Printf(\"main(): address of pointer is %v, address inside pointer is %p\\n\", \u0026u,u) fmt.Printf(\"main(): user IP address is %s\\n\", *u) u.defaultIP() fmt.Println(\"After executing defaultIP\") fmt.Printf(\"main(): address of pointer is %v, address inside pointer is %p\\n\", \u0026u,u) fmt.Printf(\"main(): user IP address is %s\\n\", *u) hyperIP(\u0026u) fmt.Println(\"After executing hyperIP\") fmt.Printf(\"main(): address of pointer is %v, address inside pointer is %p\\n\", \u0026u,u) fmt.Printf(\"main(): user IP address is %s\\n\", *u) } func (u *userIP) defaultIP() { defaultIP := userIP(\"127.0.0.1\") u = \u0026defaultIP fmt.Println(\"In function defaultIP\") fmt.Printf(\"defaultIP(): address of pointer is %v, address inside pointer is %p\\n\", \u0026u,u) fmt.Printf(\"defaultIP(): user IP address is %s\\n\", *u) } func hyperIP(u **userIP) { defaultIP := userIP(\"129.0.0.1\") *u = \u0026defaultIP fmt.Println(\"In function hyperIP\") fmt.Printf(\"hyperIP(): address of pointer is %v, address inside pointer is %p\\n\", \u0026u,u) fmt.Printf(\"hyperIP(): user IP address is %s\\n\", *u) } 通过上面这个例子可以进一步揭示问题，输出结果如下： address of s 0xc0000044c0\rwhat's in u? u = 0xc0000044c0, \u0026u = 0xc000006028\rIn main function\rmain(): address of pointer is 0xc000006028, address inside pointer is 0xc0000044c0\rmain(): user IP address is 123.2.2.1\rIn function defaultIP\rdefaultIP(): address of pointer is 0xc000006038, address inside pointer is 0xc000004520\rdefaultIP(): user IP address is 127.0.0.1\rAfter executing defaultIP\rmain(): address of pointer is 0xc000006028, address inside pointer is 0xc0000044c0\rmain(): user IP address is 123.2.2.1\rIn function hyperIP\rhyperIP(): address of pointer is 0xc000006040, address inside pointer is 0xc000006028\rhyperIP(): user IP address is \u0026129.0.0.1\rAfter executing hyperIP\rmain(): address of pointer is 0xc000006028, address inside pointer is 0xc000004580\rmain(): user IP address is 129.0.0.1 可以看到，对于主函数中的指针u，其地址为0xc000006028，其存放的地址为0xc0000044c0，这个与声明的变量是一致的。 问题在于，传入函数中的指针的地址是变动的，也就是传入函数的指针并不是原来的指针（这很正常，因为golang并没有引用传值，每一个变量的地址都是不一样的）。 所以，单纯修改指针中存放的内容是没有任何用处的。如果假设指针是杯子，里面存放的内容是某种液体，现在main函数中的u杯子里面装的是水，那么defaultIP杯子中装的就是酱油。如果想要让main的u杯中也装入酱油，唯一的方法就是把酱油倒进u杯中，因为go不支持对两个杯子的替换。 ","date":"2021-07-15","objectID":"/posts/20210715_%E5%85%B3%E4%BA%8Egolang%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/:1:0","tags":["Go","问题延申"],"title":"关于golang中指针赋值的问题","uri":"/posts/20210715_%E5%85%B3%E4%BA%8Egolang%E4%B8%AD%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98/"},{"categories":["事件记录"],"content":"今天遇到了一个问题，我需要设置一个循环中的变量用于下一次循环之中。因为修改的时候一些问题（处理err），所以不小心将之前的=改为了:=。大致如下 func getEle() (int,error){ return rand.Intn(100),nil } func exchangeGradually(fp int){ var fingerprint int = fp for i:=0;i\u003c5;i++{ oldfingerprint := fingerprint fingerprint,err := getEle() if err != nil{ panic(err) } fmt.Println(fingerprint,oldfingerprint) } } func main() { exchangeGradually(10) } 可以试着执行一下，原本预期中oldfingerprint是随着fingerprint改变而改变的，但是实际上是不变的。原因是很简单的，因为:=重新分配了一个变量覆盖掉了原有的变量。 但是我原本以为是不会覆盖的，因为之前写错误处理的时候往往也是直接val,err := ...这样写下来。现在看来，:=应该是会重新声明左侧的所有变量并覆盖作用域。 从这里可以引出shadow error的问题，类似于shadow variable。shadow error是指很多时候需要在defer中处理error，但是被后面的错误给覆盖了，类似于 func getErr1() (int,error){ return 1,fmt.Errorf(\"error 1\") } func getErr2() (int,error){ return 2,fmt.Errorf(\"error 2\") } func exchangeGradually(fp int){ a1,err := getErr1() fmt.Println(a1,err) defer func() { fmt.Println(err) }() a2,err := getErr2() fmt.Println(a2,err) } func main() { exchangeGradually(10) } 在下面这个例子中，原本预期要处理的是error1，但是实际输出的却是error2。因为defer针对的err是函数作用域的，该变量被后续的新声明给覆盖了（当然，实际上原理是不一样的，这个主要是defer中传值与传引用的问题，只要加上捕获列表即可）。 func exchangeGradually(fp int){ a1,err := getErr1() fmt.Println(a1,err) defer func(err error) { fmt.Println(err) }(err) a2,err := getErr2() fmt.Println(a2,err) } ","date":"2021-07-08","objectID":"/posts/20210708_golang%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E8%AF%AF%E7%94%A8%E4%B8%8Eshadow-variable/:0:0","tags":["Go"],"title":"golang中的赋值:=的一次误用与shadow variable","uri":"/posts/20210708_golang%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E7%9A%84%E4%B8%80%E6%AC%A1%E8%AF%AF%E7%94%A8%E4%B8%8Eshadow-variable/"},{"categories":["Go基础学习"],"content":" 其实是一个很简单的问题，但是如果是之前一直写go的话可能没有意识到指针的本质，就走不出来了。 最近写代码的时候遇到了一个问题：有一个功能需要使用一个接口，有多个结构体实现了这个接口（经典OO场景）。这些方法中，有一些方法可以修改结构体中的指定属性，并且有一个对应的方法来返回这个属性。 出于业务需要，值被修改的地方和它被使用的地方是不同的。由于要和原有代码兼容，希望这个代码尽量表现的与原来的一样。 一个小demo，直接返回interface值来完成传递。看着很正常，但是因为是传值，所以与原有代码不太一致，也不够直观。 package main import \"fmt\" type tt interface { setName(string) getName() string } type testA struct{ name string } type testDouble struct{ name string } func (t *testA) setName(n string){ t.name = n } func (t *testA) getName() string{ return t.name } func (t *testDouble) setName(n string){ t.name = n + n } func (t *testDouble) getName() string{ return t.name } func setName(s tt,n string) tt{ t := testA{} t.setName(\"test\") s = \u0026t s.setName(n) return s } func main(){ var s tt s = setName(s,\"tset2\") fmt.Println(s.getName()) /* //origin code need get Name after set var a testA setsetName(\u0026a,\"test\") fmt.Println(a.getName()) */ } 但如果试图使用接口直接作为函数参数的时候，会报错 func setName(s *tt,n string) tt{ //t := testA{} t := testDouble{} t.setName(\"test\") s = \u0026t s.setName(n) return s } func main(){ var s tt s = setName(\u0026s,\"tset2\") fmt.Println(s.getName()) } 在s=\u0026t的地方会报错：Cannot use '\u0026t' (type *testDouble) as type *tt，非指针的情况下会报错Cannot use 't' (type testDouble) as type *tt 这里比较让人迷惑的地方在于，interface tt = testDouble是很容易成立的（编译器支持），可是指针层面却并不像想象中这样继续支持，强制转换也是不行的。这个应该是与golang的底层实现相关了，现在暂时没空拆。 这个问题的实际实现上倒也不难想，直接绕回去即可 //s所对应的内容设置完成之后应该能够返回 func setName(s *tt,n string){ //t := testA{} //s里面的内容应该与t是相同的 t := testDouble{} t.setName(\"test\") //对应的接口变量 var regular tt = \u0026t regular.setName(n) *s = regular//完成转换 fmt.Println(regular.getName()) fmt.Println(s,*s) } func main(){ var s tt setName(\u0026s,\"tset2\") fmt.Println(\u0026s,s) } ","date":"2021-07-01","objectID":"/posts/20210701_golang%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%A3%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E9%80%92/:0:0","tags":["Go","实验报告"],"title":"golang函数参数中接口指针的传递","uri":"/posts/20210701_golang%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%B8%AD%E6%8E%A5%E5%8F%A3%E6%8C%87%E9%92%88%E7%9A%84%E4%BC%A0%E9%80%92/"},{"categories":["无关随笔"],"content":"专利学习 内容： 专利基础知识 标书撰写 来自嘉权专利商标事务所的相关讲座 ","date":"2021-06-26","objectID":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/:0:0","tags":["学习笔记"],"title":"专利讲座笔记","uri":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"},{"categories":["无关随笔"],"content":"专利基本知识 知识产权，包括工业产权、著作权与其他，专利是工业产权下属的概念。专利具体来说是分为三个类型：发明、实用新型、外观设计。 发明也分为产品发明和方法发明，一般毕业所注册的专利都是方法发明这一类，包括制造方法和控制方法或使用方法。发明专利是对产品、方法或者改进所提出的技术方案。 实用新型，又称为产品发明，定义上为对产品的形状、构造以其结合提出的适用于使用的新的技术方案。一般被称为小发明，不包含方法。（算法这类虚拟的方法类内容是不包含在实用新型中的） 外观设计，又称为产品设计。对产品的形状、图案、色彩或者其结合所作出的富有美感并适于工作上应用的新设计。 毕业要求的1分为公开发明专利，成果必须署名中山的数学，且必须为国家发明专利的第一发明人。 不能获得专利的情况： 科学发现，比如发现一种自然现象 智力活动的规则和方法，比如一种游戏规则（三国杀）。具体来说是可以人为地随意篡改也不影响技术方面的体现。 疾病的诊断和治疗方法。出于人道主义的考虑和社会伦理的原因。 动物和植物新品种（产品的生产方法除外） 用原子核变换方法获得的物质 专利的性质： 独占性 专利权人具有对其发明创造的制造、使用、销售、许诺销售和进出口的权利，也是最重要的性质。 时间性 从申请日到授权日大概要2-3年，审查周期很长。 地域性 只能在某个国家单独申请 专利权授予条件： 新颖性 指申请日以前没有同样的发明创造 在国内外的出版物上公开发表过。这一点比较经常遇到，在期刊发表后是不能申请专利的 在国内外公开使用过或者以其他方式为公众所知。 创造性 比新颖性要高。 要求具有突出的实质性特点和显著的进步（实用新型只需要具有实质性特点和进步即可） 涉及计算机程序的专利： 通常是以发明专利申请的形式提出 涉及计算机程序的发明是指：为解决发明提出的问题，全部或部分以计算机程序处理流程为基础（算法流程图），通过计算机执行按上述流程编制的计算机程序，对计算机外部对象或者内部对象进行控制或处理的解决方案。 并不一定要包含对计算机硬件的改变。 五类可以申请专利的计算机软件： 将计算机程序输入到一个公知的计算机来控制该计算机的内部操作，从而实现计算机内部性能的改进 用计算机程序来控制某一工业过程 用计算机程序来控制某一测量或者测试过程 使用一个计算机程序来实现外部数据处理 ","date":"2021-06-26","objectID":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/:1:0","tags":["学习笔记"],"title":"专利讲座笔记","uri":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"},{"categories":["无关随笔"],"content":"文件 主要是说明书（范围限定）和说明书附图 专利挖掘途径： 找出完成任务的组成部分：比如网站的前端、后台、服务器 分析各组成部分的技术要素：比如前端界面的多个功能模块 找出各技术要素的创新点：比如具体的权限功能模块 根据创新点总结技术方案：比如实现该模块的算法 ","date":"2021-06-26","objectID":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/:2:0","tags":["学习笔记"],"title":"专利讲座笔记","uri":"/posts/20210626_%E4%B8%93%E5%88%A9%E8%AE%B2%E5%BA%A7%E7%AC%94%E8%AE%B0/"},{"categories":["Go基础学习"],"content":" 对KM社区上译文的阅读 原文来自于Francesc Campoy在GopherCon 2016上的演讲Understanding nil：视频https://www.youtube.com/watch?v=ynoY2xz-F8s，Slides：https://speakerdeck.com/campoy/understanding-nil ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:0:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"nil是什么 就结果来说，nil是绝大部分Go中类型的初始值，包括指针、slices、maps、channels、functions等。而这其中，应该大部分类型最核心的实现都是指针，比如map和slice的本质就是指向内置对象的指针。 而对于接口而言就更加复杂一些，这个其实涉及到了接口的底层实现，详情参考Go语言接口的原理-Go语言设计与实现。 接口包括了一个指向值的指针和一个指向类型的指针。对接口来说，接口为nil代表着(nil,nil)，因此如果声明了一个自珍并且把指针赋值给了接口，那类型就不为nil了（*Person,nil） type Person struct{ a int } func (p Person) String() string{ return strconv.Itoa(p.a) } func main(){ var s fmt.Stringer//接口类型，要求实现String()函数 fmt.Println(s == nil)//true var p *Person s = p fmt.Println(s == nil)//false，尽管值依旧为nil，但是类型不为nil } ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:1:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"什么时候nil不是nil nil可以是一个nil接口/切片或者指针，是有实际意义的 type doError struct{ errorMessage string } func (err doError) Error() string{ return err.errorMessage } func do() error{ //错误地方：返回了error接口类型。改正：应该返回具体类型 * doError var err *doError return err //类型*doError是空的，但是它实现了接口 } func main(){ err := do() fmt.Println(err == nil)//false } 但如果使用了一个wrap方法，一样会出现问题。本质上是没有变化的。因此，最好不要返回具体的自定义错误类型（do not declare concrete error vars）。 func do() *doError{ return nil } func wrapDo() error{ return do() //返回空的*doError类型 } func main(){ err := wrapDo() //error(*doError,nil) fmt.Println(err == nil) // false } 正确的方式是： 不应该返回具体的错误类型，无论如何都应该返回接口error 在过程中不要自行声明具体类型变量，无论如何都应该使用接口error变量 这种感觉，就是具体类型只出现在自己的实现中而不出现在其他的任何地方。实际的错误使用 func doRequest() error { return \u0026RequestError{ StatusCode: 503, Err: errors.New(\"unavailable\"), } } 这样的东西来返回，这样即使是nil也与具体类型无关。这个是我个人的理解。 ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:2:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"nil的用法 在Go中，nil也是可以调用该类型的方法：（这个确实是有点出乎我的意料了，这个函数更接近于静态函数的实现而不是成员函数。这也说明了Go中的很多概念和OO中的概念不能很简单的一一对应） type person struct{} func sayHi(p *person) { fmt.Println(\"hi\") } func (p *person) sayHi() { fmt.Println(\"hi\") } var p *person func main(){ p.sayHi() // hi } 所以二叉树遍历可以有两个版本： //精细版本 func (t *tree) Sum() int{ sum := t.v if t.l != nil{ sum += t.l.Sum() } if t.r != nil{ sum += t.r.Sum() } return sum } //简单版本 func (t *tree) Sum() int { if t == nil { return 0 } return t.v + t.l.Sum() + t.r.Sum() } 后者同样是可行的。这虽然使得整体结构更加简洁了，但是我并不是很喜欢这种实现。 ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:3:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"nil管道 作者给了一个问题，一个很简单的应用，要求将两个channel的内容合并到一个channel中并输出。这两个channel将在发送一定数量后分别进行关闭 一个很简单的想法是这样的： func merge(out chan\u003c- int, a,b \u003c- chan int){ for{ select{ case v := \u003c-a: out\u003c-v case v:= \u003c-b: out\u003c-v } } } func main(){ a := make(chan int,0) b := make(chan int,0) out := make(chan int,0) counter := 0 go func() { for{ t1 := time.After(time.Second) \u003c- t1 //fmt.Println(\"record a\",time.Now()) a \u003c- 1 counter ++ if counter \u003e 5{ close(a) } } }() go func() { for{ t2 := time.After(2 * time.Second) \u003c- t2 //fmt.Println(\"record b\",time.Now()) b \u003c- 2 if counter \u003e 4{ close(b) } } }() go func(){ for{ select { case v := \u003c-out : fmt.Println(v,\" \",time.Now()) } } }() merge(out,a,b) } 缺陷：看上去是没有问题的，但是实际上在通道关闭后会输出大量的0（因为被关闭的通道的特性，会给v赋值为0）。这是因为管道关闭后读取部分没有进行验证，依旧在获取数据，导致获得了大量无效的值。 显然，可以通过从管道接收值的时候第二个值是否为true来判断管道有没有关上，但是这也并不管用 func merge(out chan\u003c- int, a,b \u003c- chan int){ aClosed := false bClosed := false for !aClosed || !bClosed{ select{ case v,ok := \u003c-a: if !ok{ aClosed = true; fmt.Println(\"a is now closed\") continue } out\u003c-v case v,ok := \u003c-b: if !ok{ bClosed = true; fmt.Println(\"b is now closed\") continue } out\u003c-v } } } func main(){ a := make(chan int,0) b := make(chan int,0) out := make(chan int,0) t := 0 counter := 0 go func() { for{ t1 := time.After(time.Second) \u003c- t1 //fmt.Println(\"record a\",time.Now()) a \u003c- 1 counter ++ if counter \u003e 5{ close(a) } } }() go func() { for{ t2 := time.After(2 * time.Second) \u003c- t2 //fmt.Println(\"record b\",time.Now()) b \u003c- 2 if counter \u003e 10{ close(b) } } }() go func(){ for{ select { case v := \u003c-out : t = v //fmt.Println(v,\" \",time.Now()) } } }() merge(out,a,b) } （这里需要稍微增大关闭的间隔，不然真的会同步关闭） 问题：结果显示，“a is now closed\"被大量输出，说明已经被关闭的管道a被反复读取且没有办法阻塞，正常情况下这可能会导致程序崩溃。 PS：最后程序报错panic: send on closed channel显示向a中发送了数据，并结束（这个是go协程中忘记写退出了）。 该问题的根源在于，已经关闭的管道仍然是可以读取的（只是不能写入，向一个已经关闭的管道中写入数据会引起panic）。此时如果有两个管道的话，单独关闭一个就会造成另外一个管道无法阻塞并被大量调用。 最好的方法是设置关闭的管道为nil package main import ( \"fmt\" \"time\" ) func merge(out chan\u003c- int, a,b \u003c- chan int){ for a!=nil || b!=nil{ select{ case v,ok := \u003c-a: if !ok{ a = nil fmt.Println(\"a is now closed\") continue } out\u003c-v case v,ok := \u003c-b: if !ok{ b = nil fmt.Println(\"b is now closed\") continue } out\u003c-v } } } func main(){ a := make(chan int,0) b := make(chan int,0) out := make(chan int,0) t := 0 counter := 0 go func() { for{ t1 := time.After(time.Second) \u003c- t1 fmt.Println(\"record a\",time.Now()) a \u003c- 1 counter ++ if counter \u003e 2{ close(a) return } } }() go func() { for{ t2 := time.After(2 * time.Second) \u003c- t2 fmt.Println(\"record b\",time.Now()) b \u003c- 2 counter ++ if counter \u003e 3{ close(b) return } } }() go func(){ for{ select { case v := \u003c-out : t = v //fmt.Println(v,\" \",time.Now()) } } }() merge(out,a,b) } ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:4:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"nil function 对于函数来说，可以选择给它赋值为nil来表示默认值 比如 func doSum(s Summer) int{ if s == nil{ return 0 } return s.Sum() } //Summer是接口，t是具体的实现类型，但上述方法都是可以的。即使是传入具体类型(*tree,nil)也不会报错，因为值为nil的具体类型的方法依旧可以被调用 在HTTP中，http.HandleFunc('localhost:8080',nil)就是这样的实现。 ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:5:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"nil map nil的map是不能够赋值的，因此对于需要写入的map无论何时都应该判断是否为nil，不然会直接panic退出： func main(){\rvar s map[string]bool\rfmt.Println(s==nil) //true\rs[\"true\"] = true //panic: assignment to entry in nil map\rfmt.Println(len(s))\r}\rnil的map的读取会直接任意成功。像下面的代码，并不会如预期一样输出fail，而是会输出`pass through`+v的值false。\rfunc main(){\rvar s map[string]bool\rif v,ok := s[\"test\"]; ok{\rfmt.Println(\"fail\")\r}else{\rfmt.Println(\"pass through\")\rfmt.Println(v)\r}\r}\r因此，对于接受map为参数的函数，应该要谨慎传入nil。并且在写类似函数的时候一定要做好对应的检查。 ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:6:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"总结 比较值得注意的主要是nil的接口、管道和map。 其中对于接口，比较值得注意的是具体类型所导致的接口nil的判断。 对于管道来说，比较需要注意的是对已经关闭的管道和nil的管道写入和读取等操作时与正常管道的差异。 对于map和其他类型来说，需要注意的是报错，比如nil切片的越界错误和nil映射表的读取错误哦。 ","date":"2021-06-21","objectID":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/:7:0","tags":["Go","学习笔记","实验报告"],"title":"Go中nil意义的理解","uri":"/posts/20210621_go%E4%B8%ADnil%E6%84%8F%E4%B9%89%E7%9A%84%E7%90%86%E8%A7%A3/"},{"categories":["Go基础学习"],"content":"今天在看书的时候发现了这么一句话var _ HelloServiceInterface = (*HelloServiceClient)(nil)，其中HelloServiceClient是一个结构体，另外一个自然是一个interface。代码的作者称这行代码要求后面的结构体必须实现前面的接口，不然会出现编译错误。 说实话，我第一眼真的没反应过来。直到我看到了这个问题 这一行实际上是变量赋值的变体var VariableName variableType = variableValue，其中的值是(*HelloServiceClient)类型，实际值为nil。 另外有类似的语句 //T is a struct var _ I = T{} // Verify that T implements I. var _ I = (*T)(nil) // Verify that *T implements I. 这个问题的本质其实是接口的定义：结构体只要实现了接口的定义，它就能被赋予该接口的变量。 对于指针来说就要更复杂一些，详见#180 。概要来说，就是对用指针实现的接口，该指针类型的普通结构体不能使用，具体原因也比较复杂（详见Go程序设计与实现-接口相关章节） ","date":"2021-06-17","objectID":"/posts/20210617_golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AD%89/:0:0","tags":["Go","问题解答"],"title":"golang接口与实现以及var _ I = (*T)(nil)的意义","uri":"/posts/20210617_golang%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AD%89/"},{"categories":["无关随笔"],"content":"每次都忘记这个效应叫什么名字，所以还是专门开个issue记录一下。 邓宁-克鲁格效应，按照百科的说法，是一种认知偏差，能力欠缺的人有一种虚幻的自我优越感，错误地认为自己比实际情况更加优秀 对于一般人来说也是会有类似的情况，只是可能峰值没有那么高。在知识和技能水平不断提高的过程中，势必会因为没有看到自身的缺点而导致自信程度增长速度远超想象。 其实这张图应该是没有画完的，愚昧之山不一定只有一座，开悟之坡爬得也不一定真的就是真理之山，我们所期望到达的终点也不过是一个新的起点。不过这个就是另外一个问题了。 ","date":"2021-06-17","objectID":"/posts/20210617_%E9%82%93%E5%AE%81-%E5%85%8B%E9%B2%81%E6%A0%BC%E6%95%88%E5%BA%94/:0:0","tags":["心理学"],"title":"邓宁-克鲁格效应","uri":"/posts/20210617_%E9%82%93%E5%AE%81-%E5%85%8B%E9%B2%81%E6%A0%BC%E6%95%88%E5%BA%94/"},{"categories":["Go基础学习"],"content":"参考资料 Golang and default values 这个问题相当麻烦，根据golang-nuts/google groups中的这篇文章，golang现在与将来都不会支持参数默认值。Go始终在使得自己变得尽可能的简单，而增加这种额外的支持会使parser变得更复杂。 设置参数值的好处： 可以缺省部分参数。 可以提供一种默认的，行之有效的配置。 但是参考资料中提到了几种实现默认值的方法： ","date":"2021-06-13","objectID":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/:1:0","tags":["Go","问题解答"],"title":"golang中函数如何设置参数默认值","uri":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"categories":["Go基础学习"],"content":"强制改变 // Both parameters are optional, use empty string for default value func Concat1(a string, b int) string { if a == \"\" { a = \"default-a\" } if b == 0 { b = 5 } return fmt.Sprintf(\"%s%d\", a, b) } go的一大特点就是所有的变量都必须经过初始化。那如果在函数内部读取到参数值为初始化值，即可进行对应的操作。 但是这种方法无法解决设置参数默认值时所经常应对的场景，即参数缺省问题。 ","date":"2021-06-13","objectID":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/:1:1","tags":["Go","问题解答"],"title":"golang中函数如何设置参数默认值","uri":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"categories":["Go基础学习"],"content":"使用可变参数语法糖 // a is required, b is optional. // Only the first value in b_optional will be used. func Concat2(a string, b_optional ...int) string { b := 5 if len(b_optional) \u003e 0 { b = b_optional[0] } return fmt.Sprintf(\"%s%d\", a, b) } 上述方法中，a是必须的，而b是可选的。 此时b的默认值时5，如果b_optional中存在数据，则将其读取。 ","date":"2021-06-13","objectID":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/:1:2","tags":["Go","问题解答"],"title":"golang中函数如何设置参数默认值","uri":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"categories":["Go基础学习"],"content":"利用结构体的config // A declarative default value syntax\r// Empty values will be replaced with defaults\rtype Parameters struct {\rA string `default:\"default-a\"` // this only works with strings\rB string // default is 5\r}\rfunc Concat3(prm Parameters) string {\rtyp := reflect.TypeOf(prm)\rif prm.A == \"\" {\rf, _ := typ.FieldByName(\"A\")\rprm.A = f.Tag.Get(\"default\")\r}\rif prm.B == 0 {\rprm.B = 5\r}\rreturn fmt.Sprintf(\"%s%d\", prm.A, prm.B)\r} 虽然也能做到缺省参数（如果不设置A属性，则该属性将被默认初始化），但是这种方式只对字符串管用。 ","date":"2021-06-13","objectID":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/:1:3","tags":["Go","问题解答"],"title":"golang中函数如何设置参数默认值","uri":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"categories":["Go基础学习"],"content":"转换函数的全部参数 func Concat4(args ...interface{}) string { a := \"default-a\" b := 5 for _, arg := range args { switch t := arg.(type) { case string: a = t case int: b = t default: panic(\"Unknown argument\") } } return fmt.Sprintf(\"%s%d\", a, b) } 相当泛用的方法，但是对于不同的类型就不可行了。 ","date":"2021-06-13","objectID":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/:1:4","tags":["Go","问题解答"],"title":"golang中函数如何设置参数默认值","uri":"/posts/20210613_golang%E4%B8%AD%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC/"},{"categories":["Git学习"],"content":" 本文目标 了解不同的分支开发模式并给出自己的理解 为熟练掌握并选择不同的分支开发模式做准备 ","date":"2021-06-12","objectID":"/posts/20210612_git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/:0:0","tags":["git","软件工程","学习笔记"],"title":"Git分支开发模式学习","uri":"/posts/20210612_git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["Git学习"],"content":"参考资料 segmentationfault official-分支开发工作流 按照官方的分类就比较简单： 长期分支：分支将长期存在，不同分支之间的区别将是稳定性的区别。其中master最稳定，dev比较不稳定，topic次之。 短期分支：除了master外不存在长期分支，所有分支都将短期存在，目标为实现一种主题（单一的特性或工作）。实现完成之后就合并到master中 阿里的分支模式分类就更接近生产，除了强调开发外也强调发布。 TBD（主干开发模式），有点类似长期分支，但是比长期分支简单很多。最简单的版本就是所有团队成员共有一个开发分支，这样的问题在于如果团队变大的话，每天各个成员光是在合并提交上就会花费很多时间。因此要求每次变更提交都要足够小，且能快速完成验证。 特性分支开发模式(Git-Flow)：这个是真的有点类似Git官方中长期分支与短期分支的结合。就每一个特性来说，所有关于该特性的开发工作都会集中在一个分支上，当完成该特性的工作之后，再把特性分支合并回代码主路径上并准备发布 长期存在着多个分支，比如feature分支（功能开发）、develop（功能集成）、release（版本发布）、hotfix（线上修改）、master（最新已发布版本基线） 每个特性都在对应的feature分支上开发。特性开发完毕并验证通过后会merge到develop分支（大部分时间都与master接近）进行集中验证。然后验证完毕之后单独拉到release分支进行发布。中间的任何错误都会从release分支往回传，其中master分支永远是最新的可运行分支。 缺点：分支特别多，而且非常复杂。develop分支等的意义比较冗余（与master等相比） Github-Flow，任务导向型，更贴近短期分支。实际上也是大部分开源项目所采用的方法。 master分支的所有代码都应该是最新的可部署、可工作版本 新的工作从master拉取分支，并以工作任务进行命名 完成任务后提交pull-request合并到master分支并提起代码评审，评审通过后进行合并。 Gitlab-Flow，将pull-request改为了merge-request，与Github-Flow非常相似 最大的区别是发布侧，引入了对应生产环境的production分支和预发环境的pre-production分支。 ","date":"2021-06-12","objectID":"/posts/20210612_git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/:1:0","tags":["git","软件工程","学习笔记"],"title":"Git分支开发模式学习","uri":"/posts/20210612_git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"},{"categories":["Go基础学习"],"content":" 本文目的 复习并整理go test相关知识 要求：能让我在短时间内通过阅读该文掌握写一份go单元测试所需要的知识 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/:0:0","tags":["软件测试","Go","待完善"],"title":"golang单元测试整理归纳","uri":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"},{"categories":["Go基础学习"],"content":"参考资料 Go by example，中文版，例子确实是最快的学习方式。 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/:1:0","tags":["软件测试","Go","待完善"],"title":"golang单元测试整理归纳","uri":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"},{"categories":["Go基础学习"],"content":"基础知识 一般测试文件应该与被测试文件放在同一个目录下，比如被测试代码为intutils.go时，被测试代码应该写为intutils_test.go。 通常会编写一个名称以Test开头的函数来创建测试（这个我记得是必须的，不然识别不出来）。例如GoLand自动生成的测试文件(Alt+Insert，之前写Java的时候经常用这个来生成DAO) func TestTest(t *testing.T) { type args struct { a int } tests := []struct { name string args args want int }{ // TODO: Add test cases. //{name,args{},want},... } for _, tt := range tests { t.Run(tt.name, func(t *testing.T) { if got := Test(tt.args.a); got != tt.want { t.Errorf(\"Test() = %v, want %v\", got, tt.want) } }) } } 一些常用函数： t.Error*会报告测试失败的信息，然后继续进行测试（wildcard，通配符，不是指针） t.Fail*会报告测试失败的信息，然后立即终止测试 t.Run可以运行一个subtests子测试。一个子测试对应着tests数组中的一行数据，在go test -v中会分开显示。 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/:2:0","tags":["软件测试","Go","待完善"],"title":"golang单元测试整理归纳","uri":"/posts/20210612_golang%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%95%B4%E7%90%86%E5%BD%92%E7%BA%B3/"},{"categories":["Go基础学习"],"content":"遇到问题 这个问题的来源是今天在复习接口的时候遇到了一份代码 package main import \"fmt\" type RPCError struct { Code int64 Message string } func (e *RPCError) Error() string { return fmt.Sprintf(\"%s, code=%d\", e.Message, e.Code) } func main() { fmt.Println(\"In main function\") var rpcErr error = NewRPCError(400, \"unknown err\") // typecheck1 err := AsErr(rpcErr) // typecheck2 println(err) } func NewRPCError(code int64, msg string) error { return RPCError{ // typecheck3， must be \u0026RPCError Code: code, Message: msg, } } func AsErr(err error) error { return err } 这份代码有一个compile-time error，在func NewRPCError的返回值处会报错误 ./main.go:22:17: cannot use RPCError{...} (type RPCError) as type error in return argument:\rRPCError does not implement error (Error method has pointer receiver) 解决方案是将返回的RPCError改为\u0026RPCError，即传回指针而不是实值。 但是这显然是与常识相违背的，因为error类型本身也并不是什么指针之类的东西，那这个指针是定义在哪里的？ ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/:1:0","tags":["Go","问题解答"],"title":"golang基础问题：X does not implement Y (... method has a point receiver)","uri":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/"},{"categories":["Go基础学习"],"content":"找到共性 在SO上找到了一个对应的问题，回答中构造了一个类似的情况 package main import \"fmt\" type Stringer interface { String() string } type MyType struct { value string } func (m *MyType) String() string { return m.value } func main(){ m := MyType{value:\"something\"} var s Stringer s = m // s=\u0026m fmt.Println(s) } 大意就是，为了实现接口Stringer，结构体必须有一个方法String。而在实际的实现中，String是被绑在方法*MyType上而不是MyType，所以接口对应的类型也只能是*MyType，因此必须传递一个指针。 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/:2:0","tags":["Go","问题解答"],"title":"golang基础问题：X does not implement Y (... method has a point receiver)","uri":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/"},{"categories":["Go基础学习"],"content":"回溯 而在原问题中，对Error方法的实现为 func (e *RPCError) Error() string { return fmt.Sprintf(\"%s, code=%d\", e.Message, e.Code) } 所以如果将这个地方进行修改的话一样是可行的。 问题解决。 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/:3:0","tags":["Go","问题解答"],"title":"golang基础问题：X does not implement Y (... method has a point receiver)","uri":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/"},{"categories":["Go基础学习"],"content":"根源 该问题的根源在于，结构体与结构体的指针本质上是两种不同的类型。就像不能向一个接受指针的函数传递结构体一样，反过来也是不行的。只是这两种类型可以比较方便地进行快速转换，所以可能导致一些理解上的偏差 比如下面两种实现接口的方法，其实都是可以的，而且是两种不同的实现方法。（当然，下面这样写肯定是不行的，指针类型和非指针类型对接口的实现不能同时出现） type Duck interface{\rWalk()\rQuack()\r}\rtype Cat struct{}\rfunc (c *Cat) Walk(){\rfmt.Println(\"Star Cat Walk\")\r}\rfunc (c *Cat) Quack(){\rfmt.Println(\"Star Cat meow\")\r}\rfunc (c Cat) Walk(){\rfmt.Println(\"Cat Walk\")\r}\rfunc (c Cat) Quack(){\rfmt.Println(\"Cat meow\")\r} 详情可以看面向信仰编程-4.2接口 ","date":"2021-06-12","objectID":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/:4:0","tags":["Go","问题解答"],"title":"golang基础问题：X does not implement Y (... method has a point receiver)","uri":"/posts/20210612_golang%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98_x-does-not-implement-y-...-method-has-a-point-receiver/"},{"categories":["操作实践"],"content":"参考资料： kubernetes ingress实战 Intro to Kube ingress: Set up nginx Ingress in Kubernetes Bare Metal ingress的nip.io相关资料 实验室集群中已经有一个ingress-controller，ingress.class为nginx。 本次实验的目标是将服务通过ingress暴露到外部服务，最好能够直接通过外网IP访问。 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:0:0","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"实验所需镜像 原本用的是google的镜像，但是因为在国内，弄起来太麻烦了。所以还是从dockerhub上选了一个类似的镜像。 apiVersion: v1\rkind: Namespace\rmetadata:\rname: echoserver\r---\rapiVersion: apps/v1\rkind: Deployment\rmetadata:\rname: echoserver\rnamespace: echoserver\rspec:\rreplicas: 2\rselector:\rmatchLabels:\rapp: echoserver\rtemplate:\rmetadata:\rlabels:\rapp: echoserver\rspec:\rcontainers:\r- image: ealen/echo-server:latest\rimagePullPolicy: IfNotPresent\rname: echoserver\rports:\r- containerPort: 80\renv:\r- name: PORT\rvalue: \"80\"\r---\rapiVersion: v1\rkind: Service\rmetadata:\rname: echoserver\rnamespace: echoserver\rspec:\rports:\r- port: 80\rtargetPort: 80\rprotocol: TCP\rtype: ClusterIP\rselector:\rapp: echoserver\r---\rapiVersion: networking.k8s.io/v1\rkind: Ingress\rmetadata:\rname: echoserver\rnamespace: echoserver\rannotations:\rkubernetes.io/ingress.class: nginx\rspec:\rrules:\r- http:\rpaths:\r- path: /echoserver\rpathType: Prefix\rbackend:\rservice:\rname: echoserver\rport:\rnumber: 80 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:1:0","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"进行测试 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:2:0","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"集群内功能测试 通过执行kubectl get svc -n=echoserver可以拿到对应服务的ClusterIP 再执行kubectl run -i --rm --restart=Never dummy --image=dockerqa/curl:ubuntu-trusty -n=echoserver --command -- curl 10.108.58.132:80 即可在集群内部访问到目标服务。结果可以经过jq整理，为 { \"host\": { \"hostname\": \"10.108.58.132\", \"ip\": \"::ffff:10.244.3.188\", \"ips\": [] }, \"http\": { \"method\": \"GET\", \"baseUrl\": \"\", \"originalUrl\": \"/\", \"protocol\": \"http\" }, \"request\": { \"params\": { \"0\": \"/\" }, \"query\": {}, \"cookies\": {}, \"body\": {}, \"headers\": { \"user-agent\": \"curl/7.35.0\", \"host\": \"10.108.58.132\", \"accept\": \"*/*\" } }, \"environment\": { \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"HOSTNAME\": \"echoserver-6944fb9c86-mn6vz\", \"PORT\": \"80\", \"KUBERNETES_PORT_443_TCP\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP_ADDR\": \"10.96.0.1\", \"ECHOSERVER_PORT_80_TCP\": \"tcp://10.108.58.132:80\", \"KUBERNETES_SERVICE_PORT_HTTPS\": \"443\", \"KUBERNETES_PORT\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP_PROTO\": \"tcp\", \"KUBERNETES_PORT_443_TCP_PORT\": \"443\", \"ECHOSERVER_SERVICE_HOST\": \"10.108.58.132\", \"ECHOSERVER_PORT\": \"tcp://10.108.58.132:80\", \"KUBERNETES_SERVICE_HOST\": \"10.96.0.1\", \"KUBERNETES_SERVICE_PORT\": \"443\", \"ECHOSERVER_SERVICE_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP_PROTO\": \"tcp\", \"ECHOSERVER_PORT_80_TCP_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP_ADDR\": \"10.108.58.132\", \"NODE_VERSION\": \"12.19.0\", \"YARN_VERSION\": \"1.22.5\", \"HOME\": \"/root\" } } ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:2:1","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"集群外功能测试 通过kubectl get ingress -n=echoserver可以确定目标ingress的内网IP地址。 再使用curl 192.168.1.10/echoserver，ingress-controller在工作正常的情况下即可完成对应的转发 { \"host\": { \"hostname\": \"192.168.1.10\", \"ip\": \"::ffff:10.244.1.201\", \"ips\": [] }, \"http\": { \"method\": \"GET\", \"baseUrl\": \"\", \"originalUrl\": \"/echoserver\", \"protocol\": \"http\" }, \"request\": { \"params\": { \"0\": \"/echoserver\" }, \"query\": {}, \"cookies\": {}, \"body\": {}, \"headers\": { \"host\": \"192.168.1.10\", \"x-request-id\": \"1e1d9bcdb01d497e7cb1745a1ac6ff0e\", \"x-real-ip\": \"10.244.0.0\", \"x-forwarded-for\": \"10.244.0.0\", \"x-forwarded-host\": \"192.168.1.10\", \"x-forwarded-port\": \"80\", \"x-forwarded-proto\": \"http\", \"x-scheme\": \"http\", \"user-agent\": \"curl/7.63.0\", \"accept\": \"*/*\" } }, \"environment\": { \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"HOSTNAME\": \"echoserver-6944fb9c86-mn6vz\", \"PORT\": \"80\", \"KUBERNETES_PORT_443_TCP\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP_ADDR\": \"10.96.0.1\", \"ECHOSERVER_PORT_80_TCP\": \"tcp://10.108.58.132:80\", \"KUBERNETES_SERVICE_PORT_HTTPS\": \"443\", \"KUBERNETES_PORT\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP_PROTO\": \"tcp\", \"KUBERNETES_PORT_443_TCP_PORT\": \"443\", \"ECHOSERVER_SERVICE_HOST\": \"10.108.58.132\", \"ECHOSERVER_PORT\": \"tcp://10.108.58.132:80\", \"KUBERNETES_SERVICE_HOST\": \"10.96.0.1\", \"KUBERNETES_SERVICE_PORT\": \"443\", \"ECHOSERVER_SERVICE_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP_PROTO\": \"tcp\", \"ECHOSERVER_PORT_80_TCP_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP_ADDR\": \"10.108.58.132\", \"NODE_VERSION\": \"12.19.0\", \"YARN_VERSION\": \"1.22.5\", \"HOME\": \"/root\" } } 如果将ingress改为 ---apiVersion:networking.k8s.io/v1kind:Ingressmetadata:name:echoservernamespace:echoserverannotations:kubernetes.io/ingress.class:nginxspec:rules:- host:http-svc.frognew.comhttp:paths:- path:/echoserverpathType:Prefixbackend:service:name:echoserverport:number:80则可以使用如下命令进行测试 curl 192.168.1.10/echoserver -H \"Host: http-svc.frognew.com\" 但是在集群内部使用curl http-svc.frognew.com/echoserver则无法解析，会报404错误。就是说nginx并不会对其进行解析。我的一个猜想是这个设置应该要在IngressController中进行，而不能只在ingress中设置，不过暂时还未成功。 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:2:2","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"快速总结 从上述两个实验可以很快速的认识到yaml配置文件中的项目内容。 ingress中配置的实际上是转发的URL，其本质和服务器的router是类似的。对于给定的IP请求，一旦满足指定的router，nginx controller就会将对应的请求发送到指定的服务上，服务通过port收到内容，再通过targetPort将请求投送到pod的指定端口中，完成转发。 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:2:3","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["操作实践"],"content":"host与nip.io 如果需要使用host解析的话，正常情况下需要ELB的设置。但是使用nip.io也可以达到类似的效果 apiVersion:networking.k8s.io/v1kind:Ingressmetadata:name:echoservernamespace:echoserverannotations:kubernetes.io/ingress.class:nginxspec:rules:- host:echoserver.192.168.1.10.nip.iohttp:paths:- path:/pathType:Prefixbackend:service:name:echoserverport:number:80通过上述的修改后，可以直接在集群外部使用curl echoserver.192.168.1.10.nip.io访问到服务，得到的结果如下（经过jq整理） { \"host\": { \"hostname\": \"echoserver.192.168.1.10.nip.io\", \"ip\": \"::ffff:10.244.1.201\", \"ips\": [] }, \"http\": { \"method\": \"GET\", \"baseUrl\": \"\", \"originalUrl\": \"/\", \"protocol\": \"http\" }, \"request\": { \"params\": { \"0\": \"/\" }, \"query\": {}, \"cookies\": {}, \"body\": {}, \"headers\": { \"host\": \"echoserver.192.168.1.10.nip.io\", \"x-request-id\": \"7b8b5cd857f5771388cd349d395fe979\", \"x-real-ip\": \"10.244.0.0\", \"x-forwarded-for\": \"10.244.0.0\", \"x-forwarded-host\": \"echoserver.192.168.1.10.nip.io\", \"x-forwarded-port\": \"80\", \"x-forwarded-proto\": \"http\", \"x-scheme\": \"http\", \"user-agent\": \"curl/7.63.0\", \"accept\": \"*/*\" } }, \"environment\": { \"PATH\": \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"HOSTNAME\": \"echoserver-6944fb9c86-btmf8\", \"PORT\": \"80\", \"KUBERNETES_SERVICE_PORT_HTTPS\": \"443\", \"KUBERNETES_PORT_443_TCP_PROTO\": \"tcp\", \"ECHOSERVER_SERVICE_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP\": \"tcp://10.108.58.132:80\", \"ECHOSERVER_PORT_80_TCP_PORT\": \"80\", \"ECHOSERVER_PORT_80_TCP_PROTO\": \"tcp\", \"KUBERNETES_SERVICE_HOST\": \"10.96.0.1\", \"KUBERNETES_PORT_443_TCP_PORT\": \"443\", \"ECHOSERVER_PORT\": \"tcp://10.108.58.132:80\", \"KUBERNETES_PORT\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP\": \"tcp://10.96.0.1:443\", \"KUBERNETES_PORT_443_TCP_ADDR\": \"10.96.0.1\", \"ECHOSERVER_SERVICE_HOST\": \"10.108.58.132\", \"ECHOSERVER_PORT_80_TCP_ADDR\": \"10.108.58.132\", \"KUBERNETES_SERVICE_PORT\": \"443\", \"NODE_VERSION\": \"12.19.0\", \"YARN_VERSION\": \"1.22.5\", \"HOME\": \"/root\" } } ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/:3:0","tags":["kubernetes","实验报告"],"title":"kubernetes服务：学习ingress与暴露服务简单实验","uri":"/posts/20210606_kubernetes%E6%9C%8D%E5%8A%A1_%E5%AD%A6%E4%B9%A0ingress%E4%B8%8E%E6%9A%B4%E9%9C%B2%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E5%AE%9E%E9%AA%8C/"},{"categories":["codebase"],"content":"最近因为实验室集群整体爆炸，需要修改旧服务器的网络配置。为此，需要进行一系列的网络测试。同时，这也是一个新的label系列。总是有一些代码，非常常用，但是用的时候就是找不到，想也想不起来，就非得去查。很难受。 之前做网络测试的手段太原始了（指新建ubuntu容器后登陆进去），不够灵活方便，而且也找不到代码和镜像了。为此，我总结了几个比较好的快速访问方式 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/:0:0","tags":["kubernetes","实验报告"],"title":"kubernetes内部访问服务的方式","uri":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":["codebase"],"content":"方式1 最直接的方式肯定是登陆进服务内部，比如istio中提到的 在执行命令后：kubectl apply -f samples/bookinfo/platform/kube/bookinfo.yaml，如果此时所有的svc和pods都跑起来了，可以通过运行kubectl exec -it $(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}') -c ratings -- curl productpage:9080/productpage | grep -o \"\u003ctitle\u003e.*\u003c/title\u003e\"来检测到结果。 其中的kubectl exec -it可以登陆容器并打开控制台，而服务的名称由$(kubectl get pod -l app=ratings -o jsonpath='{.items[0].metadata.name}')，-c参数保证了在存在注入的情况下能正常运行。 --连接两条不同的命令，后面就不需要过多的解释了。 甚至不一定是同一个镜像，比如使用sleep镜像进行（足够小） export SLEEP_POD=$(kubectl get pod -l app=sleep -o jsonpath={.items..metadata.name})#这里要自行加上-n=test kubectl exec -it $SLEEP_POD -c sleep curl http://ratings.default.svc.cluster.local:9080/ratings/1 {\"id\":1,\"ratings\":{\"Reviewer1\":5,\"Reviewer2\":4}} ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/:1:0","tags":["kubernetes","实验报告"],"title":"kubernetes内部访问服务的方式","uri":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":["codebase"],"content":"方式2 临时开一个curl镜像进行网络检查 官方在httpbin里也展示了如何通过curl镜像来进行内网测试(同样，注意命名空间) kubectl run -i --rm --restart=Never dummy --image=dockerqa/curl:ubuntu-trusty --command -- curl --silent httpbin:8000/html kubectl run -i --rm --restart=Never dummy --image=dockerqa/curl:ubuntu-trusty --command -- curl --silent --head httpbin:8000/status/500 time kubectl run -i --rm --restart=Never dummy --image=dockerqa/curl:ubuntu-trusty --command -- curl --silent httpbin:8000/delay/5 ","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/:2:0","tags":["kubernetes","实验报告"],"title":"kubernetes内部访问服务的方式","uri":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":["codebase"],"content":"网络测试的对象 我一开始想用hello来做，但是其实挺不好的，没什么代表性。 echo-server这个就很不错，像是一个回音壁一样，将所有的请求全部打回。 docker pull ealen/echo-server apiVersion:v1kind:Namespacemetadata:name:echoserver---apiVersion:apps/v1kind:Deploymentmetadata:name:echoservernamespace:echoserverspec:replicas:2selector:matchLabels:app:echoservertemplate:metadata:labels:app:echoserverspec:containers:- image:ealen/echo-server:0.5.1imagePullPolicy:Alwaysname:echoserverports:- containerPort:80---apiVersion:v1kind:Servicemetadata:name:echoservernamespace:echoserverspec:ports:- port:80targetPort:80protocol:TCPselector:app:echoserver---apiVersion:extensions/v1beta1kind:Ingressmetadata:name:echoservernamespace:echoserverannotations:kubernetes.io/ingress.class:\"nginx\"spec:rules:- host:echo.minikube.localhttp:paths:- path:/backend:serviceName:echoserverservicePort:80","date":"2021-06-06","objectID":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/:3:0","tags":["kubernetes","实验报告"],"title":"kubernetes内部访问服务的方式","uri":"/posts/20210606_kubernetes%E5%86%85%E9%83%A8%E8%AE%BF%E9%97%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F/"},{"categories":["Go基础学习"],"content":"关于使用go函数中传值与指针传值等问题","date":"2021-06-04","objectID":"/posts/20210604_go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/","tags":["Go"],"title":"go语言函数传值与指针的相关问题","uri":"/posts/20210604_go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["Go基础学习"],"content":"最近在快速阅读《go语言高级编程》，里面提到Go语言的栈会自动调整大小，所以go程序员是难以关心栈的运行机制。比如说，程序员很难知道局部变量到底是保存在栈中还是保存在堆中 可以使用下面的代码来作为例子： package main import \"fmt\" func f(x int) *int{ return \u0026x } func main(){ s := 5 t := f(s) s += 1 fmt.Println(s,*t) } 上述代码的输出结果是6,5。这个结果说明t所指向的局部变量确实是函数内部的（如果是指向参数的地址，则参数变化时它也应该跟着变化）。也就是说，这个函数的局部变量的地址在函数结束之后仍然存在。 PS：如果想要让该指针指向参数 package main import \"fmt\" func f(x *int) *int{ return x } func main(){ s := 5 t := f(\u0026s) s += 1 fmt.Println(s,*t) } 书中的这一部分提到了两个观点： 不用关心Go语言中栈和堆的问题，编译器和运行时会帮我们搞定 不要假设变量在内存中的位置是固定不变的，指针随时可能会变化。 原因：Go语言使用的连续动态栈，在栈增加的时候会需要将数据移动到新的内存空间，导致栈中的内存地址全部变化。 可能出问题的地方：把Go语言的指针保存到数组中；把Go的地址保存到垃圾回收控制器之外，比如CGO） ","date":"2021-06-04","objectID":"/posts/20210604_go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/:0:0","tags":["Go"],"title":"go语言函数传值与指针的相关问题","uri":"/posts/20210604_go%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E4%BC%A0%E5%80%BC%E4%B8%8E%E6%8C%87%E9%92%88%E7%9A%84%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["操作实践"],"content":"参考： 手工下载和导入vagrant镜像 How to add a downloaded .box file to Vagrant? 由于国内网络的问题，下载Vagrant镜像非常的困难。明明我已经开了全局代理并且curl到了vagrantcloud，但是就是拉不下来镜像……无奈之下只能自力更生，直接搜索然后下载，比如这个RancherOS。我所进行的实验是Vagrant快速部署k8s，因为实验室服务器不够了，没有抵挡地住诱惑。 或者也可以查看使用vagrant up获得的信息（如下），其中URL即为下载地址。 Bringing machine 'server-01' up with 'virtualbox' provider...\rBringing machine 'node-01' up with 'virtualbox' provider...\rBringing machine 'node-02' up with 'virtualbox' provider...\r==\u003e server-01: Box 'chrisurwin/RancherOS' could not be found. Attempting to find and install...\rserver-01: Box Provider: virtualbox\rserver-01: Box Version: 1.5.1\r==\u003e server-01: Loading metadata for box 'chrisurwin/RancherOS'\rserver-01: URL: https://vagrantcloud.com/chrisurwin/RancherOS\r==\u003e server-01: Adding box 'chrisurwin/RancherOS' (v1.5.1) for provider: virtualbox\rserver-01: Downloading: https://vagrantcloud.com/chrisurwin/boxes/RancherOS/versions/1.5.1/providers/virtualbox.box ","date":"2021-06-03","objectID":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/:0:0","tags":["vagrant"],"title":"Vagrant如何手动下载官网镜像并导入","uri":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/"},{"categories":["操作实践"],"content":"搜索并获取镜像 如前面所提到，直接到官网上可以搜索到对应的box。可以使用各种离线下载工具把它弄下来，因为不大我直接用浏览器下载了。 ","date":"2021-06-03","objectID":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/:1:0","tags":["vagrant"],"title":"Vagrant如何手动下载官网镜像并导入","uri":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/"},{"categories":["操作实践"],"content":"导入镜像 我所使用的环境是vagrant 2.2.16在win10下。一个非常麻烦的原因是这个版本有个bug，所以必须使用绝对路径不能用相对路径。 新建一个metadata.json放在下载好的box旁边。将box重命名为virtualbox.box {\r\"name\": \"chrisurwin/RancherOS\",\r\"versions\": [{\r\"version\": \"1.5.1\",\r\"providers\": [{\r\"name\": \"virtualbox\",\r\"url\": \"file:///C:/Users/wtyso/Downloads/virtualbox.box\"\r}]\r}]\r} PS：其中file内一定要有三个斜杠，不然会报错……但是我不能理解为什么一个斜杠又可以，而且转义不应该是\\吗。有点懵\r 接下来，在当前目录下执行命令vagrant box add C:\\Users\\wtyso\\Downloads\\metadata.json 终于可以看到好消息： ==\u003e box: Loading metadata for box 'C:\\Users\\wtyso\\Downloads\\metadata.json'\rbox: URL: file:///C:/Users/wtyso/Downloads/metadata.json\r==\u003e box: Adding box 'chrisurwin/RancherOS' (v1.5.1) for provider: virtualbox\rbox: Unpacking necessary files from: file:///C:/Users/wtyso/Downloads/virtualbox.box\rbox:\r==\u003e box: Successfully added box 'chrisurwin/RancherOS' (v1.5.1) for 'virtualbox'! 运行vagrant box list查看结果 (base) PS C:\\Users\\wtyso\\Downloads\u003e vagrant box list\rchrisurwin/RancherOS (virtualbox, 1.5.1) 可喜可贺可喜可贺，如此就基本完结了。 原作者还提到，如果没有版本号可以使用vagrant box add centos/7 --box-version 1605.01 file://virtualbox.box的方式导入，我就不赘述了。 ","date":"2021-06-03","objectID":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/:2:0","tags":["vagrant"],"title":"Vagrant如何手动下载官网镜像并导入","uri":"/posts/20210603_vagrant%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E4%B8%8B%E8%BD%BD%E5%AE%98%E7%BD%91%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AF%BC%E5%85%A5/"},{"categories":["科研实验"],"content":"http://ita.ee.lbl.gov 这个是之前很多文章提到的web server log的存放地点。具体来说，该地址是The Internet Traffic Archive的所在。我尝试了挺久的，但是发现即使挂上代理也没有办法连上。 然后我又通过google搜索了一下，发现可以找得到，但是网址是ftp版本的。虽然打不开，但是快照是连的上的，说明服务器是正常的。 我又试了一下winscp连接，然后不行…… 这时我注意到了该组织维护的另外一个网站，我当时就想着说发个邮件问一下。不过发邮件前，我问了一下师兄。师兄想了一下，让我试着用Filezilla直接开。 我试了一下，在host里输入ita.ee.lbl.gov快速连接，然后就开了…… 开了…… QAQ我忙活了一上午！！！ 所以winscp和filezilla以及windows自带的FTP有什么区别吗，为什么其他两个连不上，但是就filezilla可以呢，是默认参数的区别吗？ ","date":"2021-04-09","objectID":"/posts/20210409_%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%8F%96-ita.ee.lbl.gov-%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8Eftp%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%80%9D%E8%80%83/:0:0","tags":["实验报告"],"title":"记一次获取 ita.ee.lbl.gov 中信息的过程与FTP连接的思考","uri":"/posts/20210409_%E8%AE%B0%E4%B8%80%E6%AC%A1%E8%8E%B7%E5%8F%96-ita.ee.lbl.gov-%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%BF%87%E7%A8%8B%E4%B8%8Eftp%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%80%9D%E8%80%83/"},{"categories":["算法"],"content":"因为好像做过这个题目，所以稍微提一下。最简单的方式就是归并排序 题解 方法分别是归并排序和树状数组。 ","date":"2021-03-17","objectID":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/:0:0","tags":["算法学习"],"title":"统计序列中的逆序对","uri":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法"],"content":"归并排序 代码来源：https://blog.csdn.net/afei__/article/details/82951905 我觉得这个写的好一些。并且官方题解里面是写反的，我一开始还看了半天。 public class Main { public static void main(String[] args) { int[] arr = new int[] { 2, 3, 8, 6, 1 }; int inversionCount = mergeSort(arr, 0, arr.length); printArray(arr); System.out.println(\"inversionCount: \" + inversionCount); } public static int mergeSort(int[] arr, int start, int end) { int inversionCount = 0; int length = end - start; if (length \u003e 1) { // 长度大于1才需要排序 int mid = (start + end) / 2; inversionCount += mergeSort(arr, start, mid); // sort left inversionCount += mergeSort(arr, mid, end); // sort right inversionCount += merge(arr, start, mid, end); } return inversionCount; } public static int merge(int[] arr, int start, int mid, int end) { // check input if (arr == null || start \u003c 0 || end \u003e arr.length) { return 0; } int[] temp = new int[end - start]; int inversionCount = 0; int i = start; // 左半部分索引 int j = mid; // 右半部分索引 int k = 0; // temp数组索引 while (i \u003c mid \u0026\u0026 j \u003c end) { if (arr[i] \u003c= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; // 一旦 arr[i] \u003e arr[j]，就会有 (mid - i) 个逆序对产生 inversionCount += mid - i; } } if (i != mid) { System.arraycopy(arr, i, temp, k, mid - i); } if (j != end){ System.arraycopy(arr, j, temp, k, end - j); } System.arraycopy(temp, 0, arr, start, temp.length); return inversionCount; } public static void printArray(int[] arr) { for (int i = 0; i \u003c arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); } } ","date":"2021-03-17","objectID":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/:0:1","tags":["算法学习"],"title":"统计序列中的逆序对","uri":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法"],"content":"树状数组 思路是这样的，对于一个给定的数组a,比如[5,5,2,3,6]，从后往前遍历，并统计其前缀和。 每加入一个数字，其添加的逆序对的个数就等于i-1位的前缀和。 以该例子作为示范，显然6,3,2都没有逆序，在输入第一个5的时候，其前缀和表示所有小于等于4的数字的数量，等于2； 以此类推，将逆序对求解转变为了求解动态前序和的问题。 由于前序和动态变化，最好的方式就是树状数组。使用官方代码 class BIT { private: vector\u003cint\u003e tree; int n; public: BIT(int _n): n(_n), tree(_n + 1) {} static int lowbit(int x) { return x \u0026 (-x); } int query(int x) { int ret = 0; while (x) { ret += tree[x]; x -= lowbit(x); } return ret; } void update(int x) { while (x \u003c= n) { ++tree[x]; x += lowbit(x); } } }; class Solution { public: int reversePairs(vector\u003cint\u003e\u0026 nums) { int n = nums.size(); vector\u003cint\u003e tmp = nums;//tmp保存前缀和 // 离散化，将具体数字转为对应的排名。说实话我来做的话可能只能开个map来存了，应该是想不到lower_bound的用法 sort(tmp.begin(), tmp.end()); for (int\u0026 num: nums) { num = lower_bound(tmp.begin(), tmp.end(), num) - tmp.begin() + 1; } // 树状数组统计逆序对 BIT bit(n); int ans = 0; for (int i = n - 1; i \u003e= 0; --i) { ans += bit.query(nums[i] - 1);//求解n-1的前缀和 bit.update(nums[i]);//把i增加进去 } return ans; } }; ","date":"2021-03-17","objectID":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/:0:2","tags":["算法学习"],"title":"统计序列中的逆序对","uri":"/posts/20210317_%E7%BB%9F%E8%AE%A1%E5%BA%8F%E5%88%97%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/"},{"categories":["算法"],"content":"区间修改问题常用的三种手段，我觉得还是有必要复习一下。 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:0:0","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"树状数组 binary index tree 来自OI-wiki的图，我记得刘汝佳书里也有，不过那本书不在我手边 树状数组的核心是lowbit：x\u0026(-x)，其中-x为x的负数的补码表示形式，计算出来可以得到x的二进制从右往左的第一个1所对应的十进制数字。 这样就可以算出非叶子节点对应的管辖范围 单点修改，一路上山 int tree[MAXN]; inline void update(int i, int x) { for (int pos = i; pos \u003c MAXN; pos += lowbit(pos)) tree[pos] += x; } 求前n项和，一路下山 inline int query(int n) { int ans = 0; for (int pos = n; pos; pos -= lowbit(pos)) ans += tree[pos]; return ans; } 区间查询 inline int query(int a, int b) { return query(b) - query(a - 1); } 举个例子，查询前6个的和，lowbit(6) =2 ，所以S[6] = c[6]+c[4]，这是比较自然的。 更新的时候，如果要更新6的话，需要更新c[6]和c[8]的值。 唯一的问题就是需要多加理解，二进制表示毕竟不够直观。但是原题目是很简单的。 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:1:0","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"RMQ Range Maximum query，区间查找算法。同样出现在刘汝佳的书里面。该算法的核心是二分法，就是将对一个区间的查找转变为对不断二分的子区间的查找，其中子区间长度均为2的倍数。 因为找不到书了，参考网上的代码 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:2:0","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"建立 假设有一个数组：1,2,6,8,4,3,7 设二维数组dp[i][j]表示从第i位开始连续2^j个数中的最小值。例如dp[2][1]表示第二位数开始连续两个数的最小值，也就是第二位数和第三位数的最小值，即2. 在求的时候可以将其分为两个部分，第一部分是$i$到$i+2^{j-1}-1$，第二部分是$i+2^{j-1}$到$i+2^{j}-1$。 显然初始值dp[i][0]为数本身，因此转移方程还是比较好求的 dp[i][j] = min(dp [i][j - 1], dp [i + (1 \u003c\u003c j - 1)][j - 1])，也即第一部分和第二部分的最小值在求解。 代码 void rmq_init()\r{\rfor(int i=1;i\u003c=N;i++)\rdp[i][0]=arr[i];//初始化\rfor(int j=1;(1\u003c\u003cj)\u003c=N;j++)\rfor(int i=1;i+(1\u003c\u003cj)-1\u003c=N;i++)\rdp[i][j]=min(dp[i][j-1],dp[i+(1\u003c\u003cj-1)][j-1]);\r} 注意循环变量的顺序不可改变。这相当于就是不断增加区间的长度来更新所有的状态。另外第二部分是可以超过数组长度限制的，这不影响最终的结果。 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:2:1","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"查询 假设需要查询区间[l,r]的最小值，令$k=log2(r-l+1)$，区间最小值RMQ[l,r] = min(dp[l][k], dp[r - (1 « k) + 1][k]);，即从左边和右边同时开始搜索的最小值。 证明过程就略了，毕竟也不是搞算法的。这里刘汝佳算法竞赛训练指南那幅图比较直观，查询时其实就是从两端伸出了两个块，只要保证2^k大于等于区间的一半，则最小值一定是能算出来的。 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:2:2","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"线段树 参考资料 特点是能够在O(logN)的时间复杂度内实现单点修改、区间修改、区间查询（区间求和、求区间最大值、求区间最小值等） 求区间最值用线段树，我的理解是在修改操作较多的时候这样会更好一些。毕竟RMQ每次修改后都要更新一遍dp数组，速度其实也不快。 核心思想也是二分法，把大区间分成两个小区间管理，直到区间长度为1为止。区间索引按照完全二叉树，所以位置为x的节点其孩子分别为2x与2x+1 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:3:0","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"树建立参考 递归方法建立线段树，其中d数组保存着树节点，a数组保存着原始数据 void build(int s, int t, int p) { // 对 [s,t] 区间建立线段树,当前根的编号为 p if (s == t) { d[p] = a[s]; return; } int m = (s + t) / 2; build(s, m, p * 2), build(m + 1, t, p * 2 + 1); // 递归对左右区间建树 d[p] = d[p * 2] + d[(p * 2) + 1]; } ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:3:1","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"区间查询 以求和为例子，查询区间[3,5]的和，可以用【3,3】+【4,5】来得到最终结果。 示例代码 int getsum(int l, int r, int s, int t, int p) { // [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p 为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = (s + t) / 2, sum = 0; if (l \u003c= m) sum += getsum(l, r, s, m, p * 2); // 如果左儿子代表的区间 [l,m] 与询问区间有交集,则递归查询左儿子 if (r \u003e m) sum += getsum(l, r, m + 1, t, p * 2 + 1); // 如果右儿子代表的区间 [m+1,r] 与询问区间有交集,则递归查询右儿子 return sum; } ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:3:2","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"区间维护 如果在修改的时候将所有区间内节点进行修改，代价将难以承受。线段树使用的是”懒惰标记“，即在父节点缓存下更改，这样在查询的时候可以直接累加上对应的修改值。 ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:3:3","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"实例代码1 区间求和 void update(int l, int r, int c, int s, int t, int p) { // [l,r] 为修改区间,c 为被修改的元素的变化量,[s,t] 为当前节点包含的区间,p // 为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) { d[p] += (t - s + 1) * c, b[p] += c; return; } // 当前区间为修改区间的子集时直接修改当前节点的值,然后打标记,结束修改 int m = (s + t) / 2; if (b[p] \u0026\u0026 s != t) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m); b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } if (l \u003c= m) update(l, r, c, s, m, p * 2); if (r \u003e m) update(l, r, c, m + 1, t, p * 2 + 1); d[p] = d[p * 2] + d[p * 2 + 1]; } int getsum(int l, int r, int s, int t, int p) { // [l,r] 为查询区间,[s,t] 为当前节点包含的区间,p为当前节点的编号 if (l \u003c= s \u0026\u0026 t \u003c= r) return d[p]; // 当前区间为询问区间的子集时直接返回当前区间的和 int m = (s + t) / 2; if (b[p]) { // 如果当前节点的懒标记非空,则更新当前节点两个子节点的值和懒标记值 d[p * 2] += b[p] * (m - s + 1), d[p * 2 + 1] += b[p] * (t - m), b[p * 2] += b[p], b[p * 2 + 1] += b[p]; // 将标记下传给子节点 b[p] = 0; // 清空当前节点的标记 } int sum = 0; if (l \u003c= m) sum = getsum(l, r, s, m, p * 2); if (r \u003e m) sum += getsum(l, r, m + 1, t, p * 2 + 1); return sum; } 区间直接修改为某个值而不是加上某个值 void update(int l, int r, int c, int s, int t, int p) { if (l \u003c= s \u0026\u0026 t \u003c= r) { d[p] = (t - s + 1) * c, b[p] = c; return; } int m = (s + t) / 2; if (b[p]) { d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m), b[p * 2] = b[p * 2 + 1] = b[p]; b[p] = 0; } if (l \u003c= m) update(l, r, c, s, m, p * 2); if (r \u003e m) update(l, r, c, m + 1, t, p * 2 + 1); d[p] = d[p * 2] + d[p * 2 + 1]; } int getsum(int l, int r, int s, int t, int p) { if (l \u003c= s \u0026\u0026 t \u003c= r) return d[p]; int m = (s + t) / 2; if (b[p]) { d[p * 2] = b[p] * (m - s + 1), d[p * 2 + 1] = b[p] * (t - m), b[p * 2] = b[p * 2 + 1] = b[p]; b[p] = 0; } int sum = 0; if (l \u003c= m) sum = getsum(l, r, s, m, p * 2); if (r \u003e m) sum += getsum(l, r, m + 1, t, p * 2 + 1); return sum; } ","date":"2021-03-17","objectID":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/:3:4","tags":["算法学习"],"title":"树状数组、线段树与RMQ","uri":"/posts/20210317_%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%B8%8Ermq/"},{"categories":["算法"],"content":"leetocde的permutation-sequence问题 使用康托编码可以在O(n)是时间内求解。 题目采用康托编码的思路。其实就是康托展开的逆过程。康托展开用来求某个全排列数是第几小的数，也就是当这些数按顺序排时第几个数。 ","date":"2021-03-15","objectID":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/:0:0","tags":["算法学习"],"title":"全排列问题与康托编码","uri":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/"},{"categories":["算法"],"content":"康托展开 过程如下：比如求321 是 第几小的，可以这样来想：小于3的数有1和2 两个，首位确定之后后面两位有2！中情况，所以共有2*2！=4种。 小于2的数只有一个1，所以有11！=1种情况，最后一位是1，没有比一小的数，所以是00！=0 综上：小于321的数有4+1=5个，所以321是第六小的数。 ","date":"2021-03-15","objectID":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/:1:0","tags":["算法学习"],"title":"全排列问题与康托编码","uri":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/"},{"categories":["算法"],"content":"反例与进一步思考 但是康托展开没有这么简单，其实是挺复杂的。以n=4的情况为例子，我们已经知道3412是第17个，也就是说有16个比它小的数字。 首位确定后，有23！=12种，这个是符合的 但是第二位的话是4，此时是先考虑小于4的情况，有1、2、3，然后再排除掉3，所以是22!=4； 第三位的话是1，此时不存在比它小的数字，所以直接排除 最后一位是2，但是枚举发现1已经计算过了，所以也排除。 最终结果是12+4=16，结果正确。虽然思路大体上是一样的，但是原文是没有筛查这个过程的，其实还是有点麻烦的，可能需要开一个集合或者专门的数据结构来进行判断。 ","date":"2021-03-15","objectID":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/:1:1","tags":["算法学习"],"title":"全排列问题与康托编码","uri":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/"},{"categories":["算法"],"content":"康托编码 康托展开的逆过程就是已知这个数是第k个数，求这个数是多少，当然是知道n的值的。 第k个数就是有k-1个数比这个数小。 所以就是 k-1=an*(n-1)!+an-1*(n-2)!+….+a1*0!; 再举一个例子： 如何找出第16个（按字典序的）{1,2,3,4,5}的全排列？ 首先用16-1得到15 用15去除4! 得到0余15 用15去除3! 得到2余3 用3去除2! 得到1余1 用1去除1! 得到1余0 有0个数比它小的数是1，所以第一位是1 有2个数比它小的数是3，但1已经在之前出现过了所以是4 有1个数比它小的数是2，但1已经在之前出现过了所以是3 有1个数比它小的数是2，但1,3,4都出现过了所以是5 最后一个数只能是2 代码如下。写的真的挺好，我第一眼还没想明白 class Solution { public: //全排列元素数量为n，返回第k个排列 string getPermutation(int n, int k) { string s(n,'0');//初始是n个零 string result; for(int i=0;i\u003cn;i++) { s[i]+=i+1;//生成默认序列,1-\u003en } return kth_permutation(s,k); } private: int factorial(int n)//返回阶乘。其实我觉得这个阶乘可以带个缓存，不过不带也可以了 { int result=1; for(int i=1;i\u003c=n;i++) { result*=i; } return result; } string kth_permutation(string \u0026s,int k) { const int n=s.size(); string result; int base=factorial(n-1); --k;//转换第k个序列为有k-1个小的序列比原序列小 for(int i=n-1;i\u003e0;k=k%base,base/=i,--i) { auto a =s.begin()+k/base;//我刚刚才意识到s本质上是剩余数字。使用迭代器来做的移动，绝了。 result.push_back(*a); s.erase(a);//删掉剩余数字 } result.push_back(s[0]); return result; } }; ","date":"2021-03-15","objectID":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/:1:2","tags":["算法学习"],"title":"全排列问题与康托编码","uri":"/posts/20210317_%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%E4%B8%8E%E5%BA%B7%E6%89%98%E7%BC%96%E7%A0%81/"},{"categories":["算法"],"content":"常用的邻接矩阵和邻接表都挺简单的，就不提了。 这个是ACM版本的前向星，本质就是用数组替换了链表，效果就是更方便一些。 虽然不如十字链表删除方便，但是也能比较方便地写出边删除的操作。 //前向星 struct graph{ typedef vector\u003cint\u003e VI; VI info,next,to; //假设现在有n个点，m条边,info长度为n，next和to长度为m。 //其中，info保存着所有节点的第一个边 //next保存着所有边信息的下一个边 //to保存着边的下一个节点信息。如果是带权边，可以增加一个weights数组，与to类似。（所有边增加主要加的是to） graph(int n=0,int m=0):to(0),next(0){ info.resize(n); next.reserve(m); to.reserve(m); } int edge_size(){ return to.size();//显然，to即保存了所有边的信息 } int vertex_size(){ return info.size();//info保存了所有节点的信息 } void expand(int i){ if(info.size()\u003ci+1) info.resize(i+1); } void add(int i,int j){//添加一条从i到j的边，有向 expand(i),expand(j); to.push_back(j);//压入新边的信息 next.push_back(info[i]);//新头的下一个指向原来的指针 info[i] = to.size()-1;//链表头指针指向新加项目 } void del_back(){ for(int i=0;i\u003cinfo.size();i++){ if(info[i] == to.size()-1){ info[i] = next.back(); break; } } to.pop_back(); next.pop_back(); } void clear(){ info.clear(); next.resize(0); to.resize(0); } }; 想了一下还是提一下邻接表吧 struct Edge{ int from,to,weight; }; vector\u003cEdge\u003e G[maxn];//可以用来模拟邻接表 //使用的时候给对应的数组G[node]插入边即可，其实也挺方便的 另外一个是刘汝佳的蓝书里面的实现，应该也是邻接表，只是G[maxn][edgeNum]里面放的不再是直接放边对象，而是改为了边索引号n。这个索引号可以由边对象数组维护，也可以由多个数据对象数组维护，比较方便。在很多时候，对边的信息没有过多要求时，直接用一两个int数组就可以表示全其信息，也比较方便。唯一的问题是不好删除。 ","date":"2021-03-15","objectID":"/posts/20210315_%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%89%8D%E5%90%91%E6%98%9F%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/:0:0","tags":["算法学习","算法_图"],"title":"图的存储方式之前向星与邻接表","uri":"/posts/20210315_%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%B9%8B%E5%89%8D%E5%90%91%E6%98%9F%E4%B8%8E%E9%82%BB%E6%8E%A5%E8%A1%A8/"},{"categories":["算法"],"content":" 字节笔试题，原题忘记了，但是稍微有些区别 题目 大致意思就是反转。 实现核心就是利用亮点： 开关本身顺序对结果没有影响 所有的1都由翻转本身得到。 class Solution { public: int minFlips(string target) { //时序无关性，因此所有的1都是反转得到的 //从头开始枚举1。字符串不翻转，反转自身 int number = 0; bool flag = true;//true，看1则翻转；false，看0则翻转 for(int i =0;i\u003ctarget.length();i++){ if(flag \u0026\u0026 target[i]=='1'){ flag = !flag; number++; }else if(!flag \u0026\u0026 target[i]=='0'){ flag = !flag; number++; } } return number; } }; 扩展问题是今天碰到的字节笔试的第三题，给定一个长度为n的环状数组，按动一次开关可以改变自己和左右的状态（0-\u003e1/1-\u003e0）。初始全部为0，问如何得到1。 这个问题比较类似POJ1830，相当于自动加上了开关变化的限制。 题目类型说明： 这道题目居然是道异或方程组的高斯消元问题。 核心原理倒是不难，现在有原状态b0和目标状态b1，就可以得到状态改变量b 例如对于原始例子而言，b_0=[0,0,0,0]，b_1=[1,1,1,1]，则b = b_0^b_1=[1,1,1,1]，其中b[i]表示第i个灯的状态 整个问题可以建模成A*x=b，其中A矩阵为开关i与j之间的影响，A[i][j]=1表示开关j会对开关i产生影响。x向量表示开关i的操作，1表示开，0表示关。 显然，x[i]对应在A矩阵中为第j列，x[i]=1时第j列被激活，以字节拿到题目为例，相当于A[j][j]=A[j-1][j]=A[j+1][j]=1，一旦j列被激活就会对周围和自己产生影响。 将A转化为分块矩阵A=[a1,a2,...,an]，则变为一个异或方程组的消元问题，使用高斯消元法即可求解。 POJ1830代码 高斯消元部分原理 线性方程组写成增广矩阵形式 找主元，对增广矩阵进行行行变换；对元素，在第i列中及以下选取绝对值最大的元素，将所有元素中最大的所在的行与第i行进行交换. 消元，采用高斯消元法使得新得到的第i行以下的元素均为零 重复上述过程，直到得到下三角阵 对上三角阵回代求解。 ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/:0:0","tags":["算法学习","算法思考"],"title":"【字节笔试，算法-简单-\u003e困难】leetcode 1529灯泡开关 + POJ 1830开关问题，从搜索到高斯消元法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"具体描述普通高斯消元伪代码 给定N行N+1列的增广矩阵aug\r第一步、循环，i从0-\u003eN-1，枚举主元\r1.1 在循环中，j从i到N-1，寻找第i列的最大主元。设最大主元在第k行\r1.2 将最大主元从k行换到i行\r1.3 消元，将i行的最大主元消去i+1-\u003eN-1的所有对应元素（i列到N-1列）\r如此，得到上三角阵\r回代求解\r从最右下角出发，求解出xn，然后从第N列反向计算回前面全部。\r对于方阵N，时间复杂度为O(N^2)\r如果行数小于列数，即未知数比方程多，则不可能有解。\r如果行数等于列数，即最终未知数等于方程，有唯一解。\r如果行数大于列数，方程比未知数多，有无穷解。 #include \u003ccstdio\u003e #include \u003ccstring\u003e #include \u003calgorithm\u003e #include \u003ccmath\u003e using namespace std; ///高斯消元模板 const int Max_M = 35; const int Max_N = 35; int Aug[Max_M][Max_N]; int m,n; ///m个方程,n个未知数 int Gauss() { int i,j; int max_r,row,col; for(col=0,row=0; row\u003cm \u0026\u0026 col\u003cn; row++,col++) { max_r = row; for(i = row+1; i \u003c m; i++) { if(Aug[i][col] \u003e Aug[max_r][col]) max_r = i; } if(max_r != row) { for(j = row; j \u003c n+1; j++) swap(Aug[max_r][j],Aug[row][j]); } if(Aug[row][col]==0) { row--; continue; } for(i = row+1; i \u003c m; i++) { if(Aug[i][col]==0) continue; for(j = col; j \u003c n+1; j++) Aug[i][j] ^= Aug[row][j]; } } for(i = row; i \u003c m; i++) { if(Aug[i][col] != 0) return -1; } return 1\u003c\u003c(n-row); ///n-row个变元,只有0/1两种取值 } ///end int main() { int i,j; int t; int nn; int start[30],end[30]; scanf(\"%d\",\u0026t); while(t--) { m = n = 0; memset(Aug,0,sizeof(Aug)); scanf(\"%d\",\u0026nn); for(i = 0; i \u003c nn; i++) scanf(\"%d\",\u0026start[i]); for(i = 0; i \u003c nn; i++) scanf(\"%d\",\u0026end[i]); while(true) { scanf(\"%d %d\",\u0026i,\u0026j); if(!i\u0026\u0026!j) break; Aug[j-1][i-1] = 1; } n = m = nn; for(i = 0; i \u003c n; i++) { Aug[i][i] = 1; Aug[i][n] = start[i]^end[i]; } int ret = Gauss(); if(ret==-1) printf(\"Oh,it's impossible~!!\\n\"); else printf(\"%d\\n\",ret); } return 0; } ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/:1:0","tags":["算法学习","算法思考"],"title":"【字节笔试，算法-简单-\u003e困难】leetcode 1529灯泡开关 + POJ 1830开关问题，从搜索到高斯消元法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_%E5%BC%80%E5%85%B3%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"今天字节笔试的第二题，详情由于保密协议不能上网，但是大意就是给一大堆节点，去求LCA。递归直接爆栈，用stack写递归有一个点，改进优化了一下有两个点…… 我印象中这个算法挺简单的，就搜了一下，果然找到了。不是，现在校招算法题都这么丧病了吗。 由于保密协议，不能放代码。后面放Tarjan算法学习笔记。 LCA问题参考资料， Tarjan的时间复杂度为O((n+q)× 并查集的复杂度 )，而使用路径压缩和按秩合并的并查集复杂度为O(Alpha(n))。所以作为离线算法，Tarjan比倍增算法快很多。 但作为在线算法，倍增算法能实时得到解法。 RMQ 复杂度介绍： Tarjan的复杂度为O(n+q) RMQ预处理为O(nlogn)，查询O(1) 倍增算法复杂度为O((n+q)logn) 参考资料： Tarjan求解LCA，非常好的教学，很详细地列举了LCA的步骤。关键是有图，有逐步分解的图，非常好。 ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/:0:0","tags":["算法学习","算法思考"],"title":"【算法-字节笔试-中等难度】Tarjan算法求解公共祖先问题LCA，并介绍倍增算法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/"},{"categories":["算法"],"content":"伪代码 Tarjan(u)//marge和find为并查集合并函数和查找函数\r{\rfor each(u,v) //访问所有u子节点v\r{\rTarjan(v); //继续往下遍历\rmarge(u,v); //合并v到u上\r标记v被访问过;\r}\rfor each(u,e) //访问所有和u有询问关系的e\r{\r如果e被访问过;\ru,e的最近公共祖先为find(e);\r}\r} ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/:1:0","tags":["算法学习","算法思考"],"title":"【算法-字节笔试-中等难度】Tarjan算法求解公共祖先问题LCA，并介绍倍增算法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/"},{"categories":["算法"],"content":"具体实现代码 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cutility\u003eusing namespace std; int N = 5; vector\u003cvector\u003cint\u003e \u003e lib;//假设lib为二维动态数组，lib[i]表示节点i的所有孩子vector vector\u003cint\u003e parent(N,0);//并查集数组 vector\u003cbool\u003e isVisited(N,false); vector\u003cvector\u003cint\u003e \u003e query;//query关系，双向的 int find(int e){ if(parent[e] != e) return find(parent[e]); return e; } void Tarjan(int u){ //访问所有的孩子 for(int i =0;i\u003clib[u].size();i++){ int v = lib[u][i]; Tarjan(v); parent[v] = u;//merge isVisited[v] = true; } for(int i = 0;i\u003cquery[u].size();i++){ int e = query[u][i]; if(isVisited[e]){ cout\u003c\u003c\"u和e的共同祖先为\"\u003c\u003cfind(u,e)\u003c\u003cendl; } } } int main(void){ for(int i = 0;i\u003cN;i++){ parent[i] = i; } Tarjan(0); cout\u003c\u003c\"test\"\u003c\u003cendl; return 0; } ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/:2:0","tags":["算法学习","算法思考"],"title":"【算法-字节笔试-中等难度】Tarjan算法求解公共祖先问题LCA，并介绍倍增算法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/"},{"categories":["算法"],"content":"倍增算法 参考资料： b站视频 csdn 实例代码（有点问题） #include \u003ccstring\u003e#include \u003calgorithm\u003econst int maxn = 1000;//递归栈的最大深度，原则上等于点的数量. const int maxm = 500; const int maxh = 31; //定义见前向星 int info[maxn]; int point[maxm]; int next[maxm]; int dep[maxn];//深度数组 int anc[maxn][maxh]; void dfs(int root){ static int Stack[maxn]; int top=0;//栈顶指针 memset(dep,0,sizeof(dep)); dep[root] = 1; for(int i = 0;i\u003cmaxh;i++){ anc[root][i] = root;//根节点无论怎么跳，都是根节点 } Stack[++top] = root;//Stack[1] = top; while(top){ int x = Stack[top]; if(x != root){ for(int i = 1;i\u003cmaxh;i++){//按照方程更新数组 int y = anc[x][i-1]; anc[x][i] = anc[y][i-1]; } } for(int \u0026i = info[x];i;i=next[i]){ int y = point[i]; if(y!=anc[x][0]){ dep[y] = dep[x] + 1; anc[y][0] = x; Stack[++top] = y; } } while(top \u0026\u0026 head[Stack[top]] == 0) top--;//清理叶子节点 } void swim(int \u0026x,int H){ //目标是让x向上跳H步，使用二进制方式 for(int i=0;H\u003e0;i++){ if(H\u00261) x = anc[x][i];//i相当于现在跳2^i步，当H%2==1时 x /= 2;//相当于右移 } } int lca(int x,int y){ int i; if(dep[x]\u003edep[y]) swap(x,y); swim(y,dep[y]-dep[x]); if(x==y) return x; for(;;){ for(i=0;anc[x][i]!=anc[y][i];i++); //同时起跳，寻找不重叠的最近的父节点 if(i==0){//找不到，则显然上一个节点即为LCA return anc[x][0]; } //起跳，因为anc[x][i] == anc[y][i]，所以只能跳到i-1 x = anc[x][i-1]; y = anc[y][i-1]; } return -1;//有点问题，应该走不到这一步 } } 该代码有一些问题： 为什么叶子节点在深搜中全部丢弃，这样它们的anc数组就没有办法更新了 最后lca的时候，-1是到不了的，因为上面是死循环，没有对其进行判断。 OI wiki的代码，题目有些区别，不过思想是一样的 #include \u003ccstdio\u003e#include \u003ccstring\u003e#include \u003ciostream\u003e#include \u003cvector\u003e#define MXN 50007 using namespace std; std::vector\u003cint\u003e v[MXN];//邻接表写法 std::vector\u003cint\u003e w[MXN]; //fa表示亲缘数组，cost表示每一跳的代价 int fa[MXN][31], cost[MXN][31], dep[MXN]; int n, m; int a, b, c; void dfs(int root, int fno) {//用显式DFS做，其实差不多 fa[root][0] = fno; dep[root] = dep[fa[root][0]] + 1; for (int i = 1; i \u003c 31; ++i) { fa[root][i] = fa[fa[root][i - 1]][i - 1]; cost[root][i] = cost[fa[root][i - 1]][i - 1] + cost[root][i - 1]; } int sz = v[root].size(); for (int i = 0; i \u003c sz; ++i) { if (v[root][i] == fno) continue; cost[v[root][i]][0] = w[root][i]; dfs(v[root][i], root); } } int lca(int x, int y) { if (dep[x] \u003e dep[y]) swap(x, y); int tmp = dep[y] - dep[x], ans = 0; for (int j = 0; tmp; ++j, tmp \u003e\u003e= 1) if (tmp \u0026 1) ans += cost[y][j], y = fa[y][j]; if (y == x) return ans; for (int j = 30; j \u003e= 0 \u0026\u0026 y != x; --j) { if (fa[x][j] != fa[y][j]) { ans += cost[x][j] + cost[y][j]; x = fa[x][j]; y = fa[y][j]; } } ans += cost[x][0] + cost[y][0]; return ans; } int main() { memset(fa, 0, sizeof(fa)); memset(cost, 0, sizeof(cost)); memset(dep, 0, sizeof(dep)); scanf(\"%d\", \u0026n); for (int i = 1; i \u003c n; ++i) { scanf(\"%d %d %d\", \u0026a, \u0026b, \u0026c); ++a, ++b; v[a].push_back(b); v[b].push_back(a); w[a].push_back(c); w[b].push_back(c); } dfs(1, 0); scanf(\"%d\", \u0026m); for (int i = 0; i \u003c m; ++i) { scanf(\"%d %d\", \u0026a, \u0026b); ++a, ++b; printf(\"%d\\n\", lca(a, b)); } return 0; } ","date":"2021-03-14","objectID":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/:3:0","tags":["算法学习","算法思考"],"title":"【算法-字节笔试-中等难度】Tarjan算法求解公共祖先问题LCA，并介绍倍增算法","uri":"/posts/20210314_%E5%AD%97%E8%8A%82%E7%AC%94%E8%AF%95_tarjan%E7%AE%97%E6%B3%95%E6%B1%82%E8%A7%A3%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E9%97%AE%E9%A2%98lca%E4%B8%8E%E5%80%8D%E5%A2%9E/"},{"categories":["计算机基础"],"content":" 复习一下基本的排序算法 ","date":"2021-03-12","objectID":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:0:0","tags":["算法与数据结构","算法_排序算法"],"title":"C++复现基础排序算法","uri":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["计算机基础"],"content":"快速排序 时间复杂度O(nlogn)，不稳定 这个写法是我刻在DNA里的，应该没什么大问题，除了比较抽象之外都还好。 #include \u003cstring\u003e#include \u003cvector\u003e#include \u003ciostream\u003eusing namespace std; void quickSort(vector\u003cint\u003e\u0026 arr,int low,int high){ if(low==high) return cout\u003c\u003clow\u003c\u003c\" \"\u003c\u003chigh\u003c\u003cendl; int i = low; int j = high; int mid = (i+j)/2; int v = arr[mid]; do{ while(arr[i]\u003cv) i++; while(arr[j]\u003ev) j--; if(i\u003c=j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++,j--; } cout\u003c\u003c\"inside\"\u003c\u003ci\u003c\u003c\" \"\u003c\u003cj\u003c\u003cendl; }while(i\u003c=j); if(i\u003chigh){ quickSort(arr,i+1,high); } if(j\u003elow){ quickSort(arr,low,j-1); } } int main(void){ vector\u003cint\u003e arr{2,5,3,4,1,9,7}; quickSort(arr,0,arr.size()-1); for(auto ele:arr){ cout\u003c\u003cele\u003c\u003cendl; } } ","date":"2021-03-12","objectID":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:1:0","tags":["算法与数据结构","算法_排序算法"],"title":"C++复现基础排序算法","uri":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["计算机基础"],"content":"堆排序 理论上可以到O(nlogn)，且是稳定的，所以之前打比赛的时候很喜欢用。 nlogn的版本堆就不能自己写了， 要用优先队列 #include \u003cstring\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; void heapSort(vector\u003cint\u003e\u0026 arr){ priority_queue\u003cint,vector\u003cint\u003e,greater\u003cint\u003e \u003e q; for(auto ele:arr){ q.push(ele); } while(!q.empty()){ cout\u003c\u003cq.top()\u003c\u003cendl; q.pop(); } } int main(void){ vector\u003cint\u003e arr{2,5,3,4,1,9,7}; heapSort(arr); } 如果是自定义类型的话需要重写优先队列的比较函数 #include \u003cstring\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include \u003cqueue\u003eusing namespace std; struct myClass{ int ele; myClass(int e){ this-\u003eele = e; } }; struct cmp{ bool operator()(myClass a,myClass b){ return a.ele\u003eb.ele; } }; void heapSort(vector\u003cint\u003e\u0026 arr){ priority_queue\u003cmyClass,vector\u003cmyClass\u003e,cmp \u003e q; for(auto ele:arr){ q.push(myClass(ele)); } while(!q.empty()){ cout\u003c\u003cq.top().ele\u003c\u003cendl; q.pop(); } } int main(void){ vector\u003cint\u003e arr{2,5,3,4,1,9,7}; heapSort(arr); } ","date":"2021-03-12","objectID":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/:2:0","tags":["算法与数据结构","算法_排序算法"],"title":"C++复现基础排序算法","uri":"/posts/20210312_c++%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"categories":["算法"],"content":"题目来源为：牛客网 题目有意思的地方在于，最长公共子串与最长连续公共子串都是比较经典的问题，但是这道题在其基础上加了限制。 首先这道题应该是最长连续公共子串问题，状态转移方程就不写了，挺简单的。就记录下最大的子串所在的位置的行坐标和列坐标，就能把子串拿到手。 但是对于O(nm)的动态规划所有点都会超时，这就很厉害了，目前通过的做法使用的是滑动窗口法，我还在研究。 代码大概长这样 /** * 滑动窗口算法 * * @param str1 string字符串 the string * @param str2 string字符串 the string * @return string字符串 */ public static String LCS1(String str1, String str2) { // write code here StringBuilder sb = new StringBuilder(); int start = 0, end = 1; while (end \u003c str1.length() + 1) { if (str2.contains(str1.substring(start, end))) { if (sb.length() \u003c end - start) { sb.delete(0, sb.length()); sb.append(str1, start, end); } } else { //这个算法我曾经疑惑，假如出现start\u003eend，程序不是会crash么 //通过debug发现，当start==end时，substring获取的是\"\"，此时contains必然为true //所以当start == end时，必然会走end++分支 start++; } end++; } if (sb.length() == 0) { return \"-1\"; } return sb.toString(); } 我的理解是start和end维护了一个滑动窗口。（java的substring是前闭后开，所以开始只有一个字母） 如果滑动窗口存在，则长度增加 如果不存在，则起始位置增加 每次遇到最长的时候都记录下来。 我一开始比较疑惑的地方在于，这样做为什么能够保证正确性，就没太想明白。 后面我想通了，正着想比较困难，我是反着想的。就假设str1串和str2串之间存在着一个长度为maxlen的最大子串，开始位置在maxbeg。一个很显然的情况是，该子串一定是通过滑动窗口的方式过去的。 就有两种情况，一种是滑动窗口在匹配到最大子串前长度不够，显然它能够顺利增长到匹配为止。另一种情况是滑动窗口的起始点没有匹配到子串的起始点，它显然也会不断失配往后移动。因此，该滑动窗口一定能匹配到最大连续公共子串。 C++题解，不过只有93%的击败率。应该是一些细节吧，比如使用数组会比vector要快一些等。但大致思路已经是差不多的 #include \u003ciostream\u003e#include \u003cvector\u003e#include \u003cstring\u003e#include \u003calgorithm\u003eusing namespace std; class Solution{ public: bool check(string S,string P){ //检查S子串中是否存在P子串 //根据P子串构建next数组 vector\u003cint\u003e nxt(P.length(),0); size_t point = 1; size_t now = 0; while(point\u003cP.length()){ //第一种情况，now==point if(P[point] == P[now]){ point++; now++; } else if(now\u003e0){ now = nxt[now-1]; } else{ point++; } } //开始匹配 unsigned int tar = 0; //S unsigned int pos = 0; //P while(tar\u003cS.length()){ if(S[tar] == P[pos]){ tar++,pos++; }else if(pos\u003e0){ pos = nxt[pos-1]; }else{ tar++; } if(pos==P.length()){ return true; } } return false; } string LCS(string str1,string str2){ int maxStart = -1,maxLen = -1; size_t start = 0; size_t len = 1; size_t size1 = str1.length(); while(start + len \u003c= size1){ //长度没有超 //子串 str1.substr(start,len) 是否存在于str2中 ! 如何快速判断， // 如果存在，则记录，并累加 if(this-\u003echeck(str2,str1.substr(start,len))){ cout\u003c\u003cstart\u003c\u003c\" \"\u003c\u003clen\u003c\u003cendl; cout\u003c\u003cstr1.substr(start,len)\u003c\u003cendl; maxStart = start; maxLen = len; len++; } // 如果不存在，滑动窗口继续滑动 else{ start++; } } if(maxStart == -1){ return \"-1\"; }else{ return str1.substr(maxStart,maxLen); } } }; int main(void){ Solution s; string str1(\"22222\"),str2(\"22222\"); //cin\u003e\u003estr1\u003e\u003estr2; cout\u003c\u003cs.LCS(str1,str2)\u003c\u003cendl; cout\u003c\u003cs.check(str1,str2)\u003c\u003cendl; } ","date":"2021-03-11","objectID":"/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/:0:0","tags":["算法题解","动态规划","算法_字符串"],"title":"【动态规划】最长公共子串问题","uri":"/posts/20210311_%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E9%97%AE%E9%A2%98/"},{"categories":["算法"],"content":"太久没打了，刚好有道题用上了，就复习一下。 我觉得复到KMP应该就够用了，如果要AC自动机我直接死在那里。 参考资料 如何更好地理解和掌握 KMP 算法? - 阮行止的回答 - 知乎 https://www.zhihu.com/question/21923021/answer/1032665486 ","date":"2021-03-11","objectID":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:0:0","tags":["算法学习","算法_字符串"],"title":"KMP算法复习","uri":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["算法"],"content":"核心思想 KMP算法要解决的问题是字符串匹配问题。给定原串S和模版串P，求解原串中是否存在子字符串与模版串相匹配。 最简单的想法就是暴力搜索，设原串S长度为n，模板串P长度为m，显然暴力的时间复杂度为O(nm)，非常慢。 KMP的想法是充分利用适配信息，其next数组的定义如下：next[i]表示在P[0:i]子串中，使前k个字符恰好等于后k个字符的最大的k，且k不能等于i+1（否则就等于它自己了） 这个数组的定义挺绕的，第一眼基本都不会反应过来，我就不插图了，只用文本表述一下（建议看图）。KMP的失配匹配，本质上就是把模版串向前伸，直到伸到前缀与后缀匹配为止，这实际上就是自己与自己匹配。因此这个k就是前缀与后缀相同的最大长度k。 因此next数组可以用如下方法求得 def getNxt(x): for i in range(x,0,-1): if p[0:i] == p[x-i+1:x+1]: return i return 0 nxt = [getNxt(x) for x in range(len(p))] 构建next数组的复杂度显然是O(m^2)的 使用next数组加速匹配 def search(p,s): tar = 0 # 主串中将要匹配的位置 pos = 0 # 子串中将要匹配的位置 while tar \u003c len(s): if s[tar] == p[pos]: # 若两个字符相同，匹配成功，tar和pos各进一步 tar += 1 pos += 1 elif pos\u003e0: # 失配，且pos\u003e0，则next数组移动 pos = nxt[pos-1] else: # pos[0]也失配了，则主串前进 tar += 1 if pos == len(p): # pos走到了len(p)，匹配成功 print(tar-pos) # 输出起始地点 pos = nxt[pos-1] # 当作失配，继续下一次匹配 时间复杂度为O(n+m)，会比暴力方法小很多。 ","date":"2021-03-11","objectID":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:1:0","tags":["算法学习","算法_字符串"],"title":"KMP算法复习","uri":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["算法"],"content":"快速求next数组 这一步也是KMP的精髓，前面我没记错的话应该是MP算法，这一步是K算法。 其核心在于让P自己与自己做匹配。 next数组的定义是使得前缀与后缀的前k个字符相等的最大的k，隐含着一个匹配。因此可以考虑使用next数组递归求解自身 现在考虑两种情况，对于给定字符串 a b c a b d d d a b c a b c\r_________ X ----__________X\r0 0 0 1 2 0 0 0 1 2 3 4 5 ? 前一个子串为A串，后一个子串为B串在两个X的地方。如果前者等于后者，则？处的next显然等于6，即next[i-1]+1，即得配的情况。 但是现在是失配了，显然目标是要找到一个新的now，使得前面的前缀与后面的后缀相同，而且注意到前面的A串与B串是相同的，因此就可以利用起A串的next数组。 nxt = [] def buildNxt(): nxt.append(0) # next[0]一定是0 x = 1 #求解从1开始 now = 0 while x \u003c len(p): if p[now] = p[x]: #第一种情况，得配，相前一位 now += 1 x += 1 nxt.append(now) # 之前没有，我看了一下意思，我觉得要加上 elif now\u003e0: # 失配，需要缩小now now = nxt[now-1] else: nxt.append(0) #now最小，此时肯定为0 x += 1 ","date":"2021-03-11","objectID":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:2:0","tags":["算法学习","算法_字符串"],"title":"KMP算法复习","uri":"/posts/20210311_kmp%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":" 该文的阅读感想 CAP理论断言，最多只能满足数据一致性、可用性、分区容忍性这三要素中的两个。 REF: What is CAP 数据一致性（consistency）：所有节点访问同一份最新的数据副本。就是说所有副本之间互相同步，在任何时候保持着同一个状态 高可用性（availability）：每一个请求最终都会成功。对节点的任何读写请求都不会被拒绝。 网络容忍性(Network Partition Tolerance)：当网络断开连接的时候，系统能够继续运行。即使某些或者所有的节点都不能够互相通信。一般指的是跨区域的数据库，此时很难保证两个数据库之间相互连接。 通过显式处理分区情景，系统设计师可以做到优化数据一致性和可用性，进而取得三者的平衡。我自己对这句话的理解是这样的，假设现在存在两个节点N1和N2，所有更新操作都会互相通知，显然可以满足数据一致性C。当两者不能互相连接的时候，有三种情况：1. 两者继续服务，更新数据，此时数据必定不一致，就是放弃了C来换去A，同时维护P；2.N1和N2都不服务，放弃可用性来取得C和P。3. 只有N1服务，此时数据一致性得到部分保留，可用性得到部分保留，同时维护了P。我觉得第三种就是这种所谓的权衡。 作者指出，三选二这样的语句本身是不严谨的。实际上，只有在分区存在的前提下呈现完美的数据一致性和可用性这种很少见的情况是CAP理论所不允许出现的。因此在实际设计中有着很多的变通方案和灵活度。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:0:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"三选二公式的误导性 分区很少发生，那么在系统不存在分区的情况下没理由去牺牲C和A。 C和A之间的取舍可以在同一系统中以非常细小的粒度反复发生，每一次的决策可能因为具体的操作，或者牵涉到特定的数据或用户而有所不同。 这三种性质都可以在程度上衡量，并不是非黑即白的有或者无，可用性是一个百分比，一致性也分很多级别，分区也有不同的定义。 CAP在大多数时候允许完美的C和A，那在P出现的时候，准备一些策略去处理其影响即可，包括： 探知分区发生 进入显式的分区模式以限制某些操作 启动恢复过程以恢复数据一致性并补偿分区期间发生的错误 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:1:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"ACID、BASE和CAP ACID和BASE分处一致性-可用性分布图谱的两极 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:2:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"ACID 数据库的传统设计思路，注重一致性，写入数据库教材的经典原则。这也是事务transaction的基本性质 原子性atom：操作要么全部成功，要么全部失败。所有的系统都受惠于原子性，这是没有理由改变的，可以极大简化分区恢复 一致性consistency：事务不能破坏任何数据库规则，如键的唯一性。（CAP的C仅指单一副本上的一致性，因此是其子集）ACID一致性不能在恢复过程中保持，因此分区恢复的时候要考虑重建一致性。 隔离性Isolation:数据库允许多个并发事务对其数据进行同时读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。这也是CAP理论的核心，如果系统要求ACID隔离性，那在分区P期间，最多可以在分区的一侧维持操作。事务的可串行性要求全局的通信，因此在分区的情况下不能成立。只有在分区恢复时进行补偿，在分区前后保持一个较弱的正确性定义是可行的。 持久性Durability：事务处理结束后，对数据的修改就是永久的。牺牲持久性也没有意义。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:2:1","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"CAP和延迟的联系 CAP理论的经典解释是忽略网络延迟的，但实际中延迟和分区密切相关。在操作的间隙，系统需要作出决策： 取消操作，降低系统可用性。或是 继续操作，以冒险损失系统一致性为代价 依靠多次尝试通信来达成一致性，比如Paxos算法或者两阶段事务提交，仅仅是推迟了决策时间。无限期地尝试下去，本身就是选择一致性牺牲可用性的表现。 从延迟的角度抓住了设计的核心问题：分区两侧是否在无通信的情况下继续操作？ 从这个实用的观察角度导出两条推论： 分区并不是全体节点的一致见解，因为有的节点检测到分区，有的节点没有 检测到分区的节点会进入到分区模式，这是优化C和A的核心环节。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:2:2","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"CAP之惑 对于可用性和一致性的作用范围的误解比较严重。 离线模式正在变得越来越重要，比如HTML5的客户端持久化存储特性。这些离线系统在C和A中会更倾向于A，此时就不得不在长时间处于分区状态后进行恢复。 “一致性的作用范围”其实反映了这样一种观念，即在一定的边界内状态是一直的，但超出了边界就无从谈起。比如在一个主分区内可以保证完备的一致性和可用性，而在分区外服务是不可用的。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:3:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"管理分区 由于基本操作是原子的，因此分区检测一定发生在两个事务之间，然后在分区结束后执行分区恢复来恢复一致性。 当系统进入分区模式，有两种可行的策略。其一是限制部分操作，因此会削弱可用性；其二是额外记录一些有利于后面分区恢复的操作信息。系统可以通过持续尝试恢复通信来察觉分区何时结束。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:4:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"哪些操作可以执行？ 决定限制哪些操作，主要取决于系统需要维持哪几项不变性约束。 对分区两侧跟踪操作历史的最佳方式是使用版本向量，版本向量可以反映操作间的因果依赖关系。向量的元素是（节点, 逻辑时间）数值对，分别对应一个更新了对象的节点和它最后更新的时间。对于同一对象的两个给定的版本 A 和 B，当所有结点的版本向量一致有 A 的时间大于或等于 B 的时间，且至少有一个节点的版本向量有 A 的时间较大，则 A 新于 B。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:5:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"分区恢复 到了某个时刻，通信恢复，分区结束。 分区恢复过程中，设计师必须解决两个问题： 分区两侧的状态最终必须保持一致 必须补偿分区期间产生的错误 通常情况，矫正当前状态最简单的解决方法是回退到分区开始时的状态，以特定方式推进分区两侧的一系列操作，并在过程中一直保持一致的状态。 这样总是会有存在不能自动合并的冲突的情况，比如版本控制系统CVS，如git，就会有需要手动合并分支的时候。 相反，有些系统用了限制操作的办法来保证冲突总能合并。因此，虽然总的来说冲突问题不可解，但现实中设计师可以选择在分区期间限制使用部分操作，以便系统在恢复的时候能够自动合并状态。如果要实施这种策略，推迟有风险的操作是相对简单的实现方式。 还有一种办法是让操作可以交换顺序，这种办法最接近于形成一种解决自动状态合并问题的通用框架。但是好像挺复杂的，作者的说法是实现起来没那么容易 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:6:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"补偿错误 一般系统在分区恢复期间检查违反情况，修复工作也必须在这段时间内完成。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:7:0","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"历史信息引入 恢复外在错误通常要求知道一些有关外在输出的历史信息。以“喝醉酒打电话”为例，一位老兄不记得自己昨晚喝高了的时候打过几个电话，虽然他第二天白天恢复了正常状态，但通话日志上的记录都还在，其中有些通话很可能是错误的。拨出的电话就是这位老兄的状态（喝高了）的外在影响。而由于这位老兄不记得打过什么电话，也就很难补偿其中可能造成的麻烦。 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:7:1","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["计算机基础"],"content":"补偿性事务 曾经有人正式研究过将补偿性事务作为处理长寿命事务（long-lived transactions）的一种手段 21,22。长时间运行的事务会面临另一种形态的分区决策：是长时间持有锁来保证一致性比较好呢？还是及早释放锁向其他事务暴露未提交的数据，提高并发能力比较好呢？比如在单笔事务中更新所有的员工记录就是一个典型例子。按照一般的方式串行化这笔事务，将导致所有的记录都被锁定，阻止并发。而补偿性事务采取另一种方式，它将大事务拆成多个分别提交的子事务。如果要中止大事务，系统必须发起一笔新的、起纠正作用的事务，逐一撤销所有已经提交的子事务，这笔新事务就是所谓的补偿性事务。 经验太少，没太看明白 ","date":"2021-03-10","objectID":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/:7:2","tags":["分布式系统","学习笔记"],"title":"分布式系统-CAP理论十二年回顾：规则变了","uri":"/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/"},{"categories":["算法"],"content":"面的微信部门，应用研发岗实习一面。我人都傻了，我填的不都是java研发之类的，怎么冒出个这么奇怪的岗位。 题目是这样子的：对于一个给定的子序列，比如说[1,2,3,10,4,2,5,6]，要求去除一段连续的数据，使得剩下的数据是非下降的。输出的结果是去除的最少数字的数量。（可以不唯一） 比如说对于上面这个序列，显然其去除的可以是10,4,2，也就是输出3。也可以选择去除3,10,4，结果也是相同的。 这道题是我面试腾讯微信部门的第二道面试题，感谢面试官给了我充足的时间，虽然我还是没有做出来QAQ。 ","date":"2021-03-10","objectID":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/:0:0","tags":["算法思考","算法_动态规划"],"title":"微信面试算法题-最长拼接子序列","uri":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":["算法"],"content":"当时的想法 提到这种上升或下降式的序列，第一个想到的就是最长连续上升子序列之类的题目，就想到用DP来做。然后发现一个很尴尬的问题：状态转移方程建不出来^_^。这个真的是从做DP到现在一直困扰我的梦靥了，那就没办法了。不排除能用DP做，只是我比较菜，有时间专门研究一下吧…… 第二个想法就是观察原序列。显然，被去除掉的结构一定是存在逆序的，就是说索引顺序与值顺序不一致，比如10,4这样。那有一个想法，如果我用递归的思想，不断二分原序列，将其拆解到只剩下两个数字。然后对于小的逆序对，删除掉大的。再对其拼接的过程中不断去除逆序结构，最终应该会剩下多条顺序链。 但是在如何拼接顺序链以及确认该步骤是正确的地方上卡住了。 ","date":"2021-03-10","objectID":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/:1:0","tags":["算法思考","算法_动态规划"],"title":"微信面试算法题-最长拼接子序列","uri":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":["算法"],"content":"现在的想法 考完出来之后我就有了个新的想法。由于只能切一刀，显然只有三种情况：把前面部分切掉，只保留后面部分；把后面部分切掉，只保留前面部分；以及中间切一刀，保留两边部分。 无论怎么切，都可以用归纳法证明，剩下的一定是一条连续非下降子序列。所以问题转变为：求解以头开始或者以尾结束的最长连续子序列的长度，然后尝试把它们拼接起来。 算法正确性证明我忘了，好久没干了，不过感觉这个靠谱多了。 ","date":"2021-03-10","objectID":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/:2:0","tags":["算法思考","算法_动态规划"],"title":"微信面试算法题-最长拼接子序列","uri":"/posts/20210310_%E6%9C%80%E9%95%BF%E6%8B%BC%E6%8E%A5%E5%AD%90%E5%BA%8F%E5%88%97/"},{"categories":["计算机基础"],"content":"第一章 计算机网络体系结构 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:1:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.1 计算机网络概述 分类 按分布范围可以分为广域网、城域网和局域网 按拓扑结构分类可以分为星形网络、总线形网络、环形网络和网状形网络。 按交换技术可以分为电路交换网络（传统电话网络）、报文交换网络、分组交换网络（也成为包交换网络） 1.1.6 计算机网络的性能指标 带宽bandwidth，表示网络的通信线路所能传输数据的能力，单位是比特每秒。 时延delay，指数据从网络的一端传送到另一端所需要的总时间，由四个部分构成：发送时延、传播时延、处理时延和排队时延。 发送时延：又称传输时延，结点将分组的所有比特推向传输链路所需要的时间，即从发送分组的第一个比特算起，到该分组最后一个比特发送完毕所需的时间。发送时延=分组长度/信道宽度 传播时延：电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端到另一端传播所需的时间，传播时延=信道长度/电磁波在信道上的传播速率。 处理时延：数据在交换节点为存储转发而进行的一些必要的处理所花费的时间。 排队时延：分组在进入路由器中先在输入队列进行排队等待处理，以及确定转发端口后在输出队列等待转发。 时延带宽积：若发送端连续发送数据，在发送的第一个比特即将到达终点时，表示发送端已经发出的比特数，时延带宽积=传播时延*信道带宽 往返时延：Round-trip time,RTT。表示从发送端发送数据开始，到发送端收到来自接收端的确认总共经历的时延。 吞吐量throughput：表示在单位时间内通过某个网络的数据量，受网络的带宽或网络的额定速率限制。 速率：网络中的速率指链接在计算机网络上的主机在数字信道上传输数据的速率，也称为数据率或比特率，单位是b/s，或bps。通常把最高的数据率称为带宽。 错题 计算机网络从逻辑功能上可以分为通信子网和资源子网。 通信子网指网络中实现网络通信功能的设备及其软件的集合，包括通信设备、网络通信协议、通信控制软件，是网络的内层，负责信息的船速。包括中继器、集线器、网桥、路由器、网关等硬件设备。 资源子网负责全网的数据处理业务，负责向网络用户提供各种网络资源与网络服务，资源子网主要由计算机系统、终端、联网外部设备、各种软件资源和信息资源等组成。 广域网和局域网之间的差异不仅在于它们所覆盖范围的不同，还在于它们所采用的协议和网络技术的不同。广域网使用点对点等技术，局域网使用广播技术。 网络设备，中继器和桥接器通常是用于局域网的物理层和数据链路层的连网设备。局域网接入广域网主要通过路由器来实现。 网络的拓扑结构主要指通信子网的拓扑结构。通信子网包括物理层、数据链路层、网络层。集线器、交换机和路由器分别工作在物理层、链路层和网络层。 广播式网络共享广播信道，通常是局域网的一种通信方式，局域网工作在数据链路层，故不需要网络层，因而也没有路由选择的问题。但是数据链路层使用物理层的服务必须通过服务访问点来实习。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:1:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2 计算机网络体系结构与参考模型 分层的基本原则： 每一层实现一种相对独立的功能，降低大系统的复杂度。 各层之间界面自然清晰，易于理解，相互交流尽可能少。 各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。 保持下层对上层的独立性，上层单向使用下层提供的服务。 整个分层结构应能促进标准化工作。 一个报文(PDU) = 数据部分(SDU)+控制信息部分(PCI) 服务数据单元SDU：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。 协议控制信息PCI：控制协议操作的信息。 协议数据单元PDU：物理层的PDU叫比特，链路层的PDU叫帧，网络层的PDU叫分组，传输层的PDU叫报文。 各层间传输数据的时候，把第n+1层收到的PDU作为第n层的SDU，加上PCI后进行发送。 层次结构的定义： 第n层的实体不仅要使用第n-1层的服务，实现自身定义的功能，还要向第n+1层提供本层的服务。 最底层只提供服务，中间即是服务使用者、又是服务提供者，最上层面向用户提供服务。 1.2.2 计算机网络协议、接口、服务的概念 协议是规则的集合，由语法、语义、同步三部分组成。 语法：规定了传输数据的格式 语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作以及做出何种应答。 同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。 接口：接口是同一结点内相邻两层间交换信息的连接点，是一个系统的内部规定。在典型的接口上，同一结点相邻两层的实体通过服务访问点(Service access point,SAP)进行交互。服务是通过服务访问点提供给上层使用的。 SAP是一抽象的概念，它实际上就是一个逻辑接口。 服务指下层为紧相邻的上层提供的功能调用。上层使用服务时必须与下层交互一些命令，这些命令在OSI中称为服务原语，即： 请求request：由服务用户发往服务提供者，请求完成某项工作。 指示indication：由服务提供者发往服务用户，指示用户做某件事 响应response：由服务用户发往服务提供者，作为对指示的相应。 证实conformation：由服务提供者发往服务用户，作为对请求的证实。 协议和服务是不一样的，本层协议的实现才能保证向上一层提供服务，本层的服务用户只能看见服务而看不见下面的协议。 服务类型：面向连接服务、无连接服务。可靠服务、不可靠服务。有应答服务、无应答服务。 1.2.3 ISO/OSI参考模型和TCP/IP模型 OSI七层模型 OSI七层模型，从下到上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。 其中底下三层称为通信子网，是为了联网而附加上去的通信设备，完成数据传输功能。顶三层称为资源子网，相当于计算机系统，完成数据的处理等功能。 物理层：传输单位比特，功能是在物理媒体上为数据端设备透明的传输原始比特流。主要定义数据终端设备DTE和数据通信设备DCE的物理和逻辑连接方法。 物理层主要研究以下内容： 通信链路与通信结点之间的连接需要的电路接口的参数（机械形状、尺寸、交换电路的数量与排列） 通信链路上传输的信号的意义和电气特征，比如高低电平的规定，信号的规定等。 PS：传输信息所利用的一些物理媒体，比如双绞线、光缆、无线信道等，并不在物理层协议之内。 数据链路层：传输单位是帧，任务是将网络层传下来的IP数据组装成帧。功能为：成帧、差错控制、流量控制和传输管理。 差错控制：检测物理层发生的差错，并丢弃收到的错误信息。 流量控制：协调相邻物理结点之间的速度。 数据链路层协议：SDLC、HDLC、PPP、STP和帧中继 网络层：传输单位是数据报（分组、包），主要任务是把网络层协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 差错控制：同上 拥塞控制：如果拥塞状态使得网络层中的两个结点无法正常通信，则采用一些措施缓解拥塞。 网络层协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 传输层：传输单位是报文段TCP或用户数据包UDP(报文)，任务是负责主机中两个进程之间的通信，功能为端到端提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 传输层协议：TCP、UDP 会话层：允许不同主机上各进程之间的绘画，利用传输层提供的端到端服务，管理主机之间的会话进程，包括建立、管理以及终止进程间的绘画。 表示层：主要用于处理在两个通信系统中交换信息的表示方式。比如不同机器会采用不同的编码和表示方式，以及数据结构。 应用层：最高层，包括FTP、SMTP、HTTP等协议。 TCP模型 网络接口层：对应于OSI的物理层和数据链路层，表示与物理网络的接口 网际层：（主机-主机），即OSI的网络层，将分组发往任何网络并独立选择合适的路由。 传输层：与OSI的传输层类似，使发送端和目的端的主机上的对等实体可以进行会话，主要使用TCP和UDP。 应用层：用户-用户，包含所有高层协议，对应于OSI的应用层呢个、表示层和会话层。 实际使用 一般综合两者优点，采用五层协议的体系结构，即物理层、数据链路层、网络层、传输层和应用层。 需要注意，数据传输过程是将数据层层下放到最底层，最后形成的数据报通过通信线路传输，到达接收方结点协议栈，再层层拆开得到数据。 错题 世界上第一个计算机网络是ARPAnet 协议是指在不同结点对等实体之间进行通信的规则或约定。 OSI数据链路层的功能：保证数据正确的顺序和完整性。 物理层不参与数据封装工作。 OSI中传输层是实现端到端的应答、分组排序和流量控制的协议层。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:1:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第二章 物理层 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:2:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1 通信基础 （需要进一步研究与练习） 码元：指用一个固定时长的信号波形来表示一位k进制数字。 数据通信系统可以划分为信源、信道和信宿三部分。 信源是发送数据的源头，信宿是接受数据的终点。 信道与电路不同，是信号传输的媒介。 从通信双方信息的交互方式来看，有三种基本方式： 单工通信：只有一个方向的通信而没有反方向的交互，仅需要一条信道，比如无线广播。 半双工通信：通信的双方都可以发送或接收信息，但任何一方都不能同时发送或接受，需要两条信道。 全双工通信：通信双方可以同时发送和接收信息，需要两条信道。 信道的极限容量是指信道的最高码元传输速率或信道的极限信息传输速率。 频带带宽：信道中信号最高变化频率。 码元传输速率，表示单位时间内数字通信系统所传输的码元个数，单位是波特Baud。码元速率与数据的进制数无关。 信息传输速率，表示单位时间内数字通信系统传输的二进制码元个数（比特数），单位是比特/秒。 带宽指信号具有的频带宽度，单位是赫兹Hz。常用来表示单位时间内从网络中的某一点到另一点所能通过的最高数据率，此时单位为bps PS：若一个码元携带n bit的信息量，M baud的信息传输速率为M*n bit/s 2.1.2 奈奎斯特定律和香农定律 奈奎斯特定律指出，在理想低通（没有噪声、带宽有限）的信道中，极限码元传输率为2W Baud/s，其中W为理想低通信道的带宽，单位为Hz。若用V表示每个码元离散电平的数目，则极限数据率为：理想低通信道下的极限数据传输率=2Wlog2V(单位bps) 结论： 在任何信道中，码元传输的速率是有上限的。若传输速率超过此上限，就会出现严重的码间串扰问题（指在接收端收到的信号的波形失去了码元之间的清晰界限），使得接收端对码元的完全正确识别成为不可能。 信道的频带越宽（能通过的信号高频分量越多），就可以用更高的速率进行码元的有效传输。 奈氏准则没有对信息传输速率给出限制，即没有对一个码元可以对应多少个二进制位作出限制。 香农定理给出了带宽受限且有高斯白噪声干扰的信道的极限数据传输速率 = Wlog2(1+S/N)，单位bps 其中W为信道的带宽，S为信道所传输信号的平均功率，N为信道内部的高斯噪声功率，S/N为信噪比，即信号的平均功率和噪声的平均功率之比，=10log10(S/N)，单位是分贝。 结论： 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 对一定的传输带宽和一定的信噪比，信息传输速率的上限就确定了。 只要信息的传输速率低于信道的极限传输速率，就一定能找到某种方法来实现无差错的传输。 香农定律得出的为极限传输速率，实际信道能达到的传输速率比它低不少。 2.1.3 编码与调制 调制：数据变为模拟信号的过程 编码：数据变为数字信号的过程 编码为数字信号： 非归零码NRZ：使用两个电压来代表两个二进制数字。没有检错功能，无法判断码元的开始和结束，难以让收发双方保持同步。 曼彻斯特编码，将一个码元分为两个相等的间隔，前高后低为1,0则相反。也可采用相反的规定。它所占用的频带宽度是原始的基带宽度的两倍。（以太网使用） 差分曼彻斯特编码，常用于局域网。若码元为1，前半个码元的电平与上一个码元的后半个码元的电平相同，若为0则相反。每个码元的中间都有一次电平的跳转来实现自同步。 4B/5B编码，将欲发送数据流每4位作为一组，转为相应的5位码，只用其中的16位作为数据码，另外16位作为控制码保留。 调制为模拟信号： 幅移键控ASK：通过改变载波信号的振幅来表示1和0。抗干扰能力差。 频移键控FSK：改变载波信号的频率。易于实现，抗干扰能力强。 相移键控PSK：通过改变载波信号的相位来表示。 正交振幅调制QAM，频率相同的前提下结合ASK与PSK，形成叠加信号。波特率B，采用m个相位，每个相位n种振幅，数据传输率R=Blog2(m*n) 采样定理（奈奎斯特定理）：采样频率必须大于或等于原始信号中最大频率的两倍，才能保证采样后的数字信号能完整保留原始模拟信号的信息。 模拟转数字： 抽样，对模拟信号进行周期性扫描，把时间上连续的信号变为时间上离散的信号。 量化：把抽样取得的电平幅值转为对应的数字值。 编码：把量化的结果转为对应的二进制码。 2.1.4 电路交换、报文交换与分组交换 名称 实现 优点 缺点 电路交换 在数据交换前，两个结点之间必须建立一条专用的物理通信路径 通信时延小，实时性强，控制简单 建立连接时间长，线路独占导致使用效率低，灵活性差 报文交换 报文携带目标地址、源地址等信息，在交换节点采用存储转发 无需建立连接，动态分配线路，可以多目标服务 由于需要存储转发，所以会有时延；报文大小没有限制，需要较大的缓存空间 分组交换 同上，但是限制了每次传送的数据块大小的上限，把大的数据块划分为小的数据块，并加上了一些必要的控制信息 同上，同时减少了出错几率和重发数据量 存在传输时延、存在额外信息量，可能失序、丢失或重复分组 如果传送的数据量很大，且传送时间远大于呼叫时间，则电路交换更合适。 分组交换时延比报文交换小，更适合计算机之间的突发式数据通信。 真题 2013-35 主机甲通过1个路由器（存储转发方式）与主机乙互联，两段链路的数据传输速率均为10Mbps，主机甲分别采用报文交换和分组大小为10kb的分组交换向主机乙发送1个大小为8Mb（1M=10^6kb）的报文。若忽略链路传播延迟、分组头开销和分组拆装时间，则两种方式完成该报文传输的总时间分别为（） A. 800ms、1600ms B. 801ms、1600ms C. 1600ms、800ms D. 1600ms、801ms 解析：不进行分组的时候，发送一个报文的时延是8Mb/10Mb/s=800ms，采用报文交换时，主机甲发送报文需要一次时延，而报文到达路由器进行存储转发又需要一次时延，总时延为800ms*2=1600ms。 进行分组后，发送一个报文的时延是10kb/10Mb/s=1ms，一共有8Mb/10kb=800个分组，主机甲发送800个分组需要1ms*800=800ms的时延，而路由器接收到第一个分组后直接开始转发，即除了第一个分组，其余分组经过路由器转发不会产生额外的时延，总时延就为800ms+1ms=801ms 2.1.5 数据报与虚电路 数据报和虚电路式分组交换的两种方式，都由网络层提供 数据报：高层协议将报文拆成若干个数据单元，中间结点会存储分组一段时间并寻找最佳路由，尽快转发分组。不同的分组可以走不同的路径，按照不同的顺序到达终点。 虚电路：试图结合数据报与电路交换，要求在分组发送前在发送方和接收方之间建立一条逻辑上的虚电路。路由选择体现在连接建立阶段，连接建立后传输路径就确定了。注意电路并不是专用的，而且如果网络的某个结点或某条链路出现故障而失效的时候，所有经过的虚电路都会被破坏。 错题 并行传输：距离短、速度快；串行传输：距离长、速度慢。因此计算机内部应该使用并行传输。 把语音信号数字化的技术是脉冲编码调制 以太网采用曼彻斯特编码，一个二进制码元要用两个电平来表示，因此波特率是比特率的两倍。 波特率=比特率/每码元含比特数，有效离散值的个数=2^每码元含比特个数 香农定律和奈奎斯特定律可以算出两个不一样的值，取最小的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:2:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2 传输介质 2.2.1 双绞线、同轴电缆、光纤与无线传输介质 双绞线：由两根采用一定规则并排绞合的、相互绝缘的铜导线组成（绞合的目的是减少干扰）。价格便宜、常用于局域网和传统电话网。双绞线的带宽取决于铜线的粗细和传输的距离，可用于模拟信号与数字信号。（模拟信号要使用放大器放大衰减的信号，数字传输要用中继器将失真的信号整形） 同轴电缆：由导体铜质芯线、绝缘层、网状编织屏蔽层和塑料外层组成，基带同轴电缆用于局域网，宽带同轴电缆用于有线电视系统。具有良好的抗干扰能力。 光纤：利用光导纤维传递光脉冲来进行通信，带宽范围极大。多模光纤允许不同角度入射的光线在一条光纤中传输，只适合近距离传输；单模光纤适合远距离传输。 无线传输介质：无线电波、微波、红外线和激光 2.2.2 物理层接口的特性 物理层应该尽可能屏蔽各种物理设备的差异，主要任务是确定与传输媒体的接口有关的一些特性，如： 机械特性：物理连接的边界点 电气特性：规定传输二进制位时，线路上信号的电压高低、阻抗匹配、传输速率和距离限制等。 功能特性，指明某条线上出现某一电平的电压代表何种；意义。 规程特性，或过程特性，定义各条物理线路的工作过程和时序关系。 常用的物理层接口标准：EIA RS-232-C、ADSL、SONET/SDH 错题 同轴电缆的屏蔽层主要是为了减少电磁干扰辐射。 传统以太网的主机通信方式为半双工。 同轴电缆比双绞线的传输速度快，因为它的抗干扰能力更强（有屏蔽层），同时具有更好的抗噪声性。 光纤不是中空的。 如果光纤的直径减小到只有一个光的波长大小，则光沿直线传播。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:2:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3 物理层设备 2.3.1 中继器 中继器又称为转发器 主要功能：将信号整形并放大再转发出去，以消除信号由于噪声或其他原因而造成的失真和衰减，使信号的波形和强度达到所需要的要求，来扩大网络传输的距离。 原理是信号再生，而不是简单的将衰减信号放大。 中继器仅作用于信号的电气部分，而不管数据是否出错。它是局域网环境下用来扩大网络规模的廉价互联设备，一般连接相同的媒体，但是也可以完成不同媒体的转接工作。 中继器在物理层工作，不能连接两个具有不同速率的局域网，中继器两端的网络部分是网段而非子网。 5-4-3规则：互相串联的中继器的个数不能超过4个，而且用4个中继器串联的5段通信介质中只有3个段可以挂接计算机，其他两个段只能用来做扩展通信范围的链路段。 PS：物理设备如果具有存储转发功能，就认为它可以连接两个不同的协议。而中继器没有存储转发功能，所以不能连接两个速率不同的网段。中继器两端的网段一定要是同一个协议。 2.3.2 集线器 集线器hub实质上是一个多端口的中继器，当一个端口收到数据信号后，集线器将其整形放大，转发到其他所有处于工作状态的端口上。如果同时有两个或以上的输入，就会造成输出冲突，致使数据无效。 主要用于使用双绞线组建共享网络，是解决从服务器连接到桌面最经济的方案。hub只能在半双工下工作。 集线器不能划分冲突域，如果一个带宽为10Mb/s的集线器连接了8台计算机，当这8台计算机同时工作的时候，每台计算机真正所拥有的带宽为10/8Mb/s=1.25Mb/s 错题 集线器在物理层上扩大了物理网络的覆盖范围，无法解决冲突域（第二层交换机可解决）与广播域（第三层交换机可解决）的问题，因此不同网段在同一广播域和同一冲突域下。 基带传输：在计算机内部或者在相邻设备之间近距离传输时，可以不经过调制就在信道上直接进行的传输方式称为基带传输，通常用于局域网。 频带传输：用数字信号对特定频率的载波进行调制，将其变成适合于传送的信号后再进行传输。远距离传输或者无线传输时数字信号必须用频带传输技术进行传输。 宽带传输：在频带传输过程中，可以将链路容量分解成两个或多个信道，每个信道可以携带不同的信号，这就是宽带传输。宽带传输中所有的信道可以同时互不干扰地发送信号。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:2:3","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第3章 数据链路层 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1 数据链路层的功能 数据链路层是在物理层提供服务的基础上向网络层提供服务，其主要作用是加强物理层传输原始比特流的功能，将物理层提供的可能出错的物理连接改造成逻辑上无差错的数据链路，使之对网络层表现为一条无差错的链路。 3.1.1 为网络层提供服务 提供给网络层的服务： 无确认的无连接服务：源机器发送数据帧时不需要先建立链路连接，目的机器收到数据帧时不需要发回确认。对丢失的帧，数据链路层不负责重发而交给上层处理。一般用于实时通信或误码率较低的通信信道，比如以太网。 有确认的无连接服务：源机器发送数据帧时不需要先建立链路连接，目的机器收到数据帧时发回确认。数据链路层需要重传丢失的帧以提高传输的可靠性。一般用于误码率较高的通信信道，比如无线传输。 有确认的面向连接服务。帧传输过程分为三个阶段：建立数据链路、传输帧、释放数据链路。目的机器对于收到的每一帧都要给出确认，源机器确认后才能发送下一帧。可靠性最高。 PS：不存在无确认的面向连接的服务。 3.1.2 链路管理 数据链路层连接的建立、维持和释放过程就成为链路管理，主要用于面向连接的服务。 3.1.3 帧定界、帧同步与透明传输 帧定界：因为数据帧的首部和尾部具有很多的控制信息，很重要的一点就是确定帧的界限。 帧同步：接收方应当从接受到的二进制比特流中区分出帧的起始与终止。比如在HDLC中使用F(01111110)来标志帧的开始和结束。 透明传输：不管所传数据是什么样的比特组合，都应当能在链路上传输（比如出现了与帧定界符相同的比特组合） 3.1.4 流量控制 发送方发送数据的能力强于接收方接收数据的能力时出现的淹没现象。 数据链路层的流量控制控制的是相邻两节点之间数据链路上的流量。 3.1.5 差错控制 错误分为位错和帧错。 位错指某些位出现错误，一般使用CRC来发现位错，通过自动重传请求ARQ方式来重传出错的帧。ARQ法仅返回很少的控制信息便可有效地确认所发送数据帧是否被正确接收。 帧错是指帧的丢失、重复或失序等错误。在数据链路层引入定时器和编号机制可以保证每一帧最终都能有且仅有一次正确地交付给目的结点。 错题 数据链路层协议的功能不包括为终端结点隐蔽物理传输的细节。 对于实时通信而言，迟到的数据比数据损坏更加不好，因此应当使用无确认的无连接服务而不是有确认的无连接服务。 流量控制实质上是对发送方的数据流量的控制。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2 组帧 发送方必须依据一定的规则把网络层递交的分组封装成帧（组帧）。组帧既要加首部，也要加尾部。分组不需要加尾部进行定界。 3.2.1 字符计数法 在帧的头部使用一个计数字段来表明帧内字符数，目的结点可以通过字节计数值得知后面跟随的字节数，从而确定帧结束的位置。（计数字段提供的字节数包含自身所占用的一个字节） 问题：计数字段出错时，就失去了帧边界划分的依据，接收方就无从判断帧定界，造成灾难性后果。 3.2.2 字符填充的首尾定界法 使用一些特定的字符来定界一帧的开始(DLE STX)与结束(DLE ETX)。为了使信息位中出现的特殊字符不被误判位定界符，需要给特殊字符前填充转义字符。 3.2.3 比特填充的首尾标志法 比特填充法允许数据帧包含任意个数的比特，也允许每个字符的编码包含任意个数的比特。使用定界符01111110来判定开始和结束。 为了防止数据流中的比特流被误判位帧的首位标志，发送方的数据链路层在信息位中遇到5个连续的1时会自动加上1个0；接收方做该过程的逆操作，每收到5个连续的1，则自动删除后面的0，以恢复原信息。 可以硬件实现，性能优于前者。 3.2.4 违规编码法 在物理层比特编码时通常采用违规编码法，比如曼彻斯特编码的高-高和低-低就是违规编码，用这些编码来判定界帧的起始和终止。 不需要任何填充技术，便能实现数据传输的透明性，但它只适用于采用冗余编码的特殊编码环境。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.3 差错控制 噪声有两类： 信道固有的、持续存在的随机热噪声。可以通过提高信噪比来减少或降低干扰。 外界特定的短暂原因所造成的冲击噪声。不可能靠提高信号强度来避免干扰造成的差错，是产生差错的重要原因。 通常利用编码技术进行差错控制，主要有两类，自动重传ARQ，和前向纠错FEC。 在ARQ中，接收端检测出差错时，就设法通知发送端重发，直到接收到正确地码字为止。在FEC中，接收端不但能发现差错，还可以确定二进制数码的错误位置，从而进行纠正。 3.3.1 检错编码 参考计算机组成原理，这里不赘述 奇偶校验码、循环冗余码CRC等 3.3.2 纠错编码 同样参考计算机组成原理 海明码 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:3","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.4 流量控制与可靠传输机制 需要练习 3.4.1 流量控制、可靠传输与滑动窗口机制 流量控制：涉及对链路上帧的发送速率的控制，以使接收方有足够的缓冲空间来接收每一个帧。基本方法是由接收方控制发送方发送数据的速率。 停止-等待流量控制基本原理 发送方每发送一帧都需要等待接收方的应答信号，之后才能发送下一帧。 接收方每接收一帧，都需要反馈一个应答信号，表示可以接收下一帧，如果接收方不反馈信号，则发送方必须一直等待。 因为每次只允许发送一帧，因此效率很低。 滑动窗口流量控制基本原理 在任意时刻，发送方都维持一组连续的允许发送的帧的序号，称为发送窗口；接收方维护一组连续的允许接收的帧的序号，称为接收窗口。使用发送窗口来对发送方进行流量控制，发送窗口的大小Wt代表在还没有收到对方确认消息的情况下发送方最多还可以发送多少个数据帧。同理，接收方只有在收到的数据帧的序号落入接收窗口内才允许将该数据帧收下。 在发送端，每收到一个确认帧，发送窗口就向前滑动一个帧的位置，当发送窗口内没有可以发送的帧（全部都是发送且未确认），发送方就会停止发送。 在接收端，当收到数据帧后，窗口向前移动一个位置，并发送确认帧，若收到的数据帧落在接收窗口之外一律丢弃。 特性： 只有接收窗口向前滑动后，发送窗口才会向前滑动。 从滑动窗口的概念看，停止-等待协议、后退N帧协议和选择重传协议只在发送窗口大小和接收窗口大小上有区别。 停止等待协议：发送窗口大小=1，接收窗口大小=1 后退N帧协议：发送窗口大小\u003e1，接收窗口大小=1 选择重传协议：发送窗口大小\u003e1，接收窗口大小\u003e1 当接收窗口大小为1时，可以保证帧的有序接收。 数据链路层的滑动窗口协议中，窗口的大小在传输过程中是固定的。（注意与传输层区别开） 可靠传输协议：通常使用确认和超时重传两种机制。 确认：一种无数据的控制帧，使得接收方可以让发送方知道哪些内容被正确接收。 超时重传：发送方在发送某一个数据帧以后就开启一个计时器，在一定时间内如果没有得到发送的数据帧的确认帧，那么就重新发送该数据帧，直到发送成功为止。 自动重传请求ARQ，通过接收方请求发送方重传出错的帧来恢复出错的帧。传统的自动请求方式分为三种：停等式ARQ、后退N帧式ARQ以及选择重传ARQ。 3.4.2 单帧滑动窗口与停止-等待协议 错误可能： 数据帧丢失 到达目的地时帧已经遭到破坏 数据帧正确而确认帧被破坏，发送方收不到确认帧，会重传已经被接收的数据帧。 算法实现 发送结点： 从主机取一个数据帧，送交发送缓存。 V(s)=0，发送状态变量V(s)初始化 N(s)=V(s)，将发送状态变量值写入数据帧中的发送序号N(s)中。 将发送缓存中的数据发送出去。 设置超时计时器，选择适当的重传时间。 等待7或8事件 收到确认帧ACKn，若n=1-V(s)，则已经发送的数据帧被接收方确认，此时从主机取一个新的发送帧，放入发送缓存。更新发送缓存，转至下一序号（V(s)=1-V(s)）。否则，丢弃这个帧，转至6 若超时计时器时间到，转至4 接收结点： V(r) = 0，接收状态变量初始化，其数值等于欲接收的数据帧的发送序号。 等待。 收到一个数据帧，就检查有无产生传输差错（比如CRC）。若检查结果错误，丢弃，转2；否则执行后续算法。 若N(s)=V(r)，则执行后续算法，否则丢弃并转到7(丢弃的帧是重复帧) 将收到的数据帧的数据交给主机 V(r)=1-v(r)，更新接收状态变量，准备接收下一个数据帧。 发送确认帧ACKn，n=V(r)，表明期望收到V(r)。转到2 为了超时重发和判定重复帧的需要，发送方和接收方都需要设置一个帧缓冲区，这样发送方才能在出差错的时候进行重传。只有在收到确认帧后才可以清楚副本。 3.4.3 多帧滑动窗口与后退N帧协议 发送方不需要在收到上一个帧的ACK之后才能开始发送下一帧，而是可以连续发送帧。 接收方在检测到失序的信息帧后，要求发送方重发最后一个正确接受的信息帧之后所有未被确认的帧。或者发送方在发送了N帧之后，发现N个帧的前一帧在计时器超时后仍未返回其确认信息，则该帧被判为出错或丢失，发送方将重传该帧以及之后的N个帧。 换而言之，接收方只能按顺序接收帧。 如果采用n bit对帧进行编号，如果发送窗口的尺寸小于2^n-1，则会造成接收方无法分辨新帧和旧帧。 PS：如果信道的传输质量很差导致误码率较大的时候，后退N帧协议不一定优于停止-等待协议。 3.4.4 多帧滑动窗口与选择重传协议 设法只重传出差错的数据帧或者计时器超时的数据帧。每一个发送缓冲区对应一个计时器，计时器超时的时候发送方就会重传该帧。 捎带确认：只有当自己有数据要发送时才将对之前正确收到的帧进行确认的方式。 因此，对某一帧的确认表明该数据帧和这以前所有的数据帧均已正确无误地收到了。 接收端只按序接收数据帧。此外，接收方一旦怀疑帧出错，就会发送一个NAK给发送方，要求发送方对NAK中指定的帧进行重传。 同样使用n bit对帧进行编号，需要满足接收窗口+发送窗口\u003c=2^n。显然接收窗口不能超过发送窗口，当接收窗口为最大值时，两者相等，为2^(n-1) 通信原理基础 信道的效率，也称为信道利用率。从时间角度定义，信道效率对发送方而言，是指发送方在一个发送周期的时间内，有效地发送数据所需要的时间占整个发送周期的比率。 信道吞吐率=信道利用率*发送方的发送速率 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:4","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.5 介质访问控制 主要任务：为使用介质的每个结点隔离来自同一信道其他结点所传送的信号，以协调活动结点的传输。即决定广播信道中信道分配的协议。 介质访问控制 medium access control, MAC 3.5.1 信道划分介质访问控制 使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。 多路复用技术：传输介质的带宽超过了传输单个信号所需的带宽时，在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率。即将多个输入通道的信息整合到一个复用通道，然后在接收端把收到的信息分离出来传送到对应的输出通道中。 信道划分的实质是通过分时、分频、分码等方法，把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道。 频分多路复用FDM：将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号的多路复用技术。即将物理信道的总带宽分割成若干格传输单个信号带宽相同（略宽）的子信道 时分多路复用TDM：将一条物理信道按时间分成若干个时间片，轮流地分配给多个信号使用。每一个时间片复用的一个信号占用。利用每个信号在时间上的交叉，在一条物理信道上传输多个信号。改进：STDM，统计时分多路复用，可以动态地分配时隙，提高线路的利用率。 波分多路复用WDM：光的频分多路复用，在一根光纤中传输多种不同波长的光信号，最后用波长分解复用器将各路波长分解出来。 码分多路复用CDM：靠不同的编码来区分各路原始信号，既共享信道的频率、又共享时间。码分多址CDMA是码分复用的一种方式。（要求各个站点的芯片序列是相互正交的）优点：抗干扰能力强、保密性强、语音质量好，主要用于无线通信特别是移动通信领域。 3.5.2 随机访问介质访问控制 随机访问协议中，如果有两个或多个用户同时发送信息，就会造成冲突，产生帧的碰撞，导致所有冲突用户的发送均以失败告终。 算法思想：胜利者通过争用获得信道，从而获得信息的发送权。又称为争用型协议，实质上是将广播信道转化为点对点通信的行为。 纯ALOHA协议：任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果一段时间内没有收到确认，该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。（等待的时间随机）缺点是吞吐量很低。 时隙ALOHA协议：在时间上把所有站点同步起来，并将时间划分为一段段等长的时隙，规定只能够在每个时隙开始的时候才能发送一个帧，以避免用户发送数据的随意性。这样，每个帧正好在一个时隙内发送完毕，碰撞重传的机制是一样的。吞吐量S与网络负载G的关系是S=Ge^(-G)，当G=1时S=0.368，达到最大值。 1-坚持CSMA协议：当一个结点要发送数据时，首先侦听信道，如果信道空闲立即发送数据；如果信道忙则等待，同时继续侦听直至信道空闲。如果发生冲突，则随机等待一段时间，再重新侦听信道。（1的意思是侦听到信道空闲后，发送帧的概率为1）。受传播延迟的影响较大 非坚持CSMA：当一个结点要发送数据时，首先侦听信道；如果信道空闲就立即发送数据；如果信道忙就放弃侦听，等待一个随机的时间后再重复上述过程。降低了冲突的概率，但是使得数据在网络中的平均延迟增加了。 p-坚持CSMA：用于时分信道，基本思想是当一个结点要发送数据时，首先侦听信道，如果信道忙，则等待下一个时隙再侦听；如果信道空闲，便以概率p发送数据，依次类推。这个过程一直持续到数据发送成功或者其他结点发送数据而检测到信道忙为止。若是后者，则等待一个随机时间后再重新开始侦听。 CSMA/CD协议，载波侦听多路访问/碰撞检测，是CSMA的改进方案（特点是边听边发，CSMA的侦听和发送不是同时的），适用于总线型网络或半双工网络环境。即每一个站在发送数据之前先检测一下总线上是否有其他站点在发送数据。如果有，则暂时不要发送数据，要等待信道变为空闲再发送。碰撞检测就是边发送边侦听。概括为先听后发，边听边发，冲突停发，随机重发。 显然，CSMA/CD不可能进行全双工通信，只能进行半双工通信。 争用期：把以太网端到端往返时间称为争用期，又称为冲突窗口或碰撞窗口。每一个站在自己发送数据之后的一小段时间内，存在着遭遇冲突的可能性，只有经过争用期这段时间还没有检测到冲突，才能确定这次发送不会发生冲突。 为了确保发送站在发送数据的同时能检测到可能存在的冲突，需要在发送完帧之前就能收到自己发送出去的数据，也就是说帧的传输时延至少要两倍于信号在总线中的传播时延。CSMA/CD总线网的所有数据帧必须要大于一个最小帧长，最小帧长=总线传播时延*数据传输速率*2 比如对于以太网，规定51.2微秒的争用期，则对于10Mb/s的以太网，争用期内可发送512bit，如果前64B未发送冲突，则后面也不会发生冲突。因此规定最短帧长为64B。 CSMA/CD的重点在于二进制指数退避算法，以此来从冲突中恢复。 确定基本退避时间，一般取两倍的总线端到端传播时延。（即争用期） 定义参数k=重传次数，且不超过10 从离散整数集合{0,1,2,…,2^k-1}中选择一个数，重传所需要的退避时间就是r倍的基本退避时间。（全取） 重传达16次仍不能成功，说明网络太拥挤，抛弃此帧并向高层报告出错。 CSMA/CA协议。CSMA/CD成功用于有线连接的局域网，而CSMA/CA则是在无线局域网环境运行的。CA即为碰撞避免。碰撞避免的实现： 二进制指数退避算法 预约信道。发送方在发送数据的同时通知其他站点自己传输数据所需要的长度。 ACK帧，站点在正确收到发给自己的数据帧后，都需要发回一个ACK帧 RTS/CTS帧，可选的碰撞避免机制，主要用于解决无线网中的隐蔽站问题。 与CSMA/CD的区别： 吞吐量计算 网络负载（T0时间内所有站点发送的成功和未成功而重传的帧数）G 网络吞吐量（T0时间内成功发送的平均帧数）S 算法名称 计算公式 ALOHA S=Ge^(-2G) 时隙ALOHA S=Ge^(-G) 3.5.3 轮询访问介质访问控制：令牌传递协议 用户不能随机地发送信息，而是通过一个集中控制的监控站，以循环的方式轮询每一个结点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道。 令牌传递协议：一个令牌再各结点之间以某个固定次序交换，令牌是一组特殊的比特组合而成的帧。环上的一个站希望传送帧时，必须等待令牌，一旦收到令牌，站点便可启动发送帧。帧在环上发送的时候，所有站点一律进行转发，直到到达始发站，并由始发站撤销该帧。 物理拓扑不必成环，但是为了把对访问介质的许可从一个设备传递到另一个设备，令牌在设备间的传递通路在逻辑上必须是一个环。 非常适合负载很高的广播信道 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:5","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.6 局域网 局域网的介质访问控制方法：CSMA/CD、令牌总线和令牌环。前两种主要用于总线型局域网，后一种主要用于环形局域网。 下表属于常识 数字表示数据传输率，10为10Mbps，第二部分的base表示基带传输；第三部分的字母表示传输介质，T表示双绞线，F表示光纤；数字则表示所支持的最大传输距离，2表示200m,5表示500m 10Base-T在拓扑关系上是星形的，但是在逻辑上仍然是总线型，各机器在同一冲突域内。 MAC地址为全球唯一的，用6个十六进制数表示，高24位为厂商代码，低24位为厂商自行分配的网卡序列号。 以太网与IEEE802.3 以太网采用两项措施简化通信： 采用无连接的工作方式 不对发送的数据帧编号，也不要求接收方发送确认。 即以太网尽最大努力交付数据，提供的是不可靠服务，对于差错的纠正则由高层完成。 以太网的MAC帧格式有两种标准：DIX Ethernet V2标准和IEEE 802.3标准，前7个字节为前同步码，然后是一个字节的帧开始定界符，后面的信息就是MAC帧。MAC帧并不需要帧结束符，因为以太网在传送帧的时候各帧之间必须存在一定的间隙。但是以太网MAC帧需要尾部，在数据链路层，帧既要加首部，也需要尾部。 数据部分为46-1500字节。MAC帧的首部和尾部的长度为18字节，以太网帧最小需要64B，所以最少也要有46B的数据。 高速以太网： 100BASE-T，双绞线上传送100Mb/s基带信号的星形拓扑结构的以太网，使用CSMA/CD。可以全双工（不用CSMA/CD） 千兆以太网，1Gb/s，与上面兼容。 10吉比特以太网，只使用光纤，只在全双工下使用，不使用CSMA/CD。 3.6.3 IEEE 802.11 无线网络系列标准，MAC层采用CSMA/CA 802.11规定无线局域网的最小构件是基本服务集(Basic Service Set,BSS) 令牌环网 简述：网络中有一个令牌在传输。空闲的时候网络中只有令牌在传输。如果传到有数据要发送的站点，令牌会被修改一个标志位，并带上数据成为数据帧。 在继续传递的过程中，如果计算机检测到令牌的目的地址与自己相同，会复制令牌。 传递完毕后，源计算机会重新产生一个令牌，并将令牌传递给下一个站点，以交出对媒体的控制权限。 令牌环网在物理上采用星形拓扑结构，但是逻辑上却是环形结构。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:6","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.7 广域网 广域网由一些结点交换机（不是路由器，结点交换机在单个网络中转发分组，路由器在多个网络构成的互联网中转发分组）以及连接这些交换机的链路组成。 3.7.2 PPP协议 PPP：Point-to-Point Protocol PPP是使用串行线路通信的面向字节的协议，该协议应用在直接连接两个结点的链路之上，设计目的主要是用来通过拨号或专线方式建立点对点连接发送数据，使其称为各种主机、网桥和路由器之间简单连接的一种共同的解决方案。 PPP在SLIP的基础上发展而来，它既可以在异步线路上传输，也可以在同步线路上使用。 三个组成部分： 链路控制协议LCP：一种扩展链路控制协议，用于建立、配置、测试和管理数据链路 网络控制协议NCP：PPP允许同时采用多种网络层协议，每个不同的网络层协议要用一个相应的NCP来配置，为网络层协议建立和配置逻辑连接。 一个将IP数据报封装到串行链路的方法。IP数据报在PPP帧中就是其信息部分，这个信息部分的长度受最大传送单元MTU的限制。 信息部分同样不超过1500B，但是最低可以是0字节。当数据部分出现和标志部分一样的比特组合时，需要采取一些措施来实现透明传输。 首部5字节，尾部3字节，合计8字节 注意： PPP提供差错检测但不提供纠错功能，只保证无差错接收。它是不可靠的传输协议，因此也不使用序号和确认机制。 仅支持点对点的链路通信，不支持多点链路 PPP仅支持全双工链路 两端可以运行不同的网络层协议 PPP是面向字节的。当信息字段出现和标志字段一致的比特组合时，PPP有两种处理方法，如果PPP在异步线路（默认），采用字节填充法了；如果PPP在SONET/SDH等同步线路，采用硬件来完成比特填充（与HDLC做法一样） 3.7.3 HDLC协议 高级数据链路控制(High-level Data Link Control, HDLC)是ISO指定的面向比特的数据链路层协议，不依赖于任何一种字符编码集 PS：一定要与PPP面向字节向区分。 全双工 所有帧采用CRC校验 对信息帧进行顺序编号，提供了编号和确认机制，能够提供可靠传输 可适用于两种基本的配置：非平衡配置和平衡配置 非平衡配置的特点是由一个主站控制整个链路的工作 平衡配置的特点是链路两端的两个站都是复合站，每个复合站可以平等地发起数据传输，而不需要得到对方复合站的允许。 主站：负责控制链路的操作，发出的帧叫做命令帧 从站：按主站的命令进行操作，发出的帧称为响应帧 复合站：具有主站和从站两者的功能 数据操作方式： 正常响应方式：非平衡结构操作方式，即主站向从站传输数据，从站进行响应传输。从站只有收到主站的许可后，才可进行响应 异步平衡方式：平衡结构操作方式，每一个复合站都可以进行对另一站的数据传输 异步响应方式：非平衡结构操作方式，从站在没有接到主站的允许下就可以进行传输。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:7","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.8 数据链路层设备 3.8.1 网桥的概念与基本原理 网桥可以连接两个或多个以太网，网桥工作在链路层的MAC子层，可以使以太网的各网段成为隔离开的碰撞域。网桥处理数据的对象是帧，所以它是工作在数据链路层的设备。 不同碰撞域内的最大吞吐量可以相加，如果是同一个碰撞域，同一时刻内只能一组计算机进行通信，最大吞吐量只能取最大值。 网桥必须具有路径选择的功能。根据路径选择算法的不同： 透明网桥（选择的不是最佳路由）：以混杂方式工作，接收与之连接的所有LAN传送的每一帧。如果源LAN和目的LAN相同，丢弃。不同，则转发。未知，则扩散。网桥按照自学习算法处理收到的帧。 自学习算法的基本思想：若从站A发出的帧从某端口进入网桥，那么从这个端口出发沿相反方向一定可以把一个帧传送到站A。 为了避免转发的帧兜圈子，使用了一种生成树算法，以确保每个源到每个目的地只有唯一的路径。工作上没有环路，但是生成树一般不是最佳路由。 源路由网桥（选择的是最佳路由）：路由选择由发送数据帧的源站负责，网桥只根据路由信息对帧进行接收和转发。 源路由网桥对主机是不透明的，主机必须知道网桥的标识以及连接到哪个网段上。 为了寻找最佳路由，源站以广播的方式向目的站发送一个发现帧作为探测 源路由的生成过程：在未知路径前，源站要先发送一个发现帧；途中的每个网桥都转发此帧，最终发现该帧可能从多个途径到达目的站；目的站也将一一发送应答帧，每个应答帧将通过原路径返回，途径的网桥把自己的标志记录在应答帧中；源站选择出一个最佳的路由 从此，从这个源站向该目的地发送的帧的首部，都必须携带这一路由信息。 这里的最佳路由并不是经过路由器最少的路由，也可以是发送帧往返时间最短的路由。 3.8.2 局域网交换机及其工作原理 桥接器的主要限制是任一时刻只能执行一个帧的转发操作，于是出现了交换机。以太网交换机本质上是多端口的网桥，能经济地讲网络分成小的冲突域，为每个工作站提供更高的带宽。 利用交换机还可以很方便地实现VLAN，VLAN不仅可以隔离冲突域，还可以隔离广播域。 原理：检测从以太网端口来的数据帧的源和目的地的MAC地址，然后与系统内部的动态查找表进行比较，若数据帧的MAC地址不在查找表中，则将该地址加入查找表中，并将数据帧发送给相应的目的端口。 交换模式： 直通式交换机，只检查帧的目的地址，在接收后马上就被传出去。速度很快，缺乏智能性和安全性，也无法支持具有不同速率的端口的交换。 存储转发式交换机先将接收到的帧缓存到高速缓存器中，并检查数据是否正确，确认无误后通过查找表转换成输出端口将该帧发送出去。优点是可靠性高，支持不同速度端口间的转换，缺点是延迟较大。 关于物理层、数据链路层、网络层设备对于隔离冲突域和广播域的总结 网桥与交换机的不同之处： 网桥的端口一般连接局域网，而交换机的端口一般直接与局域网的主机相连 交换机允许多对计算机同时通信，而网桥仅允许每个网段上的计算机同时通信 网桥采用存储转发进行转发，而以太网交换机还可以采用直通方式进行煮饭啊，且以太网交换机采用了换用的交换结构芯片，转发速度比网桥快。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:3:8","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第4章 网络层 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1 网络层的功能 4.1.1 异构网络互联 网络的互联指的是将两个以上的计算机网络，通过一定的方法，用一种或多种通信处理设备相互联接起来，以构成更大的网络系统。 四种不同的中继系统： 物理层中继系统：中继器、集线器 数据链路层中继系统：网桥或交换机 网络层中继系统：路由器 网络层或以上的中继系统：网关 TCP/IP体系在网络互联上采用的做法是在网络层(IP层)采用了标准化协议，但是相互联接的网络可以是异构的。因为都使用了相同的网络协议IP，因此可以把互联以后的计算机网络看作是一个虚拟互联网络。 优点：互联网上的主机在通信的时候，就好像在一个网络上通信一样，而看不见互联的具体的网络异构细节（如具体的编制方案、路由选择协议等） ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1.2 路由与转发 路由器的两个功能： 路由选择（确定那一条路径）：按照复杂的分布式算法，根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态地改变所选择的路由。 分组转发（当一个分组到达时所采取的行动）：路由器根据转发表将用户的IP数据报从合适的端口转发出去。 即路由选择算法得出路由表，路由表再得出转发表，而转发表的结构应当使得查找过程最优解。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1.3 拥塞控制 在通信子网中，由于过量的分组而引起的网络性能下降称为拥塞。 判断网络是否进入拥塞状态的方法：观察网络的吞吐量与网络负载的关系。 如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就可能进入“轻度拥塞”状态；如果网络的吞吐量随着网络负载的增大反而下降，网络就可能进入拥塞状态；如果网络的负载继续增大，而网络的吞吐量下降到零，网络就可能进入到死锁状态。 拥塞控制主要解决的问题：如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞出现分组的丢失以及严重拥塞而产生网络死锁的现象。目标是确保子网能够承受所达到的流量。 流量控制：发送端到接收端点对点通信量的控制，局部问题。 拥塞控制：确保通信子网能够传送待传送的数据，全局问题。 方法： 开环控制：静态预防方法，在设计网路的时候将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。控制手段：确定何时接收新流量、何时可丢弃分组以及哪些分组，确定何种调度决策等。共性：在做决定时不考虑当前网络的状态。 闭环控制：事先不考虑有关发生拥塞的各种因素，采用监控网络系统去监视，及时检测到哪里发生拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。动态的方法。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:3","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2 路由算法 4.2.1 静态路由与动态路由 静态路由算法，非自适应路由算法，指由网络管理员手工配置的路由信息。不适合大型和复杂的网络环境。 动态路由算法，自适应路由算法：指路由器上的路由表项是通过相互联接的路由器之间彼此交换信息，然后按照一定的算法优化得出来的。较为复杂，会增加网络的负担。 4.2.2 距离-向量路由算法 内容：所有的结点都定期将它们的整个路由选择表传送给所有与之直接相邻的结点。这种路由选择表包含：每条路径的目的地（另一节点）以及路径的代价（距离） 即所有结点都需要监听从其他结点传送来的路由选择更新信息，并在下列情况下更新它们的路由选择表： 被通告一条新的路由，该路由在本结点的路由表中不存在，此时本地系统加入这条新的路由。 发送来的路由信息中有一条到达某个目的地的路由，该路由比当前使用的路由有较小的代价。此时，就会用新路由替换掉原路由。 实质上就是迭代计算一条路由中的站段数或延迟时间，从而得到到达一个目标的最短通路。更新报文的大小与通信子网的结点个数成正比，因此通信子网上的路由选择信息很容易变得很大。 最常见的是RIP算法，采用跳数作为距离的度量。 4.2.3 链路状态算法 内容：要求每个参与该算法的结点都由完全的网络拓扑信息，执行以下任务： 主动测试所有邻接结点的状态。 定期将链路状态传播给其他所有的结点（而非相邻结点）。 这样子，每个结点都能得到整个网络的拓扑信息。然后每当链路状态报文到达时，路由结点便使用这些状态信息取更新自己的网络拓扑和状态视野图。一旦链路状态发生了变化，就是用更新了的网络图利用dijkstra最短路径算法重新计算路由，更新最短路径。 典型算法：OSPF算法 特征： 向本自治系统中的所有路由器发送信息，方式是泛洪法。 发送的信息是与路由器相邻的所有路由器的链路状态，但仅是路由器所知道的部分信息。 只有当链路状态发生变化时，路由器才向其他所有路由器发送此信息。 优点：每个路由节点独立地计算路径，而不依赖中间结点的计算。大小与网络中的路由结点数目无关系。 4.2.4 层次路由 为了减少路由表的表项和各种资源，使用层次路由，将整个互联网划分为多个较小的自治系统（一个自治系统里面包含很多局域网），每个自治系统有权自主地决定本系统内应采用何种路由选择协议 自治系统内部使用的路由选择协议，即内部网关协议IGP。协议有RIP和OSPF。 自治系统之间所使用的路由选择协议，即外部网关协议EGP，协议有BGP。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:4","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3 IPv4 4.3.1 IPv4分组 IP分组由首部+数据组成。首部定长20字节，自查，可以提供错误检测及安全等机制。 首部的部分重要字段： 首部长度：占4位，以32位为单位，最大值为60.最常用的首部长度为20字节，此时不使用任何可选字段 总长度：16位，指首部和数据之和的长度，单位为字节。IP数据报的最大长度为65536B，而以太网的最大传送单元MTU=1500B。因此当一个IP数据报封装成帧的时候，数据报的总长度一定不能超过下面的MTU 标识：占16位，是一个计数器，每产生一个数据报就加1.（IP是无连接服务，并不是序号） 标志：占3位，最低位MF，MF=1表示后面还有分片；MF=0表示最后一个分片。中间一位DF，只有当DF=0时才允许分片 片偏移：占13位，指出较长的分组在分片后，某片在原分组中的相对位置。片偏移以8B为偏移单位 首部检验和：占16位，只检验分组的首部 生存时间TTL：占8位，数据报在网络中可通过的路由器数的最大值。路由器在转发分组之前，先把TTL减1，若TTL=0，则该分组必须丢弃。比如对于只有一组路由器来说，TTL=1的时候，路由器在发出的时候TTL就会变为0，此时就该被丢弃而不是发出去。 协议：占8位，6表示TCP，17表示UDP 源地址字段：4B 目的地址字段：4B IP数据报分片 一个链路层数据报所能承载的最大数据量称为最大传送单元MTU。MTU限制IP数据报的长度，因此如果IP数据报长度大于链路MTU时，就需要分片在数据链路层进行传输。片会在目的地的网络层被重新组装。 当一个路由器需要分片时，形成的每个片都具有原始数据报的标识号。这样目的主机可以通过检查数据报的标识号来确定哪些数据报属于同一个原始数据报。 IP首部的标志位有3个比特，后两个bit分别时MF位和DF位。DF=0时IP数据报才可以被分片。MF用来告知目的主机该IP数据报是否为原始数据报的最后一个片，MF=1表示还有片，MF=0表示没有。 片偏移字段用来确定片应该被放在IP数据报的哪个位置。偏移量=首部字节数/8，比如第一个数据报的有效数据长度是1480B，下一个的片偏移字段为185 路由器的分组转发算法： 根据目的主机的IP地址计算目的网络地址。 如果网络与路由器直连，则直接交付，把数据报交给目的主机 如果没有直接交付，则查看路由表，交给路由表中指明目的主机的其他路由器 如果没有，交给路由表中指明目的网络的路由器 交给默认路由器 报告转发分组出错 注意：得到下一跳路由器的IP地址之后不是直接发送，而是将IP地址转为MAC地址（通过ARP）之后，将其放到MAC首部，根据这个MAC地址找到下一跳路由器。 PSS：在不同网络中传送时，MAC帧中的源地址和目的地址要发生变化，但是网桥在转发帧时，不改变帧的源地址。 4.3.2 IPv4地址与NAT IP地址=网络号+主机号，网络号在因特网范围内必须是唯一的。 五类IP地址 特殊地址，不能用作主机地址： 主机号全为0，表示网络本身 主机号全为1，表示本网络的广播地址。 127.0.0.0的网络保留作为环路自检地址，此地址表示任意主机自身。 32位全为0，表示本网络上的本主机 32位全为1，表示整个TCP/IP网络的广播地址，又称受限广播地址。实际使用时由于路由器对广播域的隔离，等效为本网络的广播地址。 A类地址：网络号字段为0与127字段不可指派，总共2^7-2 B类地址：网络号字段为128不可指派，共2^14-1 C类地址：网络号字段为192不可指派，2^21-1 NAT：网络地址转换，国通将专用网络地址转换为公用地址，从而对外隐藏内部管理的IP地址。 私有IP地址：A类1个10.0.0.0/8，B类16个172.16-172.31/16，C类256个192.168.0/24。 NAT路由器使用NAT转换表将本地地址转换为全球地址。内部存放着｛本地IP地址：端口｝到{全球IP地址：端口}的映射。 4.3.3 子网划分与子网掩码、CIDR 子网划分：在IP地址中增加一个子网号段，使两级IP化为三级IP。 子网掩码：子网掩码用来表达对原网络中主机号的借位，是与IP地址对应的二进制串，1代表IP地址中的网络号和子网号，0代表主机号。 无分类编址CIDR，在变长子网编码的基础上提出的一种消除传统ABC类网络划分的划分方法。 最长前缀匹配（最佳匹配）：使用CIDR时，路由表中的每个项目由网络前缀和下一跳地址组成，从匹配结果中选择具有最长网络前缀的路由。 需要注意：全0和全1的地址不能作为主机地址。（全0一般代指本机自己，全1一般用作子网的广播地址） 4.3.4 ARP协议、DHCP协议与ICMP协议 （重要，需要练习） IP地址时网络层地址，硬件地址是数据链路层地址。由于路由器的隔离，IP网络无法跨网络使用MAC地址来寻址，只能使用IP地址寻址。 地址解析协议ARP：ARP工作在网络层，可以完成IP地址到MAC地址的映射。实现是在每个主机设置一个ARP高速缓存，存放本局域网中各主机和路由器的IP地址到MAC地址的映射表，称为ARP表。 PS：NAT路由器由于看到了端口，所以它工作在传输层。 动态主机配置协议DHCP，用于给主机动态地分配IP地址，提供了即插即用联网的机制，允许一台计算机加入新的网络和获取IP地址而不用手工参与。DHCP是应用层协议，是基于UDP的。 原理： 需要IP地址的主机在启动时向DHCP服务器广播发送发现报文，这时主机称为DHCP客户。 DHCP在数据库中查找该主机的配置信息，如果找到，返回找到的信息；如果没有的话，从服务器的IP地址池汇总取一个地址分配给计算机。回答报文叫做提供报文。 过程： DHCP客户机广播“DHCP发现”消息，试图找到DHCP服务器。 DHCP服务器收到“DHCP发现”消息后，广播“DHCP提供”消息，提供DHCP客户机的IP地址和相关的配置信息。 DHCP客户机收到“DHCP提供”消息，如果接收DHCP服务器提供的相关参数，则通过广播“DHCP请求”消息向DHCP服务器请求提供IP地址 DHCP服务器广播“DHCP确认”消息，并将IP地址分配给DHCP客户机。 协议允许网络上配置多台DHCP服务器，客户机可能收到多个应答消息，但是只会挑选最先到达的。分配到的地址时临时的，在一段有限的时间内使用这个分配到的IP地址，这段时间称为租用期。 网际控制报文协议ICMP，允许主机或路由器报告差错和异常情况。是IP层协议（网络层）。ICMP报文作为IP层数据报的数据，加上数据报的首部，组成IP数据报进行发送。 ICMP报文包括ICMP差错报告报文和ICMP询问报文。 差错报告报文用于目标主机或目标主机路径上的路由器向源主机报告差错和异常情况，有以下五种类型： 终点不可达。 源点抑制。路由器或主机由于拥塞而丢弃数据报的时候，会向源点发送抑制报文，减慢数据报发送速率 时间超过 参数问题。收到的数据报首部中的字段有不正确的地方，会丢弃报文并发送参数问题报文。 改变路由（重定向）。路由器把改变路由报文发送给追，让主机知道下次应将数据报发送给另外的路由器。 PS：对ICMP差错报文不再发送ICMP差错报文。 ICMP询问报文的类型：回送请求和回答报文、时间戳请求和回答报文、掩码地址请求和回答报文、路由器询问和通告报文。 PS：ping工作在应用层，直接使用网络层的ICMp协议而没有使用传输层的TCP或UDP。而tracert工作在网络层。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:5","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.4 IPv6 省略 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:6","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.5 路由协议 （重要，需要练习） 4.5.1 自治系统 AS，自治系统：在单一的技术管理下的一组路由器，这些路由器使用一种AS内的路由选择协议以确定AS内的路由，同时还使用一种AS外的路由选择协议来确定AS间的路由。 一个自治系统内的所有网路都属于一个行政单位来管辖。 4.5.3 RIP路由协议 路由信息协议routing information protocol RIP，是内部网管协议，是一种分布式的基于距离向量的路由选择协议，最大的优点就是简单。 规定： 每个路由器维护自己到其他每一个目的网络的距离记录。这称为距离向量。 距离也成为跳数，规定一路由器到直接连接的网络距离为1，每经过一个路由器，距离加1. RIP优先选择跳数少的路径。 RIP允许一条路径最多包含15个路由器，因此距离等于16时表示网络不可达。 默认两个使用RIP协议的路由器每30s之间广播一次RIP路由更新信息，以便自动建立并维护路由表。 RIP中不支持子网掩码的RIP广播，即RIP中每个网络的子网掩码必须相同。 特点： 仅和相邻路由交换信息。 路由器交换的信息是当前本路由器所知道的全部信息，即自己的路由表。 按固定的时间间隔交换路由信息，如每隔30s。 距离向量算法： 每一个路由表项有三个关键数据：\u003c目的网络N，距离d，下一跳路由器X\u003e 对地址为X的相邻路由器发来的RIP报文，进行修改：把下一跳路由器地址改为X，并把距离全部加1. 对修改后的RIP报文中的每一条进行更新。如果没有目的网络N，插入；如果有目的网络N，且下一跳路由地址是X，替换；如果有目的网络N，且下一跳路由地址不是X，如果收到的项目中的距离d小于路由表中的距离，进行替换，不然什么都不做。 如果180s（默认超时时间）还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即设置距离为16. 返回 优点是简单、开销小，收敛速度快。 缺点是限制了网络规模，最多只能15跳；且由于路由器之间交换的是完整的路由表，网络规模越大开销越大；当网络出现故障时，会出现慢收敛现象（需要较长时间传播信息），即坏消息传的慢。 应用层协议，使用UDP传送数据。 4.5.4 OSPF路由协议 开放最短路径优先协议OSPF，分布式链路状态算法的代表。 特点： OSPF对不同的链路可以根据IP分组的不同类型设置成不同的代价，对于不同类型的业务计算出不同的路由，十分灵活。 如果同一网络有多条相同代价的路径，可以进行多路径的负载均衡。 所有在OSPF路由器之间交换的分组都具有鉴别功能，保证仅在可信赖路由器之间交换链路状态信息。 支持CIDR。 基本工作原理：所有路由器最终都能建立起一个全网的拓扑结构，每个路由器根据这个拓扑结构，根据dijkstra算法自行计算自己到目的地址的网络最优路径。为了使OSPF能够用于规模很大的网络，OSPF会将一个自治系统再划分为若干个更小的范围，使利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，减少了整个网络上的通信量。 OSPF的五种分组类型： 问候分组，用来发现和维持邻站的可达性。 数据库描述分组，向邻站给出自己的链路状态数据库汇总的所有链路状态项目的摘要信息。 链路状态请求分组，向对方请求发送某些链路状态项目的详细信息。 链路状态更新分组，用洪泛法对全网更新链路状态。 链路状态确认分组，对链路更新分组的确认。 运行： 通常每隔10s相邻两个路由器之间交换一次问候分组，以便知道哪些站可达。 在刚开始工作的时候，每一个路由器使用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息。 路由器使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息，建立全网同步的链路数据库。 在网络运行过程中，只要有一个路由器的链路状态发生变化，该路由器就要使用链路状态更新分组，用洪泛法向全网更新链路状态。其他路由器在更新后，发送链路状态确认分组对更新分组进行确认。 每隔一段时间（30分钟），刷新一次数据库中的链路状态，以此确保链路状态数据库与全网的状态保持一致。 OSPF直接使用IP数据报传送。 4.5.5 BGP路由协议 边界网关协议Border Gateway Protocol,BGP，是不同自治系统的路由器之间交换路由信息的协议，是一种外部网关协议。 BGP是应用层协议，是基于TCP的。采用的是路径向量路由选择协议。 工作原理：每一个自治系统的管理员选择至少一个路由器作为自治系统的”BGP发言人“，一个BGP发言人与其他自治系统中的BGP发言人通过建立TCP连接来交换路由信息，当所有BGP发言人都相互交换网络可达性信息后，各BGP发言人就可以找到各个自治系统中比较好的路由。 特点： BGP协议交换路由信息的结点的数量级是自治系统的数量级。 每一个AS中的BGP发言人是很少的。 BGP支持CIDR，因此BGP路由表需要包含目的网络前缀、下一跳路由器，以及到达该目的网络所要经过的各个自治系统序列。 BGP刚运行时，邻站需要交换整个BGP路由表，但以后只需要在发生变化时更新有变化的部分。 使用四种报文： 打开报文：与另一个相邻的BGP发言人建立关系 更新报文：用来发送某一路由的信息，以及列出要撤销的多条路由 保活报文：用来确认打开报文和周期性地证实邻站关系。 通知报文：用来发送检测到的差错。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:7","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.6 IP组播 组播的目的时将一个分组发给多个目的地主机。组播一定仅应用与UDP，因为TCP是面向连接的协议。 IP组播使用D类地址，主机使用IGMP（因特网组管理协议）的协议加入组播组，通信本地网络的路由器关于要接收发送给某个组播组的愿望，通过扩展路由器的路由选择和转发功能，来实现因特网组播。 组播指发送一组数据，数据在传送路径出现分叉时才进行复制后转发。 4.6.3 IGMP协议与组播路由算法 IGMP协议是让连接在本地局域网上的组播路由器知道本局域网上是否有主机参加或退出了某个组播组。 IGMP协议应当被视为TCP/IP协议的一部分，工作可分为两个阶段： 当某个主机加入新的组播组时，主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。本地的组播路由器收到IGMP报文后，将组成员关系转发给因特网上的其他路由器。 本地组播路由器周期性地探寻本地局域网上的主机，以便直到这些主机是否还继续是组的成员。只要对某个组有一个主机响应，就认为这个组是活跃的。否则，如果一个组几次探寻后仍然没有主机响应，就不再将该组的成员关系转发给其他组播路由器。 组播的路由选择实质上就是找到以源主机为根节点的组播转发树。 路由算法：一是基于链路状态的路由选择；第二种是基于距离-向量的路由选择；第三种则是可以建立在任何路由器协议之上，因此称作协议无关的组播。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:8","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.7 移动IP 支持移动性的因特网体系结果与协议被共同称为移动IP。移动IP技术是移动结点以固定IP实现跨越不同网段的漫游功能，并保证基于网络IP的网络权限在漫游过程中不发生任何改变。 基于IPv4的移动IP定义三种功能实体： 移动结点：具有永久IP地址的移动结点。 本地代理（归属代理）：网络环境中，移动结点的永久居所被称为归属网络，归属网络中代表移动结点执行移动管理功能的实体叫归属实体，它根据移动用户的转角地址，采用隧道技术转交移动结点的数据包。 外部代理：在外部网络中帮助移动结点完成移动管理功能的实体称为外部代理。 移动IP通信过程 移动结点在本地网， 有本地网固有的地址。 移动结点漫游到外地网络，仍然使用固定的IP地址进行通信。向本地代理注册当前的位置地址，这个位置地址就是转交地址（可以是外部代理的地址或是动态配置的一个地址） 本地代理接收来自转交地址的注册后，会构建一条通向转交地址的隧道，将截获的发给移动结点的IP分组通过隧道发给转交地址。 转交地址解除隧道封装，恢复原始IP分组，送到移动站点。 移动站点在外网通过外网的路由器或外代理向通信对端发送IP数据包。 移动结点来自另一个外网时，只需要向本地代理更新注册的转交地址就可以继续通信。 移动结点回到本地网时，向本地代理注销转交地址。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:9","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.8 网络层设备 4.8.1 路由器的组成和功能 路由器是一种具有输入输出端口的专用计算机，任务是连接不同的网络（连接异构网络）并完成路由转发，在多个逻辑网络（即多个广播域）互联时必须使用路由器。 从结构上看，路由器由路由选择和分组转发两部分构成。路由器是网络层设备，实现了下三层，即物理层、数据链路层和网络层。 如果一个存储转发设备实现了某个层次的功能，那么它就可以互联两个在该层次上使用不同协议的网段。 路由选择部分也叫控制部分，其核心构建是路由选择处理机，路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和其他相邻路由器交换路由信息而不断更新和维护路由表。 分组转发由三部分组成：交换结构、一组输入端口和一组输出端口。 路由器主要完成分组转发和路由计算两个功能。分组转发处理通过路由器的数据流，关键操作是转发表查询、转发以及相关队列管理和任务调度。路由计算通过和其他路由器进行基于路由协议的交互，完成路由表的计算。 4.8.2 路由表与路由转发 路由表根据路由选择算法得出，转发表根据路由表得出 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:4:10","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第5章 传输层 多路复用：multiplexing，在源主机不同套接字收集数据块，每个都装上首部信息，生成报文段，然后将报文段传递到网络 多路分解：demultiplexing，将传输层报文段中的数据交付到正确（通过首部信息）的套接字 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:5:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.1 传输层提供的服务 5.1.1 传输层的功能 功能： 传输层提供应用进程之间的逻辑通信（即端对端通信）。与网络层的区别是网络层提供的是主机之间的逻辑通信。 复用和分用。复用指发送方不同的应用进程都可以使用同一个传输层协议传输数据；分用指接收方的传输层在剥去报文的首部后能够将这些数据正确交付到目的应用进程中。 传输层要对收到的保温进行差错检测，而网络层只检查IP数据报的首部而不检查数据部分。 提供了面向连接的TCP和无连接的UDP协议。 为什么说是逻辑信道：传输层向高级用户屏蔽了底层网络核心的细节（网络拓扑、路由协议），使应用进程看到的好像两个传输层实体之间存在一条端对端的逻辑通信信道，但是物理上并不存在这样的信道。 5.1.2 传输层的寻址与端口 端口的作用：端口能够让应用层的各种应用进程将其数据通过端口向下交付给传输层，以及让传输层知道应该将其报文段中的数据向上通过端口交付给应用层相应的进程。 软件端口是应用层的各种协议进程与传输实体进行层间交互的一种地址。应用进程通过端口号进行标识，长度为16bit，能够标识65532个不同的端口号。 服务端使用的端口号，熟知端口号为0-1023，是IANA（互联网地址指派机构）把这些端口号指派给了TCP/IP中最重要的一些应用程序；另一类是登记端口号，数值为1024-49151，使用这类端口号必须在IANA登记以防止重复。 FTP：21，TELNET：23，SMTP：25，DNS：53，TFTP：69，HTTP：80，SNMP：161 客户端使用的端口号为49152-65535，又叫短暂端口号或是临时端口号，通信结束后就不复存在。 套接字 = （主机IP地址，端口号），网络中采用套接字组合来识别通信端点，唯一的标识了网络中的一个主机以及其上的一个应用。 基于TCP的协议：FTP、HTTP、TELNET 基于UDP的协议：TFTP、DNS、SNMP、RTP ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:5:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2 UDP协议 优点： 无需建立连接，时延小。 不用维护连接状态。 分组首部开销小。 应用层能更好地控制发送的数据和发送时间。 首部由8个字节组成，包含源端口号、目的端口、长度和校验和 5.2.2 UDP校验 （重要，建议多加练习） IP数据报与UDP一样使用检验和进行校验，只是IP数据报只检验首部，UDP数据报除了检验首部还有数据部分。 在计算校验和时，要在UDP数据报之前加上12字节的伪首部（源IP地址（4）+目的IP地址（4）+0（1）+17（1）+UDP长度（2）） 与IP数据报类似，都是使用二进制反码运算求和再取反，但是是将首部和数据部分一起检验。 发送方： 把全零放入校验和字段并且添加伪首部。 把UDP数据报看作许多16位子串连接起来。若UDP数据报的数据部分不是偶数个字节，要在末尾增补一个全零字节。 按二进制反码计算出这些16位字的和，进位重新进行累加，然后将此二进制的反码写入校验和字段。 接收方同理计算，如果无差错结果应全为1，有差错就丢弃UDP包。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:5:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.3 TCP协议 (重点，注意练习) 5.3.1 TCP协议的特点 面向连接 只能是点对点 提供可靠的交付服务，保证传送的数据无差错、不丢失、不重复且有序 全双工通信 面向字节流 5.3.2 TCP报文段 TCP报文段分为TCP首部和TCP数据，TCP首部前20个字节固定，后4N个可选项。 5.3.3 TCP连接管理 TCP连接的三个阶段：连接建立、数据传送和连接释放 TCP连接的建立：三次握手。 第一步，客户端向服务端发送SYN=1,seq=x且不含应用层数据的特殊报文段。 第二步，服务器为TCP连接分配TCP缓存和变量，在确认报文段中，SYN和ACK位置1，确认字号ack=x+1,seq=y 第三步，客户端也给该连接分配缓存和变量。ACK=1,seq=x+1,ack=y+1 TCP连接的释放，四次挥手。 第一步：客户机打算关闭连接，FIN=1,seq=u。发送FIN的一端不能再发送数据 第二步：服务器收到，ack=u+1,seq=v,ACK=1，TCP连接半关闭。 第三步：若服务器没有要向客户机发送的数据，就通知TCP释放连接，FIN=1，ACK=1,seq=w,ack=u+1 第四步：客户机确认释放报文段，ACK=1,ack=w+1,seq=u+1 总结序号变化：回复的ack=seq+1，seq=ack 5.3.4 TCP可靠传输 TCP校验和与UDP校验和一样 序号：TCP首部的序号字段(seq)用来保证数据能够有序提高给应用层。 确认：TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。TCP使用累计确认，只确认数据流中至第一个丢失字节为止的字节。 重传：在超时或有冗余ACK的时候会重传。 冗余确认：TCP规定每当比期望序号大的失序报文到达时，发送一个冗余ACK，致命下一个期待字节的序号。 快速重传：同时TCP规定发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。 5.3.5 TCP流量控制 TCP流量控制是一个速度匹配服务，为了消除发送方发送速度过快使接收方缓存区溢出的可能性。TCP的流量控制是基于窗口实现的。 接收窗口rwnd:接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小。 拥塞窗口cwnd：发送方那个根据当前对网络拥塞程序的估计而确定的值。 TCP通过报文的窗口字段将rwnd通知给发送方，表示接收方允许连续接收的最大能力，单位是字节。发送方根据收到的最新的rwnd来限制自己发送窗口的大小，将未确认的数据量控制在rwnd之内。实际上发送窗口的大小是取rwnd和cwnd的最小值。 5.3.6 TCP拥塞控制 拥塞控制的目的时为了防止过多的数据注入网中，使网络中的路由器或者链路不过载。 接收窗口rwnd:接收方根据自己接收缓存的大小所许诺的最新的窗口值，反应了接收方的容量，由接收方根据其放在TCP报文的首部的窗口字段通知发送方。 拥塞窗口cwnd：发送方那个根据自己估算的网络拥塞程度而设置的窗口值，反应了网络的当前容量。 发送窗口上限取rwnd和cwnd较小的一个。 维护拥塞窗口 慢开始算法：在TCP刚连接好时，发送方设置拥塞窗口cwnd=1，即一个最大报文长度MSS，然后在每收到一个对新的报文段的确认后，将cwnd加1。这样，每个RTT后，cwnd加倍。直到超过阈值ssthresh。 拥塞避免算法：cwnd每经过一个MSS就加一而不是加倍。当出现一次超时，ssthresh等于当前cwnd的一半。 网络拥塞的处理：遇到网络拥塞，将ssthresh=cwnd/2，并将cwnd=1，执行慢开始算法。 快重传和快恢复 快速重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段。 快恢复：当发送端收到连续三个ACK时，ssthresh=cwnd/2，但是cwnd=cwnd/2（即此时的阈值） ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:5:3","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第6章 应用层 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:0","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.1 网络应用模型 6.1.1 客户/服务器模型 CS模型，总有一个打开的主机被称为服务器，工作流程： 服务器处于接收请求的状态 客户机发出服务请求，并等待接收结果。 服务器收到请求后，分析请求，进行必要的处理，得到结果并发送给客户机。 主要特征：客户是服务请求房，服务器是服务提供方。 主要特点： 网络中各计算机的地位不平等。 客户机之间不直接通信 可扩展性不佳。 6.1.2 P2P模型 P2P模型中，各计算机没有固定的客户和服务器划分，任意一对计算机(称为对等方)直接相互通信。 优点： 减轻了服务器的计算压力。 多个客户机之间可以直接共享文档。 可扩展性好。 网络健壮性强 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:1","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.2 DNS系统 UDP协议，53号端口。可以将具有特定含义的主机名转换为IP地址。 6.2.1 层次域名空间 域是名字空间中一个可被管理的划分。 域名组成：三级域名+二级域名+顶级域名 域名中的标号注意： 标号中的英文不区分大小写。（目录和文件是区分的） 标号中除-不使用其他标点符号。 每一个标号不超过63个字符。 级别最低的域名写在最左边，级别最高的域名写在最右边。 顶级域名： 国家顶级域名nTLD 通用顶级域名gTLD，比如.com公司企业，.net网络服务机构，.org非营利性的组织，.gov美国的政府部门 基础结构域名。只有一个arpa，用于反向域名解析，又称为反向域名。 6.2.2 域名服务器 域名系统采用客户/服务器模型。DNS使用了层次方式组织域名服务器，映射分布在所有的DNS服务器上，采用分布式设计。 根域名服务器：最高层次的服务器，所有根域名服务器都知道所有顶级域名服务器的IP地址。在顶级域名服务器无法解析时，就需要求助于根域名服务器。 顶级域名服务器：负责管理该顶级域名服务器注册的所有二级域名。 授权域名服务器：将其管辖的主机名转换为该主机的IP地址。 本地域名服务器：每一个因特网服务提供者ISP，都拥有一个本地域名服务器。负责相应辖区内主机的DNS查询请求。 6.2.3 域名解析过程 正向解析：把域名映射为IP地址。 反向解析：把IP地址映射为域名。 客户端需要域名解析时： 通过本机的DNS客户端构造一个DNS请求报文，以UDP数据报形式发往本地域名服务器。 递归查询（给根域名服务器造成的负载过大，实际中几乎不使用） 递归与迭代相结合的查询 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:2","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.3 文件传输协议FTP 6.3.1 FTP的工作原理 FTP文件传输协议，允许客户指明文件的类型和格式，并允许文件具有存取权限。 使用客户/服务器的工作方式，使用TCP可靠的传输服务。一个FTP服务器进程可以同时为多个客户进程提供服务。 FTP服务器由两个部分组成：一个是主进程，负责接收新的请求。若干个从属进程，负责处理单个请求。 工作步骤： 打开熟知端口21（FTP控制端口），使客户进程能够连接上。 等待客户进程发连接请求。 启动从属进程来处理客户进程发来的请求，主进程和从属进程并发执行。从属进程对客户进程的请求处理完毕后即终止。 回到等待状态，继续接收其他客户进程的请求。 6.3.2 控制连接与数据连接 FTP在工作的时候使用两个并行的TCP连接，一个是控制连接（端口21），一个是数据连接（端口20）。 控制连接：服务器监听21号端口，等待客户连接。控制连接用来传输控制信息，在整个会话过程都会打开。 数据连接：服务端的控制进程在接收到FTP客户端发送来的文件传输请求后就创建“数据传送进程”和“数据连接”。数据连接用来连接客户端和服务端的数据传送进程，数据传送进程来实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。 因为FTP使用了一个分离的控制连接，也称FTP的控制信息是带外（out-of-band）传送的。 PS：如果需要修改服务器上的文件，需要将此文件传到本地主机，然后再将修改后的文件副本传送到原服务器。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:3","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4 电子邮件 6.4.1 电子邮件系统的组成结构 电子邮件的三个最主要的组成构建：用户代理、邮件服务器和电子邮件使用的协议（SMTP、POP3）。 用户代理UA：用户与电子邮件系统的接口。用户代理使得用户能够通过一个很友好的接口来发送和接收邮件。通常情况下是一个运行在PC上的程序。 邮件服务器：组成电子邮件系统的核心。邮件服务器的功能是发送和接收邮件，同时向发信人报告邮件发送的情况。 邮件发送协议和读取协议：邮件发送协议用于用户代理向邮件服务器发送邮件或在邮件服务器之间发送邮件，通常使用SMTP。邮件读取协议用于用户代理从邮件服务器读取邮件，如POP3. SMTP用push，将邮件推送到SMTP服务器端。POP3采用pull，当读取的时候，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件。 6.4.3 SMTP协议和POP3协议 MIME：多用途网络邮件扩充。定义了邮件传送非ASCII码的编码规则。 SMTP协议，简单邮件传输协议，是一种提供可靠且有效地电子邮件传输的协议，控制两个相互通信的SMTP进程交换信息。使用TCP连接，端口号25. 过程： 连接建立：SMTP客户每隔一端时间扫描一次缓存，发现有邮件，就使用SMTP熟知端口号25与接收方邮件服务器的SMTP服务器建立TCP连接。接收方SMTP服务器要发出“220 Service ready”（服务就绪），然后SMTP客户向SMTP服务器发送HELO命令，附上发送方的主机名。 邮件传送。使用MAIL命令+发件人地址。若SMTP服务器已准备好接收邮件，则回答“250 OK”，接着SMTP服务器发送一个或多个RECT命令来接收。主要是弄清接收方系统是否已做好接收邮件的准备，然后才发送邮件。不至于发送了很长时间才发现是地址错误，浪费通信资源。 连接释放。邮件发送完毕后释放资源 POP3协议，邮局协议，是一个非常简单但功能有限的邮件读取协议。当用户读取邮件时，用户代理向邮件服务器发出请求，拉取用户邮箱中的邮件。 同样使用TCP协议，端口号110. 在接收方计算机中的用户必须运行POP客户程序 下载并保留工作方式：用户从邮件服务器读取了邮件之后，邮件依旧会保存在邮件服务器上，下次可以再次从服务器上读取该邮件。 下载并删除工作方式：邮件一旦被读取之后，就被从邮件服务器上删除了。 网际报文存取协议IMAP，只是建议标准。也有很多基于HTTP协议的邮件提供，仅在不同邮件服务器之间传送邮件采用SMTP协议。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:4","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.5 万维网WWW 统一资源定位符URL：负责标识万维网中的各种文档，并使每个文档在整个万维网的范围内具有唯一的标识符URL。 超文本传输协议HTTP：应用层协议，使用TCP，端口一般为80 超文本标记语言HTML：是文档结构的标记语言。 HTTP协议是无状态的，在实际应用中使用cookie加数据库的方式来跟踪用户的活动。 HTTP可以使用非持久连接或持久连接。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/:6:5","tags":["考研","计算机网络"],"title":"计算机网络-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第1章 计算机系统概述 冯诺依曼结构：运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机一般把控制器和运算器集成在一个芯片上，合称为中央处理器。 现代计算机一般以存储器为中心，使I/O操作尽可能绕过CPU，直接在I/O设备与存储器间完成，从而提高系统的整体运行效率。 重要设备： 地址寄存器MAR：存放访存地址，经过地址译码后可以找到所选的存储单元。 数据寄存器MDR：是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息，失序控制逻辑用于产生存储器操作所需的各种时序信号。位数和存储字长相等。 MAR和MDR虽然是存储器的一部分，但是确实在现代CPU内的。 运算器：核心是ALUM，包含若干通用寄存器用于暂存操作数和中间结果。另外还有程序状态寄存器PSW，用来保留各类运算指令或测试指令的结果的各类状态信息，以表征系统运行状态。 控制器：由程序计数器PC、指令寄存器IR、控制单元CU组成。PC存放当前欲执行指令的地址。IR用来存放当前的指令，内容来自于主存的MDR。 CPU和主存储器构成主机，计算机中除去主机的其他硬件设备统称为外部设备。 系统软件：保证计算机系统高效、正确运行的基础软件，包括操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序。 应用软件：用户为解决某个应用领域中的各类问题而编制的程序。 PS：DBMS和DBS是有区别的。DBMS是系统软件，而DBS是引入DBMS后的系统。 信息流程： 取指令：PC-\u003eMAR-\u003eM-\u003eMDR-\u003eIR 分析指令：OP(IR)-\u003eCU 执行指令：Ad(IR)-\u003eMAR-\u003eM-\u003eMDR-\u003eACC ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:0:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2.5 计算机系统的多级层次结果 微程序机器层。硬件层，由机器硬件直接执行微指令。 传统机器语言层。机器层，由微程序解释机器指令系统。 操作系统层。由操作系统定义和解释软件指令，作为广义指令。以及机器指令组成。 汇编语言层。 高级语言层。 应用层。 层次之间，下层是上层的基础，上层是下层的扩展。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:0:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.3 计算机的性能指标 机器字长：计算机进行一次整数运算所能处理的二进制数据的位数。 数据通路带宽：数据总线一次能并行传送信息的位数 贮存容量：主存储器所能存储信息的最大容量。MAR的位数反应了存储单元的个数，MDR的位数反应了可寻址范围的最大值。 吞吐量：系统在单位时间内处理请求的数目。 CPU时钟周期：CPU中最小的时间单位，每个动作至少需要一个时钟周期。 CPU时钟主频：CPU时钟周期的倒数。主频越高，完成指令的一个执行步骤所需要的时间越短。 CPI：指执行一条指令所需的时钟周期数 CPU执行时间= CPU周期数/主频=（指令条数*CPI）/主频 MIPS(million instructions per second)：每秒执行多少百万条指令。有MIPS=指令条数/(执行时间*10^6)=主频/CPI MFLOPS，每秒执行多少百万次浮点运算，重要的性能判断标志。 平均指令周期 = 1/MIPS 平均每条指令的时钟周期数(CPI)=平均指令周期/CPU时钟周期=1/(MIPS*主频) 题目 17.C 解析：基准程序的CPI=2*0.5+3*0.2+4*0.1+5*0.2=3。计算机的主频为1.2GHz，即1200MHz，故该机器的MIPS=1200/3=400 18.D 解析：程序A的运行时间为100秒，除去CPU时间90秒，剩下10秒为I/O时间。CPU提速后运行基准程序A所耗费的时间T=90/1.5+10秒 19.D 解析：假设原来指令条数为x，那么原CPI就为20*f/x（注：f为CPU的时钟频率），经过编译优化后，指令条数减少到原来的70%，即指令条数为0.7x，而CPI增加到原来的1.2倍，即24*f/x，那么现在P在M上的执行时间就为：（指令条数*CPI）/f=(0.7x*24*f/x)/f=16.8秒 20.C 运行时间=指令数*CPI/主频。M1的时间=指令数*21.5，M2的时间=指令数*1/1.2，两者之比为(2/1.5):(1/1.2)=1.6 透明性：在计算机领域中，站在某一类用户的角度，如果感觉不到某个事物或属性的存在，则称“对该用户而言，某个事物或属性是透明的”。这与日常生活中透明的概念刚好相反。 例如，对于高级语言程序员而言，浮点数格式、乘法指令等这些语言的格式、数据如何在运算器中运算都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。 码距：任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。 奇偶校验，最高位为校验位，剩下的是信息位 奇校验：1的个数为奇数。 偶校验：1个个数为偶数。 缺点为只能发现数据代码中奇数位出现错误的情况，不能纠正错误。 海明码的位数：n位有效信息位，k位校验位，有n+k\u003c=2^k-1。 海明码最高位采用全校验，全校验是对全部数据位和其他校验位采用偶校验计算出来的。 纠错理论：L-1=D+C，且D\u003e=C，这里L是编码最小码距，D为检测错误位数，C为纠正错误位数。 第2章重点复习：补码和原码的乘法和除法 大佬的博客：数的表示与运算 PS：变形补码等同于模4补码，即符号位有两位 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:1:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"浮点数 值得注意的一点：标准的移码中，对于n+1位，偏移量为2^n，这时候有一个很好的性质，就是移码在表示上等于补码在符号位取反后的结果。 - IEEE754不是标准的译码，它的偏移量是2^k-1，即对于32位浮点数，偏移量为127 - 从网上的回答来看，目的应当是为了对齐范围 浮点数加减运算 对阶：目的是将小数点的位置对齐，使得两个数阶码相等。求阶差，然后小阶向大阶看齐的原则，将阶码小的尾数右移一位，阶加1，直到阶码相等。尾数右移的时候会舍弃有效位，引起误差。 尾数求和：对阶后尾数按定点数加减法运算。 规格化：尾数计算后有空缺，需要左规；尾数求和时结果溢出，需要右规 舍入：在对阶和右规的过程中，可能将尾数的低位丢失，引起误差，影响精度。（0舍1入，或是恒置1法） 溢出判断：浮点数使用双符号位，如果两个符号位的值不一致，则说明出现了溢出（01正溢出，上溢、10负溢出，下溢）。上溢的时候中断处理，下溢的时候当作机器零使用。 阶码全1表示无穷大（根据符号位分为正无穷和负无穷，要求尾数为0） 阶码全0表示非规格数，其中尾数全0表示机器零。 这篇文章介绍的很好。 2009年真题 浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5位和7位（均含2位符号位）。若有两个数X=2^7*29/32，Y=2%5*5/8，则用浮点加法计算X+Y的最终结果是（） A. 00111 1100010 B.00111 0100010 C. 01000 0010001 D.发生溢出 解析：选D 根据浮点数的加法步骤进行计算 X：00,111;00,11101 Y：00,101;00,10100 1 对阶。X、Y的阶码相减，可以目测出来是X的阶码比Y大2.根据小阶向大阶看齐的原则，将Y的阶码加2，尾数右移2位，将Y变为00,111;00,00101 2 尾数相加，得到01,00010，尾数相加结果符号位为01，故需要右规 3 规格化。将尾数右移1位，阶码加1，得X+Y：01,000;00,10001 4 判断溢出。阶码符号位为01，说明发生正溢出 本题容易误选B、C，B少了第3和第4步，C少了第4步 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:1:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"易忘知识点 大端：高位低地址 小端：低位低地址 如0x12345678，大端为12 34 56 78，小端为78 56 34 12 第三章 存储单元 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:1:2","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1.2 存储器的性能指标 存储容量=存储字数*字长，存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量 单位成本：每位价格=总成本/总容量 存储速度：数据传输率=数据的宽度/存储周期 存取时间Ta：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间 存取周期Tm：又称读写周期或访问周期，指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间 主存带宽Bm：又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字节/秒之类 存取周期一般大于存取时间，因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器（RAM），存取周期往往比存取时间大得多。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:1:3","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2 存储器的层次化结构 速度、容量和价格三者不能同时取得。 cache-主存：主要解决CPU和主存速度不匹配的问题 主存-辅存：主要解决存储系统的容量问题 上一层中的内容都是下一层中内容的副本。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:2:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.3 半导体随机存储器 SRAM：静态随机存储器，非破坏性读出，但是易失，断点信息不保存。功耗大、集成度低，一般用作高速缓存。 DRAM：动态随机存储器，存取速度较慢，破坏性读出且易失 DRAM需要定期刷新，重新将信息写入电容中。 集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生。优点是读写操作不受刷新操作影响，缺点是刷新时不能访问存储器 分散刷新：把对每一行的刷新分散到各个工作周期中。优点是没有死区，缺点是加长了系统的存取周期，降低了整机速度 异步刷新：结合两者，具体做法是将刷新周期除以行数，得到两次刷新操作的时间间隔t，逻辑电路每隔t秒产生一次刷新请求，尽量减少刷新的次数 透明刷新：将刷新安排在不需要访问存储器的译码阶段，。 特点： 刷新对CPU透明，即不依赖于外部的访问 DRAM以行为单位刷新，只需要行地址 刷新操作仅仅是给栅极电容补充电荷而不需要信息输出，而且不需要选片，整个存储器的所有芯片同时被刷新。 地址复用技术 来自百度知道 书上并没有明确提出这个概念，不过参考各种资料可以得出如下结论： 地址复用技术只适用于DRAM，不适用于SRAM 地址复用技术的目的是为了减少地址线的数量，便于增加DRAM的集成度 地址复用技术的本质是分两次送行列地址，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可以像DRAM那样分两次取得行列地址，减少地址线的数量。 另外SRAM与DRAM有许多不同，这个技术也是导致不同的原因之一。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:3:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.3.3 只读存储器 非易失，断电后信息保存 MROM：任何人无法改变内容 PROM：一次可编程ROM，允许用户自行写入程序，一旦写入后内容无法改变 EPROM：可以进行多次改写，当需要改变内容时需要将其中的全部内容擦除，再进行编成。分为紫外线擦除和电可擦除式两种。（编程次数有限，且写入时间过长） Flash Memory闪存：在EPROM和E2PROM基础上发展起来，在不加点的情况下可以长期保存信息，擦除重写的速度快。 固态硬盘SSD：用固态电子存储芯片阵列制成的磁盘，由控制单元和闪存芯片组成。价格较高 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:3:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.4 主存储器与CPU的连接 主存容量扩展：位扩展、字扩展、位字扩展 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.4.3 存储芯片的地址分配和片选 片选+字选 线选法：用高位地址线直接访问存储单元的片选端。优点是实现简单，不需要译码器；缺点是地址空间不连续，选片的地址线必须分时为低电平 译码片选法：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号 ##3.5 双口RAM和多模块存储器 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.5.1 双端口RAM 同一个存储器拥有左右两个独立的端口，允许两个独立的控制器同时异步地访问存储单元。当两个端口的地址不相同的时候，在两个端口上的读写操作一定不会产生冲突。 当读写同一个地址单元的时候：不同时存取或者读同一个数据不会产生冲突；同时写入或者一边读取一遍写入会产生冲突。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:2","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.5.2 多模块存储器 单体多字存储器：存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一个存储单元。优点是增大了存储器的带宽，提高了单体存储器的工作速度。缺点是指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，那么效果就不明显了。 多体并行存储器：由多个模块组成，每个模块各自独立，既能够并行工作，又能交叉工作 高位交叉编址：高位地址表示体号，低位地址表示体内地址。仍然是顺序存储器，连续的数据放在同一存储单元中。 低位交叉编址：低位地址表示体号，高位地址表示体内地址。由于程序连续存放在相邻体中，因此称采用此编址方式的存储器为交叉存储器。 低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。 设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为r，为实现流水线方式存取，则存储器交叉模块数应大于等于m=T/r 其中，m称为交叉存取度，每经r时间延迟后启动下一个模块。如果保证流水线国祚，则连续存取m个字所需的时间为t1=T+(m-1)r 已知命中率为H，主存访问时间与cache访问时间的倍率r cache主存系统的效率：e=访问Cache的时间/平均访存时间=1/[H+(1-H)r] ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:3","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.6 高速缓冲器 3.6.1 程序访问的局部性原理 包括时间局部性和空间局部性。时间局部性指的是最近的未来要用到的信息，很可能是现在正在使用的信息，这是因为程序存在循环。空间局部性指的是最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组、表等形式簇聚地存储在一起。 高速缓存由SRAM构成 CPU要访问的信息在cache中的比率称为命中率，设总命中次数为Nc，访问内存的总次数为Nm，命中率H=Nc/(Nc+Nm) 平均访问时间Ta=Htc+(1-H)tm ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:4","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.6.3 Cache和主存的映射方式 cache中要为每一块加一个标记，指明它是主存中那一块的副本，内容相当于主存中块的编号。 为了说明标记是否有效，每个标记至少应该设置一个有效位，该位为1的时候，表示Cache映射的主存块数据有效；否则无效。 直接映射：j=i mod 2^c，其中j是cache的块号，i是主存的块号，2^c是cache中的总块数。直接映射的地址结构为：主存字块标记+Cache字块地址+字块内地址 全相联映射：可以把主存块装入Cache中的任何位置。通常采用按内容寻址的相联存储器来进行地址映射。地址结构为：主存字块标记+字块内地址 组相联映射：将cache分为大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置，是对全相联映射和直接映射的一种折中。j=i mod Q，j是缓存的组号，i是主存的块号，Q是Cache的组数。地址结构：主存字块标记+组地址+字块内地址 例题 假设某个计算机的主存地址空间大小为256MB，按字节寻址，其数据Cache有8个Cache行，行长为64B，那么 1.若不考虑用于cache的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据cache的总容量为多少？ 2.若该cache采用直接映射方式，则主存地址为3200(十进制)的主存块对应的cache行号是多少？若采用二路组相联映射又是多少？ 3.以直接映射为例，简述访存过程（设访存的地址为0123456H） 4256bit，标记字段长度的计算：主存地址有28位(256MB=2^28B)，其中6位为块内地址(2^6B=64B)，3位为行号，剩余28-6-3=19位为标记字段，总容量为8*(1+19+512)=4256bit 直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为3200B/64B=50。而Cache只有8行，则50mod8=2，故对应的cache行号为2 二路组相联，实际上就是将两个cache行合并，内部采用全相联方式，外部采用直接映射方式，50mod4=2，对应的组号为2，也就是对应的cache行号为4或5. 直接映射方式，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即0000 0001 0010 0011 010位主存标记为，001位块号，010110位块内地址。 首先根据块号，查Cache（即001号Cache行）中对应主存标记位，看是否相同。如果相同，再看Cache行中的装入有效位是否为1，如果是，则表示有效，称此为访问命中，按块内地址010110读出Cache行所对应的单元送入CPU中，完成访存 如果出现标记位不相等或者有效位为0的情况，则是不命中，访问内存将数据取出送往CPU和Cache的对应块中，把主存的最高19位存入001行的Tag中，并将有效位置1. cache中的标记位 详细 脏位：使用写回法修改数据的时，会先修改cache中的数据，再修改脏位，表示修改过。如果cache中的数据被换出且脏位被修改过，需要写回内存。 控制位：替换算法控制位，正常情况不用考虑，位数未知。 维护位：一致性维护位，一般不用考虑，主要用于多核调度的数据一致性。 有效位：标志着Cache数据是否有效的，比如刚开始的时候cache数据就是无效的。1位 标记位：主存字块标记位，表示这块Cache代表的主存中的哪一块。主存地址=主存字块标记位+Cache中的组号/直接映射号+cache内偏移 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:5","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.6.4 Cache中主存块的替换算法 采用全相联映射和组相联映射方式时，当cache的空间已经被占满时，就需要使用替换算法替换cache行。 随机算法：完全随机确定，命中率较低 先进先出算法：将最早调入的行进行替换，没有依据程序访问的局部性原理。 近期最少使用算法：堆栈类算法，平均命中率比FIFO高。实现上对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器均加1，需要替换时将计数值最大的行换出。 最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换的时候将计数值最小的行换出 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:6","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.6.5 Cache写策略 对于Cache写命中，两种策略 全写法(写直通法、write-through)：必须把数据同时写入cache和主存。替换时直接覆盖。实现简单，但是增加了访存次数。 写缓冲：为了减少全写法直接写入主存的时间消耗，在cache和主存之间加一个写缓冲。可以解决速度不匹配的问题，但是频繁写的时候可能会饱和溢出 写回法(write-back)：不立即写入主存，只有当此块被换出时才写回主存。减少了访存次数，但存在不一致的隐患。实现上必须为每个cache行设置一个标志位（脏位），一次反映此块是否被CPU修改过。 写不命中： 写分配法(write-allocate)：加载主存中的块到cache中，然后更新这个块。缺点是每次不命中都要从主存中读取一块 非写分配法(not-write-allocate)：只写入内存，不进行掉块。 一般非写分配法与全写法合用。写分配法通常和写回法合用。 PS：需要意识到，cache中的内容都是主存中的备份，因此在计算存储系统容量的时候不能够简单地将主存容量与cache容量相加。 - 主存地址从0开始的时候，组相联的组号需要慎重考虑是否能直接通过求余得到（仔细思考） ## 3.7 虚拟存储器 与cache的不同之处： 1. cache是为了解决系统速度，而虚拟存储器解决的是主存容量。 2. cache全由硬件实现，对所有程序员透明；而虚拟存储器由OS和硬件实现，对系统程序员不透明。 3. CPU速度为cache的10倍，而主存速度为磁盘速度的100倍，故虚拟存储器系统不命中时对系统性能的影响更大。 4. cache不命中的时候主存能直接和CPU通信，把数据调入cache中。而虚拟存储器不命中时只能先将数据调入主存，不能直接和CPU通信。 PS：指令和数据可以分别存储在不同的cache中，其特点是允许CPU在同一Cache存储周期内同时提取指令和数据，由于指令执行过程取值和取数据都有可能访问cache，这一特性可以保证不同的指令同时访存。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:7","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2 指令寻址方式 寻址方式是指寻找指令或操作数有效地址的方式，也就是确定本条指令的数据地址以及下一条要执行的指令地址的方法。分为指令寻址和数据寻址两大类。 指令中的地址码字段叫做形式地址A，通过A结合寻址方式可以计算出操作数在存储器中的真实地址，称为有效地址EA。 4.2.1 指令寻址和数据寻址 指令寻址的方式有两种，一种是顺序寻址方式，另一种是跳跃寻址方式。 顺序寻址方式通过程序计数器PC加1（1个指令字长），自动形成下一条指令的地址。 跳跃寻址则通过转移类指令实现。跳跃指下一条指令的地址码由本条指令给出（提供计算方式，可能受状态寄存器和操作数的控制），跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，所以下一条指令仍然是通过程序计数器PC给出。 数据寻址：数据寻址就是如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。 指令格式：操作码+寻址特征+形式地址A 4.2.2 常见的数据寻址方式 隐含寻址：不明显给出操作数的地址，在指令中隐含着操作数的地址。优点是有利于缩短指令字长，缺点是需要增加存储操作数或隐含地址的硬件。 立即（数）寻址：这些指令的地址字段指出的不是操作数的地址，而是操作数本身，又称为立即数。数据采用补码形式存放，优点是指令在执行期间不用访问主存，执行时间最短；缺点是A的位数限制了立即数的范围。 直接寻址：形式地址A=EA。优点是简单，只用访问一次主存；缺点是A的位数决定了该指令操作数的寻址范围，且操作数的地址不易修改。 间接寻址：指令的地址字段给出的形式地址A不是操作数的真正地址EA，而是操作数有效地址所在的存储单元的地址（EA=(A)）。可以是一次间接寻址或是多次间接寻址。优点是可扩大寻址范围，便于编制程序（方便实现子程序返回）；缺点是指令在执行期间要多次访存，访问速度过慢，一般使用寄存器间接寻址。 寄存器寻址：由指令直接给出操作数所在寄存器编号，即EA=R_i。优点是指令在执行期间不访问主存，只访问寄存器；缺点是寄存器价格昂贵，数量有限。 寄存器间接寻址：寄存器存放着操作数所在主存单元的地址，即EA=(R_i)，比一般的间接寻址速度更快，但是指令的执行阶段需要访问主存。 相对寻址：把PC的内容+A得到操作数的有效地址，即EA=(PC)+A，A是相对于当前地址的偏移量，可正可负。优点是操作数的地址不固定，便于程序浮动，广泛用于转移指令。（值得注意的是，对于转移指令JMP A，PC会自动执行PC+1，也就是说会跳到目的指令的下一条指令执行） 基址寻址：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，形成操作数的有效地址，即EA=(BR)+A。基址寄存器是面向操作系统的，主要目的是解决程序逻辑空间与存储器物理空间的无关性，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。优点是可以扩大寻址范围，用户不必考虑自己的程序位于主存的哪一空间区域，利于多道程序设计，但偏移量的位数较短。 变址寻址：变址寄存器IX，EA=(IX)+A。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），而形式地址A不变（作为基地址）。优点是可以扩大寻址范围，利于编制循环程序，主要用于处理数组问题。 堆栈寻址：堆栈是一块LIFO的存储区，地址由特定的寄存器=堆栈指针SP负责。堆栈可分为硬堆栈（寄存器堆栈）与软堆栈（主存堆栈），通过无操作数，隐式地使用SP完成操作。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:8","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3 CISCO和RISC的基本概念 CISC，复杂指令系统计算机，典型的有采用x86架构 RISC，精简指令系统计算机，ARM和MIPS架构 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:9","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.1 CPU的功能和基本结构 5.1.2 CPU的基本结构 运算器，计算机对数据进行加工处理的中心，主要由算术逻辑单元ALUM、暂存寄存器、累加寄存器ACC、通用寄存器组、程序状态字寄存器（PSW）、移位器、计数器（CT）等组成。 算术逻辑单元：主要功能是进行算术/逻辑运算 暂存寄存器：暂存从主存读来的寄存器 累加寄存器：通用寄存器，暂存ALU运算的记过 通用寄存器组：用于存放操作数和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。 程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息 CY/CF(carry)：加法运算中有进位或减法运算中有借位置1，否则置0 OV/OF：有无溢出，溢出时OF=1 SF/NF(symbol flag)：符号标志，判断指令执行后结果是否为负，如果是SF=1 ZF：零标志，判断结果是否为0，如果是ZF=1 IF：允许中断 TF：跟踪标志 移位器：对操作数或运算结果进行移位运算 计数器：控制乘除运算的操作步数 控制器：整个系统的指挥中枢，基本功能是执行指令，每条指令的执行都是由控制器发出的一组微操作实现的。工作原理是根据指令操作码、指令的执行步骤和条件信号来形成当前计算机各部件要用到的控制信号。分为硬布线控制器和微程序控制器两种。 程序计数器PC：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令 指令寄存器IR：用于保存当前正在执行的那条指令 指令译码器：对操作码字段进行译码，向控制器提供特定的操作信号。 存储器地址寄存器MAR：用于存放所要访问的主存单元的地址 存储器数据寄存器MDR：用于存放向主存写入的信息或从主存中读出的信息 时序系统：用于产生各种时序信号 微操作信号发生器：根据IR、PSW的内容以及时序信号，产生控制整个计算机系统所需要的各种控制信号，结构有组合逻辑型和存储逻辑型。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:10","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2 指令执行过程 指令字长一般都取存储字长的整数倍，和机器字长没有关系。 5.2.1 指令周期 指令周期：CPU从主存中每取出并执行一条指令所需的全部时间，也就是CPU完成一条指令的时间。 指令周期常常用若干机器周期表示，一个机器周期包含若干个时钟周期。 时钟周期，又称为节拍或T周期，是CPU操作的最基本单位。 机器周期，又称为CPU周期，是执行指令一项操作（取值、执行）的时间 对于无条件转移指令，执行的时候不需要访问内存，只包含取指阶段（包括取值和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。 对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后再访问主存取出操作数，所以还需要包括间址周期。 如果存在中断的话，还会有中断周期。完整的指令周期应该包含取值、间址、执行和中断4个周期。 上述4个工作周期CPU都需要访存，只是访存的目的不相同。 CPU设置4个标志触发器FE、IND、EX和INT，分别对应取值、间址、执行和中断周期。 PS：中断周期中进栈操作是将SP减1，和传统意义上相反。原因是计算机的堆栈中都是向低地址增加，所以进栈是减1而非加1. 5.2.2 指令周期的数据流 取值周期，任务是根据PC中的内容从主存中取出指令代码并存放在IR中。 1.PC-\u003eMAR-\u003e地址总线-\u003e主存 2. CU发出控制信号-\u003e控制总线-\u003e主存 3. 主存-\u003e数据总线-\u003eMDR-\u003eIR 4. CU发出读命令-\u003ePC内容加1 间址周期，任务是取操作数有效地址。以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。 Ad(IR)-\u003eMAR-\u003e地址总线-\u003e主存 CU发出读命令-\u003e控制总线-\u003e主存 主存-\u003e数据总线-\u003eMDR（存放有效地址） 其中，Ad(IR)表示取出IR中存放的指令字的地址字段。 执行周期，任务是根据IR中的指令字的操作码和操作数通过ALUM操作产生执行结果。 中断周期，任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:11","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.3 数据通路的功能和基本结构 数据在功能部件之间的传送路径称为数据通路，描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器。 5.3.2 数据通路的基本结构 CPU内部单总线方式。将所有寄存器的输入端和输出端都连接到一条公共的通路上，存在较多的冲突现象，性能较低 CPU内部三总线方式。将所有寄存器的输入端和输出端都连接到多条公共的通路上，同时在多个总线上传送不同的数据，提高效率 专用数据通路方式，避免使用共享总线，性能比较高，但是硬件量大 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:12","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4 控制器的功能和工作原理 控制器的主要功能： 从主存中取出一条指令，并指出下一条指令在主存中的位置 对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作 指挥并控制CPU、主存、输入和输出设备之间的数据流动方向 5.4.2 硬布线控制器 基本原理：根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号。由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器。 CPU的控制方式：控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。因为每条指令和每个微操作所需的执行时间也不同，有3种控制方式： 同步控制方式：系统有统一的时钟，所有的控制信号来自统一的时钟信号。通常以最长的微操作序列和最繁琐的微操作作为标准，采用完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。优点是控制电路简单，缺点是运行速度慢 异步控制方式：不存在基准时钟信号，各部件按照自身固有的速度工作，通过应答方式进行联络。优点是速度快，缺点是控制电路复杂 联合控制方式：介于同步、异步的一种折中，对不同指令的微操作实行大部分同步控制、小部分异步控制的方法 硬布线控制单元设计步骤： 列出微操作命令的操作时间表 进行微操作信号总和 画出微操作命令的逻辑图 5.4.3 微程序控制器 基本思想是将每一条机器指令编写成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作命令。 微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的执行过程 微指令是若干微命令的集合。 微周期通常指从控制存储器中读取一条微指令并执行相应微操作所需的时间 微程序控制器的基本组成： 主要画出的是微程序控制器比组合逻辑控制器多出的部件 控制存储器CM：它是微程序控制器的核心部件，用于存放各指令对应的微程序，可以用ROM构成 微指令寄存器CMDR：用于存放从CM中取出的微指令，它的位数同微指令字长相等 微地址形成部件：用于产生初始微地址和后继微地址，以保证微指令的连续执行 微地址寄存器CMAR：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备 微程序控制器的工作流程： 执行取微指令公共操作 由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR 从CM中逐条取出对应的微指令并执行 执行完对应于一条机器指令的一个微程序后又回到取值微程序的入口地址，继续1，以完成取下一条机器指令的公共操作。 微指令的编码方式：编码的目的是在保证速度的情况下，尽量缩短微指令字长 直接编码方式（直接控制）：微指令的微命令字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只需要将对应的位设为0或1即可。优点是简单、直观；缺点是微指令过长。 字段直接编码方式：将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同的字段中，每个字段独立编码。可以缩短字长，但是比较慢（一般每个小段还要留出一个状态，表示本字段不发出任何微命令） 字段间接编码方式：一些字段中的某些微命令需要由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微指令，故称为字段间接译码，又称隐式编码。可以进一步缩短微指令字长，但是削弱了微指令的并行执行能力，所以一般作为辅助手段。 微指令的地址形成方式： 直接由微指令的下地址字段指出。微程序格式中设置一个下地址字段，由微程序的下地址字段直接指出后继微指令的地址，又称为断定模式。 根据机器指令的操作码形成。当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。 其他形成微指令序列地址的方式： 增量计数器法，适用于后继微指令的地址是连续的情况 根据各种标志决定微指令分支转移的地址 通过网络测试形成 由硬件直接产生微程序入口地址 微指令的格式： 水平型微指令：直接编码、字段直接编码、字段间接编码和混合编码都属于这种。指令字中的一位对应一个控制信号，一条水平型微指令定义并执行几种并行的基本操作 优点是微程序短，执行速度快；缺点是微指令长，编写微程序较麻烦 垂直型微指令。采用类似机器操作码的方式，在微指令中设置微操作字段，采用微操作码编译法。一条垂直型微指令只能定义并执行一种基本操作。 优点是微指令短、简单、规整；缺点是微程序长，执行速度慢，效率低 混合型微指令。在垂直型的基础上增加一些不太复杂的并行操作。 微指令控制单元的设计步骤： 写出对应机器指令的微操作命令及节拍安排 确定微指令格式 编写微指令码点 动态微程序设计：一台微程序控制的计算机，如果能够根据用户的要求改变微程序，那么这台机器就具有动态微程序设计功能。需要可写控制寄存器的支持，可采用可擦除只读寄存器EPROM。 毫微程序设计：如果硬件不由微程序直接控制，而是通过存放在第二级控制寄存器中的毫微程序来解释的，则直接控制硬件的是毫微微指令。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:13","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.5 指令流水线 5.5.2 流水线的分类 部件功能级流水：将复杂的算术逻辑运算组成流水线工作方式。例如，将浮点加法运算分成求阶差、对阶、尾数相加以及结果规格化4个子过程 处理机级流水：把一条指令解释过程分成多个子过程，如前面提到的取值、译码、执行、访存及写回5个子过程 处理机间流水，一种宏流水，每一个处理机专门完成某一专门任务，各个处理机所得到的结果需存放在下一个处理机所共享的存储器中。 5.5.3 影响流水线的因素 结构相关（资源冲突） 由于多条指令在同一时刻争用同一资源而引起的冲突称为结构相关。两种解决方法： 前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。 单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行。（资源重复配置） 数据相关（数据冲突） 数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。解决方法： 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞（stall）和软件插入\"NOP\"指令两种方法。 设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而是直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程。（数据旁路技术） 通过编译器对数据相关的指令编译优化的方法，通过调整指令顺序来解决数据相关。 控制相关（控制冲突） 当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。解决的方法： 对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。 预测转移成功和不成功两个控制流方向上的目标指令。 加快和提前形成条件码。 提高转移方向的猜准率。 5.5.4 流水线的性能指标 吞吐率，指在单位时间内流水线所完成的任务数量，或是输出结果的数量。TP=n/Tk，其中n是任务数，Tk是处理完成n个任务所用的时间。 加速比，指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。设T0表示不使用流水线时的执行时间，即顺序执行所用的时间；Tk表示使用流水线时的执行时间，加速比S=T0/Tk。 如果流水线各段执行时间都相等，则一条k段流水线完成n个任务所需要的时间为Tk=(k+n-1)*\\delta t。而不使用流水线，即顺序执行n个任务时，所需的时间为T0=kn\\delta t，代入有加速比S=kn/(k+n-1) 效率，流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为完成n个任务占用的时空图有效面积与n个任务所用的时间与k个流水段所围成的时空区总面积之比。E=T0/kTk 5.5.5 超标量流水线的基本概念 超标量流水线技术：每个时钟周期可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此配置多个功能部件。 超流水线技术：在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次。 超长指令字：由编译程序挖掘出指令潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。 真题 2017-19 下列关于指令流水线数据通路的叙述中，错误的是（） A. 包含生成控制信号的控制部件 B. 包含算术逻辑运算部件ALU C. 包含通用寄存器组和取指部件 D. 由组合逻辑电路和时序逻辑电路组成 解析：选A 流水线中各个子系统之间通过数据总线连接形成的数据传送路径称为数据通路，包含程序计数器、算术逻辑运算部件、通用寄存器组、取值部件等，不包括控制部件。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:4:14","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第6章 总线 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:5:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.1 总线概述 6.1.2 总线的分类 片内总线：芯片内部的总线，比如CPU芯片内部寄存器与寄存器之间、寄存器与ALUM之间的公共连接线 系统总线 数据总线，用来传输各种功能部件之间的数据信息，是双向传输总线，其位数与机器字长、存储字长有关。 地址总线，用来指出数据总线上源数据或目的数据所在的主存单元或I/O端口的地址，单向传输总线，地址总线的位数与主存地址空间的大小有关。 控制总线，传输的是控制信息，包括CPU送出的控制命令和主存返回CPU的反馈信号。 通信总线：计算机系统之间或计算机系统与其他系统之间信息传送的总线，也称为外部总线。 6.1.4 总线的性能指标 传输周期：一次总线操作所需要的时间，简称总线周期。总线周期通常由若干个总线时钟周期组成。 总线时钟周期：即机器的时钟周期 总线的工作频率：总线上各种操作的频率，为总线周期的倒数，如果总线周期=N个时钟周期，总线的工作频率=时钟频率/N 总线宽度：总线位宽，总线上能同时传输的数据位数 总线带宽：可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数。 总线带宽=总线宽度*总线工作频率/8 单位：B/s ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:5:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.2 总线仲裁 6.2.1 集中仲裁方式 总线控制逻辑集中于一个设备上，利用一个特定的裁决算法进行裁决，称为集中仲裁方式 链式查询方式：总线上所有的部件共用一根总线请求线，响应信号逐个传递。如果响应信号到达的部件有总线请求，则信号被截住，不再传下去。 优点：优先级固定，结构简单，扩展容易 缺点：对硬件电路的故障敏感，且优先级不可改变，可能会饥饿 计数器定时查询方式：采用一个计数器控制总线使用权，计数器计数是，如果地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线使用权，同时中止计数器的计数及查询。 优点：设备使用总线的优先级相等，而且硬件故障不那么敏感 缺点：增加了控制线数，控制更加复杂 独立请求方式：每个设备均有一对总线请求线和总线允许线。 优点：响应速度快 缺点：控制线数量很多，总线逻辑更加复杂 总结： 6.2.2 分布仲裁方式 每个设备有自己的仲裁号和仲裁器，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较，如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最终，获胜者的仲裁号保留在仲裁总线上。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:5:2","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.3 总线操作和定时 6.3.1 总线传输的4个阶段 1.申请分配阶段：由使用总线的主模块向总线仲裁机构申请。 2. 寻址阶段：取得了使用权的主模块通过总线访问本次要访问的从模块 3. 传输阶段：主模块和从模块进行数据交换 4. 结束阶段：主模块让出总线使用权。 6.3.2 同步定时方式 系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。产生相等的间隔，每个间隔构成一个总线周期，在一个总线周期中，发送方和接收方可以进行一次数据传送。 优点：传送速度快，具有较高的传输速率；总线控制逻辑简单 缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。 6.3.3 异步定时方式 没有同一的时钟或固定的时间间隔，完全依靠双方相互发送握手信号。 通常，把交换信息的两个部件分为主设备和从设备，主设备提出交换信息的“请求”信号，从设备发出“回答”信号 优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。 缺点：比同步控制方式稍微复杂一些，速度比同步定时方式慢 根据请求和回答信号是否互锁，又分为3种类型： 不互锁方式：主设备发出请求信号后，不必等到接到从设备的回答信号，而是经过一段时间后，便撤销请求信号。从设备在接到请求信号后，发出回答信号，并在一段时间后，自动撤销回答信号。 半互锁方式：主设备发出请求信号后，必须等待从设备发出回答信号，才能撤销请求信号，有互锁。从设备在接到请求信号后，发出回答信号，不必等待主设备的请求信号撤销，而是隔一段时间自动撤销。 全互锁方式：主设备发出请求信号后，必须在从设备回答后，才能撤销。从设备发出回答信号后，必须等主设备请求信号撤销后，才能撤销。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:5:3","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4 总线标准 6.4.1 常见的总线标准 ISA总线，Industry Standard Architecture，工业标准体系结构总线，是最早出现的微型计算机的系统总线标准，应用在IBM的AT机上。 EISA总线，扩展的ISA总线，为配合32位CPU设计的总线扩展标准，对ISA完全兼容。 VESA总线，32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。 PCI总线(Peripheral Component Interconnect，外部设备互连总线)，是高性能的32位或64位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统而设计的互联机制（显卡、声卡、网卡）。支持即插即用，是一个与处理器时钟无关的高速外围总线，属于局部总线。 PCI-Express：串行传输 AGP，视频接口标准，连接主存和图形存储器，局部总线。 7.RS-232C总线，串行通信总线标准 USB总线，通用串行总线，设备总线，即插即拔 PCMCIA，小型的用于扩展功能的差错，即插即用 IDE总线，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接。 SCSI小型计算机系统接口，用于计算机和智能设备（硬盘、光驱）系统级接口的独立处理器标准 12.SATA串行高级技术附件，基于行业标准的串行硬件驱动接口，硬盘接口规范。 并行总线因为涉及到多条线之间数据同步的问题，所以速度其实是不如串行总线快的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:5:4","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第7章 输入/输出系统 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:6:0","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.1 I/O系统基本概念 7.1.2 I/O控制方式 基本的控制方式有4种： 程序查询方式：由CPU通过程序不断查询I/O设备是否已经做好准备，从而控制I/O设备与主机交换信息。 程序中断方式：只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。 DMA方式：主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无需调用中断服务程序。 通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需要启动有关通道，通道将执行通道程序，从而完成I/O操作。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:6:1","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.2 外部设备 除主机之外，能直接或间接与计算机交换信息的装置。 7.2.2 输出设备 显示器 吸纳是存储器VRAM：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。 VRAM容量=分辨率*灰度级位数 VRAM带宽=分辨率*灰度级位数*帧频 7.2.3 外存储器 磁盘存储器 平均存取时间=寻道时间（磁头移动道目的磁道）、旋转延迟时间（磁头定位到所在扇区）和传输时间（传输数据所花费的时间）3个部分构成。 数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转速为r（转/秒），每条磁道容量为N个字节，则数据传输率为Dr=r/N. 磁盘阵列 RAID通过使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提供容错能力。 一个汉字内码在主存中占用2个字节，输出的字形码16*16点阵占用32个字节。 在字符显示器中的VRAM存放ASCII码以显示字符。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:6:2","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.3 IO接口 CPU同外设之间的信息传送实质上是对接口中的某些寄存器（即端口）进行读或写，如传输数据是对数据端口DBR进行读写操作。 接口与端口不同，端口是指接口电路中可以进行读/写的寄存器，若干个端口加上相应的控制逻辑才可以组成接口。 内部接口：与系统总线相连，实质上是与内存、CPU相连，数据的传输方式只能是并行传输。 外部接口：通过接口电缆与外设相连，可能是串行方式，所以IO接口需要具有串/并转换功能。 7.3.4 IO端口及其编址 每一个端口对应一个端口地址 统一编址：又称为存储器映射编址，是指把IO端口当作存储器的单元进行地址分配。不用专门的输入输出指令，用统一的访存指令即可访问IO端口。但是占用了存储器地址会使内存容量变小，且利用存储器编址的IO设备进行数据输入/输出操作，执行速度较慢。 独立编址：又称为IO映射方式，即IO端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口。优点是程序清晰，缺点是输入/输出指令横扫，一般只能对端口进行传送操作，控制比较复杂。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:6:3","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.4 I/O方式 前两者更依赖于CPU中程序指令的执行。 7.4.1 程序查询方式 信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（控制端口）。当主机进行I/O操作时，首先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。 工作流程： CPU执行初始化程序，并预置传送参数。 向I/O接口发出命令字，启动I/O设备。 从外设接口读取其状态信息。 CPU不断查询I/O设备状态，直到外设准备就绪 传送一次数据。 修改地址和计数器参数 判断传送是否结束，若没有结束转第3步，直到计数器为0. CPU与I/O串行工作，一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序。 CPU在信息传送过程中要花费很多时间用于查询和等待，而且一段时间内只能和一台外设交换信息，效率大大降低。 7.4.2 程序中断方式 程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后又自动返回到现行程序的断点处，继续执行原程序。 内中断和外中断 根据中断源的不同，可以将中断源分为内中断和外中断两种。 每个中断源向CPU发出中断请求的时间是随机的。为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTRODUCE，当其状态为1时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。 外中断：狭义上的中断，来自处理器和内存之外的部件引起的中断，包括IO设备发出的IO中断、外部信号中断（如Ctrl+C、ESC等），以及各种定时器引起的时钟中断。 内中断：又称异常，主要指在处理器和内存内部产生的中断。包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错（访存时缺页）、算术操作溢出、数据格式非法、除数为0、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及用户态到核心态的切换。 硬件中断：通过外部硬件产生的中断，属于外中断 软件中断：通过某条指令产生的中断，可以编成实现，属于内中断。 非屏蔽中断：一种硬件中断，不可屏蔽中断请求NMI控制，不受中断标志位IF的影响，即使在关中断（IF=0）的情况下也会被响应。 可屏蔽中断：也是一种硬件中断，通过中断请求标记触发器INTRODUCE控制，且受中断标志位IF的影响，在关中断情况下不接收中断请求。 一般而言，只要是延迟也不会有太大影响的（比如打印机等外设）都是可以屏蔽的。如果延迟会造成重大印象的（比如断电）那就不可以屏蔽 软件中断是否可以被屏蔽 中断判优 中断系统在一瞬间只能够响应一个中断源的请求，如果有多个中断源同时请求，需要通过中断判优逻辑确定响应哪个中断源的请求。 硬件实现：硬件排队器 软件实现：查询程序 CPU响应中断必须满足以下3个条件： 中断源有中断请求 CPU允许中断及开中断 一条指令执行完毕，且没有更紧迫的任务 中断隐指令：CPU响应中断后，经过某些操作，转去执行中断服务程序（由硬件直接实现） 工作流程： 关中断。处理器响应中断后，首先要保护程序的现场状态。 保存断点。为了保证中断服务程序执行完毕后能正确地返回原来的程序，必须将原来程序的断点保存起来。 引出中断服务程序。（实质上是取出中断服务程序的入口地址，中断向量，然后送入程序计数器中）可以用硬件向量法和软件查询法寻找入口地址 保存现场和屏蔽字。进入中断服务程序后首先要保存现场，现场信息一般指的是程序状态字、中断屏蔽器和CPU中某些寄存器的内容 开中断。允许中断嵌套 执行中断服务程序。这是中断系统的核心 关中断。保证恢复现场和屏蔽字时不被打断 开中断、中断返回。中断服务程序的最后一条指令是中断返回指令，使其返回原程序的断点处，以便继续执行原程序。 1-3是中断隐指令（硬件自动完成），4-9由中断服务程序完成。 中断屏蔽技术 主要用于多重中断，要求CPU具备多重中断的能力 条件： 在中断服务程序中提前设置开中断指令。 优先级别高的中断源有权中断优先级别低的中断源 而每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容就是屏蔽字。 参见例题 7.4.3 DMA方式 DMA方式是一种完全由硬件进行成组信息传送的控制方式。具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。 DMA方式是在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU在传送数据时的开销。（省去了保护、恢复CPU现场等繁琐操作） 有一个对数据传送过程进行控制的硬件，称为DMA控制器。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应后将让出系统总线，由DMA控制器接管总线进行数据传送。 过程： 接收外设发出的DMA请求，并向CPU发出总线请求 CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期 确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数 规定数据在主存和外村间的传送方向，发出读写等控制信号，执行数据传送操作 向CPU报告DMA操作的结束。 DMA传送方式：主存和DMA控制器之间有一条数据通路，因此主存和IO设备进行数据交换的时候可以不通过CPU。但是IO设备与CPU同时访存的时候可能引起冲突，3种方式： 停止CPU访问主存。DMA向CPU发送一个信号，要求CPU放弃地址线、数据线和有关控制线的使用权，DMA在获得总线使用权之后开始数据传送。之后交回。在传送过程中，CPU基本处于不工作状态。 DMA与CPU交替访存。适用于CPU的工作周期比主存存取周期长的情况。例如CPU工作周期1.2us，主存存取周期0.6us，可以将一个CPU周期分为C1周期和C2周期，C1周期专供DMA访存，C2周期专供CPU访存，总线控制权通过C1和C2分时控制 周期挪用/窃取：前两种方式的折中。IO有DMA请求时有三种情况。第1种CPU不再访存，未冲突；第2种，CPU正在访存，必须等待存取周期结束后，CPU再将总线占有权让出；第3种IO和CPU同时请求访存，这时候CPU暂时放弃总线使用权，让IO设备挪用一个或几个存取周期。 DMA传送过程：预处理、数据传送和后处理 预处理：CPU完成一些必要的准备工作，执行I/O指令以测试I/O设备状态，向DMA控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备号发送的数据或接受的数据，此时I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求，用以传送数据 数据传送：DMA数据传送可以以单字节或是数据块为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的输入输入都是通过循环来实现的。这一阶段全部由DMA（硬件）控制 后处理：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验食人鱼主存的数据是否正确、测试传输过程是否出错以及决定是否继续使用DMA传送其他数据块。 DMA请求的优先级高于中断请求。 DMA内容的优秀博客 比较 DMA方式和中断方式的区别 中断方式是程序的切换，需要保护和恢复现场；DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源 对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期之后）；而对DMA请求的响应可以发生在每个机器周期结束时（取值、间址、执行周期之后均可），只要CPU不占用总线就可以被响应。 中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，故数据传输速率非常高，适合高速外设的成组数据传送。 DMA请求的优先级高于中断请求。 中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的IO操作 从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。 ","date":"2021-03-09","objectID":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/:6:4","tags":["考研","计算机组成"],"title":"计算机组成-概述","uri":"/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":" 整理磁盘时发现的408笔记 第一章 操作系统概述 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:0:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.1 操作系统的基本概念 操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:1:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.1.2 操作系统的特征 并发、共享、虚拟和异步，其中现代操作系统最基本的特征是并发和共享。 并发：两个或多个事件在同一时间间隔内发生。（并行是同一时刻内发生）单处理机环境的并发在微观上表现为程序分时交替执行，操作系统的并发性是通过分时得以实现的。 共享：系统中的资源可供多个并发执行的进程共同使用。 虚拟：将物理的实体变为若干逻辑上的对应物 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行是以不可预知的速度向前推进。 操作系统的接口： 命令接口：用户利用这些操作命令来组织和控制作业的执行。 程序接口：程序员用其来请求操作系统服务（系统调用） 命令接口分为联机命令接口和脱机命令接口。联机命令接口用于分时系统，脱机命令接口用于批处理系统。 程序接口由一组系统调用命令（广义指令）组成，包括图形接口等。 PS：系统调用是操作系统提供给应用程序使用内核功能的接口。库函数是高级语言中提供的与系统调用对应的函数（部分与系统调用无关），目的是隐藏访管指令的细节，更加抽象、透明。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:1:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2 操作系统的发展与分类 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2.1 手工操作阶段（此阶段无操作系统） 略过 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2.2 批处理阶段 单道批处理系统：内存中始终保持一道作业 多道批处理系统：可以允许多个程序同时进入内存进行作业。 多道程序设计特点： 多道：计算机内存中同时存放多道相互独立的程序 宏观上并行：同时进入系统的多道程序都处于运行状态，即它们先后开始了各自的运行，但都未完成。 微观上串行：内存中的多道程序轮流占有CPU。 在分时系统中，时间片一定的时候，用户数量越多，每个用户分到的时间片就越少，响应时间自然就变长。 实时系统为了保证高响应时间，一般内存调度使用抢占式的优先级高者优先算法。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.2.3 分时操作系统 分配时间片给进程。 实现分时系统最关键的问题是如何使用户能与自己的作业进行交互。 多道程序设计的基本特征： 引入多道程序设计后，程序的执行就失去了封闭性和顺序性 多道程序系统通过组织作业使CPU总有一个作业可以执行，从而提高了CPU的利用率、系统吞吐量和IO设备利用率，但是系统要付出额外的开销来组织作业和切换作业，所以开销会比单道程序系统更大。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:2:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.3 操作系统的运行环境 用户态与核心态，使用访管指令进行切换，切换时会引起一次中断。 中断处理功能需要在核心态下进行。 内核功能： 时间管理 中断机制 原语（定义原语的直接方法是关中断，完成动作后再打开） 系统控制的数据结构及处理（就进城管理、存储器管理和设备管理） 综上，和心态指令实际上包括系统调用类指令和一些针对时钟、中断和原语的操作指令。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.3.2 中断和异常 中断：外中断，来自CPU执行指令以外的事件的发生。包括外设请求和人为干预 异常：内中断，源自CPU执行指令内部的事件。（访存时缺页中断属于异常） ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.3.3 系统调用 系统调用是用户在程序中调用操作系统所提供的一些子功能。 系统调用运行在系统的和心态，通过系统调用的方式来使用系统功能。 执行系统调用的过程如下：先传递系统调用参数，然后由trap指令负责将用户态转为内核态，并将返回地址压入堆栈中备用，接下来CPU执行相应的内核态服务程序，最后返回用户态。 错题： 子程序调用只需要保存程序断点，即该指令的下一条指令的地址。中断调用子程序不仅要保护断点（PC），还要保护程序状态字寄存器PSW。（通用数据寄存器和通用地址寄存器不在子程序工作的保存范围之内，如果要保存则是由操作系统自行保存） 外部中断处理过程中，PC值由中断隐指令自动保存，而通用寄存器内容由操作系统保存。 为什么说引入中断技术后多道程序系统才有用？ 通道技术和中断技术结合起来可以实现CPU与IO设备的并行工作，此时，多道程序的概念才变为现实。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:3:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.4 操作系统的体系结构 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:4:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.4.1 大内核和微内核 大内核：主要功能模块作为紧密整体运行在核心态，系统服务的性能高. 微内核：解决代码难以维护的问题，只保留最基本的功能，即交互通过微内核进行通信。性能较差，需要频繁地在用户态与核心态之间进行切换。 第二章 进程管理 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:4:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1 进程与线程 PCB：进程控制块，进程存在的唯一标志。系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。 进程映像=程序段、相关数据段和PCB（进程实体）。进程映像是静态的，而PCB是动态的。 动态性是进程的最基本特征。 进程状态：运行状态、就绪状态（缺少处理机）、阻塞状态/等待状态（等待事件，一般是IO）、创建状态（申请空白PCB，分配必要资源后转为就绪状态，资源不足而创建失败则进入阻塞状态）、结束状态 进程终止、阻塞和唤醒略过 进程切换：实质上改变了进程的运行环境 保存处理机上下文，包括程序计数器和其他寄存器（保证后面再次调入时环境一致） 更新PCB信息 把进程的PCB移入相应的队列 选择另一进程进行执行并更新其PCB 更新内存管理的数据结构 恢复处理机上下文 PS：进程切换不同于处理机切换。如果进程因中断或异常进入到核心态运行，恢复的时候只需要恢复CPU现场；进程切换不只是恢复CPU现场，还要改变当前进程的环境信息。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1.4 进程=PCB+程序段+数据段 PCB在创建后就会常驻内存，是进程实体的一部分，是进程存在的唯一标志。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1.5 进程的通信 共享存储：两个进程之间共享同一块存储空间，需要使用同步互斥工具进行访问。 消息传递：使用操作系统提供的消息传递方法实现。 管道通信：管道是指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，只能采用半双工，即同一时刻只能单向通信。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1.6 线程概念和多线程模型 如果说进程是资源分配的基本单元，那么线程就是CPU执行的基本单元。 线程是独立调度的基本单元，同一进程的线程之间的切换不会引起进程切换。 线程可以直接读写数据段（全局变量）进行通信 线程分为用户级线程和内核级线程，执行核心态指令只能通过内核级线程。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:5:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2 进程调度 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2.1 调度的概念 三级调度：作业调度、中级调度和今晨调度 作业调度：从外存向内存调度，一般用于批处理系统，其他系统中通常不配置。 中级调度：又称为内存调度，将暂时不能运行的内存调至外存等待。目的是提高内存利用率和系统吞吐量 进程调度：又称低级调度，分配处理机，频率很高。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2.2 调度的时机、切换与过程 不能进行进程的调度与切换的情况： 在处理中断的过程中 进程在操作系统内核程序临界区中（不是访问临界资源）：进入临界区后，需要独占式地访问共享数据，理论上必须加锁，以防止其他并行程序进入，在解锁前不应切换到其他进程运行，以加快该共享数据的释放。 其他需要完全屏蔽中断的原子操作过程中：连中断都要屏蔽，更不应该进行进程调度。 如果此时发生了引起调度的条件，需要能到上述过程结束后才能够调度。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2.3 进程调度方式 非剥夺式 剥夺式 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2.4 调度的基本准则 评价处理机调度算法的性能的指标 系统吞吐量：表示单位时间内CPU完成作业的数量 周转时间：指从作业提交到作业完成所经历的时间，包括在作业等待、在就绪队列中排队、在处理机上运行以及进行输入/输出操作所花费时间的总和。 等待时间：指进程处于等处理机状态时间之和。处理机调度算法并不影响作业执行或输入输出的时间，而是影响等待时间，因此等待时间是衡量一个调度算法优劣的重要参数。 响应时间：指从用户提交请求到系统首次产生响应所用的时间。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:4","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2.5 典型的调度算法 FCFS，每次从就绪队列中调度最先进入队列的进程 SJF，短作业优先，从后备队列中选择一个运行时间时间最短的进程 优先级调度算法，从后备队列中选择一个优先级最高的作业 高响应比调度算法：考虑到每个作业的等待时间和估计的运行时间。响应比=(等待时间+要求服务时间)/要求服务时间。在有利于短作业的同时兼顾了长作业（克服了饥饿状态） 时间片轮转算法：先到先服务，每人一个时间片(round robin)。时间片的性能对调度算法的影响很大 多级反馈队列算法（综合了前面所有的优点） 思想： 多个就绪队列与不同的优先级，第1级队列的优先级最高 赋予各个队列中进程执行时间片的大小也各不相同。优先级越高的队列，每个进程分到的时间片就越小。第2级队列的时间片比第1级队列的时间片长1倍。 当一个新进程进入内存后，先将其放入第1级队列的队尾。如果一个时间片后没有执行完，则放在第2级队列的队尾，依次类推。 仅当第1级队列为空时调度程序会调度第2级队列。 终端型作业用户：短作业优先 短批处理作业用户：周转时间较短 长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理 选择题部分： 为了合理设置进程优先级，一般需要考虑进程的CPU时间和IO时间。对于优先级调度算法，IO型作业的优先级要高于计算型作业的优先权，因为IO操作需要及时完成，没有办法撑起保存所需要输入输出的数据。 对于时间片轮转算法，当前进程的时间片用完后，它的状态由执行态变为就绪态；同时现代操作系统为了保证性能最优，通常会根据响应时间、系统开销、进程数量、进程运行时间、进程切换开销等因素来确定时间片的大小。 当进程处于临界区时，说明进程正在占用处理机，只要不破坏临界资源的使用规则，是不会影响处理机调度的。比如，通常访问的临界资源可能是慢速的外设（比如打印机），如果在进程访问打印机的情况下，不能进行处理机的调度，那么系统的性能将会变得很差。 在分析题中可能出现一些涉及到原理的题目（处理机调度的原理，饥饿的产生条件等） 2016年联考真题：某进程调度程序采用基于优先数(priority)的调度策略，即选择优先数最小的进程运行，进程创建时由用户指定一个nice作为静态优先数。为了动态调整优先数，引入运行时间cpuTime和等待时间waitTime，初值均为0.进程处于执行态时，cpuTime定时加1，且waitTIme定时置0；进程处于就绪态时，cpuTime置0，waitTime定时加1.请回答下列问题。 若调度程序只将nice的值作为进程的优先数，即priority=nice，则可能会出现饥饿现象，为什么？ 使用nice、cpuTime和waitTime设计一种动态优先数计算方法，以避免产生饥饿现象，并说明waitTime的作用。 1 答：由于采用了静态优先数，当就绪队列中总有优先数较小的进程时，优先数较大的进程一直没有机会运行，因而会出现饥饿现象。 2 答：priority=nice+k1*cpuTime-k2*waitTime，其中k1\u003e0，k2\u003e0，用来分别调整cpuTime和waitTime在priority中所占的比例。waitTime可使长时间等待的进程优先数减少，避免出现饥饿现象。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:6:5","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3 进程同步 绝对重点！！！ ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.1 进程同步的基本概念 临界资源：一次仅允许一个进程使用的资源 临界区：访问临界资源的代码 进入区：为了进入临界区使用临界资源，在进入区检查可否进入临界区 临界区：进程中访问临界资源的代码 退出区：将正在访问临界区的标志清除 剩余区：代码中其他部分 同步：直接制约关系 互斥：间接制约关系 为了禁止两个进程同时进入临界区，准则： 空闲让进 忙则等待 有限等待 让权等待：当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.2 实现临界区互斥的基本方法 软件实现方法： 单标志法：设置一个公用整形变量，用于指示被允许进入临界区的进程编号。 可以确定每次只允许一个个进程进入临界区，但违背空闲让进（如果某个进程不再进入临界区，另一个进程也无法进入） P0: while(turn!=0); critical section; turn = 1; remainder section; P1: while(turn!=1); critical section; turn = 0; remainder section; 双标志先检查。每一个进程在访问临界区资源之前，先查看一下临界资源是否正在被访问。如果正在被访问，则等待，否则进程才进入自己的临界区。数组flag，flag[i]=FALSE表示Pi进程没有进入临界区。 Pi进程： while(flag[j]); flag[i]=TRUE; cirical section; flag[i] = FALSE; remainder section; Pj进程： while(flag[i]); flag[j]=TRUE; cirical section; flag[j] = FALSE; remainder section; 优点：不用交替进入，可以连续使用 缺点：Pi和Pj可能同时进入临界区，同时通过循环等待认证，违背忙则等待原则。 双标志后检查。先设置自己标志为TRUE后，再检测对方标志 Pi进程： flag[i]=TRUE; while(flag[j]); cirical section; flag[i] = FALSE; remainder section; Pj进程： flag[j]=TRUE; while(flag[i]); cirical section; flag[j] = FALSE; remainder section; 有可能导致饥饿现象：两个进程都想进入临界区，结果大家都进不去。 Peterson’s Algorithm Pi进程 flag[i]=TRUE; turn = j; while(flag[j] \u0026\u0026 turn == j); critical section; flag[i] = FALSE; remainder section; Pj进程 flag[j] = TRUE; turn = i; while(flag[i]\u0026\u0026turn == i); critical section; flag[j] = FLASE; remainder section; 利用flag解决临界资源访问，利用turn解决饥饿现象。 硬件实现： 中断屏蔽方法：直接禁止一切中断发生，避免发生进程调度，这样就能保证当前进程顺利将临界区代码执行完。但是限制了处理机交替执行程序的能力，因而执行的效率会明显降低。 硬件指令方法 TestAndSet指令，原子操作。 boolean TestAndSet(boolean *lock){ boolean old; old = *lock; *lock = true; return old; } 使用一个共享的lock来执行互斥 while TestAndSet(\u0026lock); 执行临界区 lock = false; 剩余区； Swap指令：交换两个字的内容。lock为共享变量，初值为false。key为局部变量 Swap(boolean *a,boolean *b){ boolean temp; temp = *a; *a = *b; *b = temp; } 使用的时候 key = true; while(key!=false) Swap(\u0026lock,\u0026key); 进程临界区 lock = false 剩余区 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.3 信号量 两个原语 P操作：wait V操作：signal 整形信号量，被用于定义一个用于表示资源数目的整型量S wait(S){\rwhile(S\u003c=0);\rS=S-1;\r}\rsignal(S){\rS=S+1;\r} 并未遵循让权等待，而是处于忙等 2.记录型信号量：不存在忙等现象。除了需要一个用于代表资源数目的整型变量value外，还需要一个进程链表L，用于链接所有等待该资源的进程。 typedef struct{ int value; struct process *L; }semaphore; void wait(semaphore S){//相当于申请资源 S.value--; if(S.value\u003c0){ add this process to S.L; block(S.L); } } void signal(semaphore S){//相当于释放资源 S.value++; if(S.value\u003c=0){ remove a process P from S.L; wakeup(P) } } 利用信号量实现同步 semaphore S=0; P1(){ ... x; V(S); ... } P2(){ ... P(S); y; ... } 初始S=0，如此，P2会阻塞，直到P1x执行完之后，y才会执行，实现了同步。 利用信号量实现互斥 semaphore S=1; P1(){ ... P(S) P1临界区; V(S); ... } P2(){ ... P(S); P2临界区; V(S) ... } 在互斥问题中，P、V操作要紧紧夹着使用互斥资源的那个行为，中间不能有其他冗余代码。 利用信号量实现前驱关系 初始化所有信号量为0，对每一条边设置一个信号量，在这条边的源点进程进行V，在后继进程进行P ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.5 经典同步问题 生产者消费者问题 关系问题：生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者的消费者又是一个相互协作的关系，是同步关系。 信号量设置：mutex作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初始为1；信号量full用于记录当前缓冲池中”满“缓冲区数，初值为0.信号量empty用于记录当前缓冲区中”空“缓冲区数，初值为n semaphore mutex = 1;//临界区互斥变量 semaphore empty = n;//空闲缓冲区数量 semaphore full = 0;//缓冲区初始化为空 producer(){ while(1){ produce an item in nextp;//生产数据 P(empty);(要用什么，P一下)//获取空缓冲区单元 P(mutex);//进入临界区 add nextp to buffer; V(mutex);//离开临界区 V(full);（提供什么，V一下）//满缓冲区数量加1 } } consumer(){ while(1){ P(full);//获取满缓冲区单元 P(mutex); remove an item from buffer;//从缓冲区中取出数据 V(mutex); V(empty);//空缓冲区数加1 consume the item//消费数据 } } 较为复杂的生产者-消费者问题 描述：桌上有一只盘子，每次只能放入一个水果。爸爸专门向盘中放苹果，妈妈专门向盘中放橘子；儿子专等吃橘子，女儿专等着吃苹果。只有盘子为空时，爸爸或妈妈才可以放入一个水果；仅当盘中有自己需要的水果时，儿子或女儿可以从盘子中取出。 信号量设置：互斥信号量plate，表示是否允许向盘中放入水果。apple=0，表示盘中是否有苹果，orange=0，表示盘中是否有橘子 semaphore plate = 1,apple = 0,orange = 0; dad(){ while(1){ prepare an apple; P(plate); put the apple on the plate; V(apple); } } mom{ while(1){ prepare an orange; P(plate); put the orange on the plate; V(orange); } } son(){ while(1){ P(orange); take an orange from the plate; V(plate); eat the orange; } } daughter(){ while(1){ P(apple); take an apple from the plate; V(plate); eat the apple } } 读者-写者问题 有读者和写者两组进程，共享一个文件。两个或以上读进程同时访问时没有问题，写进程和其他进程同时访问共享数据时则可能导致数据不一致的错误。要求1.允许多个读者同时对文件进行读操作。2.只允许一个写者往文件中写信息。3.任一写者在完成写操作之前不允许其他读者或写者工作。4.执行写操作前，应让已有的读者和写者全部退出。 信号量设置：count为计数器，用来记录当前读者数量；mutex为互斥信号量，保护count变量的更新；互斥信号量rw用于保证读者和写者的互斥访问。 读者优先（存在写进程饥饿的现象） int count=0; semaphore mutex = 1; semaphore rw = 1; writer(){ while(1){ P(rw);//互斥访问共享文件 writing;//写入 V(rw);//释放共享文件 } } reader(){ while(1){ P(mutex);//互斥访问count变量 if(count==0){//当第一个读进程共享文件时 P(rw);//阻止写进程写 } count++; V(mutex);//释放互斥变量count reading; P(mutex);//互斥访问变量count count--;//读者计数器减1 if(count==0)//当最后一个读进程读完共享文件时 V(rw);//允许写进程写 V(mutex);//释放互斥变量count } } 写者优先，增加了一个信号量以及一个P、V操作，在有写进程的请求时不允许读进程进行 int count=0; semaphore mutex = 1; semaphore rw = 1; //new add semaphore w= 1;//用于实现写优先 writer(){ while(1){ P(w);//在无写进程请求时进入 P(rw);//互斥访问共享文件 writing;//写入 V(rw);//释放共享文件 V(w);//恢复对共享文件的访问 } } reader(){ while(1){ P(mutex);//互斥访问count变量 if(count==0){//当第一个读进程共享文件时 P(rw);//阻止写进程写 } count++; V(mutex);//释放互斥变量count reading; P(mutex);//互斥访问变量count count--;//读者计数器减1 if(count==0)//当最后一个读进程读完共享文件时 V(rw);//允许写进程写 V(mutex);//释放互斥变量count } } 哲学家进餐问题 一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆着一根筷子。在哲学家饥饿的时候，会试图拿到两根筷子， 如果筷子在其他人手中则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后会放下筷子继续思考。 信号量设置：互斥信号量组chopstick[5]={1,1,1,1,1}，用于对5个筷子的互斥访问 semaphore chopstick[5]={1,1,1,1,1};//定义信号量数组chopstick[5]并初始化 Pi(){//i号哲学家的进程 do{ P(chopstick[i]); P(chopstick[(i+1)%5]); eat; V(chopstick[i]); V(chopstick[(i+1)%5]); think; }while(1); } 问题，可能会出现死锁。 使用AND型信号量机制来解决哲学家进餐问题 semaphore chopstick[5]={1,1,1,1,1};//定义信号量数组chopstick[5]并初始化 semaphore mutex = 1;//设置取筷子的信号量 Pi(){//i号哲学家的进程 do{ P(mutex); P(chopstick[i]); P(chopstick[(i+1)%5]); V(mutex); eat; V(chopstick[i]); V(chopstick[(i+1)%5]); think; }while(1); } 吸烟者问题 一个系统有三个吸烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽调它，卷起一根烟需要三种材料：烟草、纸张和胶水。供应者每次放两种材料到桌子上，拥有剩下那种材料的抽烟者卷起它，并告诉供应者一个信号告诉完成了，供应者就会继续放两种材料，如此重复。 信号量设置：offer1-3表示缺少胶水、缺少纸张和缺少烟草的资源，finish互斥抽烟动作 int random; semaphore offer1=0; semaphore offer2=0; semaphore offer3=0; semaphore finish=0; process P1(){ while(1){ random = 随机整数 random = random%3; if(random==0) V(offer1); else if(random==1) V(offer2); else if(random==2) V(offer3); P(finish); } } process P2(){//拥有烟草者 while(1){ P(offer3); 卷烟，抽掉 V(finish); } } process P3(){//拥有纸张者 while(1){ P(offer2); 卷烟，抽掉 V(finish); } } process P4(){//拥有胶水者 while(1){ P(offer1); 卷烟，抽掉 V(finish); } } ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:4","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.4 管程 定义：管程由一组数据以及定义在这组数据之上的对这组数据的操作组成的软件模块，这组数据能初始化并改变管程中的数据和同步进程。 组成： 局部于管程的共享结构数据说明 对该数据结构进行操作的一组过程 对局部于管程的共享数据设置初始值的语句 基本特性：（类似抽象类，由编译程序负责互斥操作，不用程序员关注，而且保证正确） 局部于管程的数据只能被局部于管程内的过程所访问 一个进程只有通过调用管程内的进程才能进入管程访问共享数据 每次仅允许一个进程在管程内执行某个内部过程。 题目 [2016-32]下列关于管程的叙述，错误的是 A. 管程只能够用于实现进程的互斥 B. 管程是由编成语言支持的进程同步机制 C. 任何时候只能有一个进程在管程中被执行 D. 管程中定义的变量只能被管程内的过程访问 答案选A，显然，管程不仅能实现进程的互斥，还可以实现进程的同步。 我在选的时候比较纠结的是C选项，第一次知道任何时候只能有一个进程在管程中被执行。 2019-28 若x是管程内的条件变量，则当进程执行x.wait()时所做的工作是（） A. 实现对变量x的互斥访问 B. 唤醒一个在x上阻塞的进程 C. 根据x的值判断该进程是否进入阻塞状态 D. 阻塞该进程，并将之插入x的阻塞队列中 解析：D。“条件变量”是管程内部说明和使用的一种特殊变量，其作用类似于信号量机制中的“信号量”，都是用于实现进程同步的。需要注意的是，在同一时间内，管程中只能有一个进程在执行。如果进程A执行了x.wait()操作，那么该进程会阻塞，并挂到条件变量x对应的阻塞队列上。这样，管程的使用权会被释放，就可以有另一个进程进入管程。如果B执行了x.signal()操作，那么会唤醒x对应的阻塞队列队头进程。在Psacal语言的管程中，规定只有一个进程要离开管程的时候才能调用signal()操作。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:7:5","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.4 死锁 同样是非常核心 注意四个必要条件，只要任一条件不成立，死锁就不会发生： 互斥条件 不剥夺条件 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求。 循环等待条件：存在一个进程的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。 其中循环等待条件比较容易弄混，死锁定义上要求等待环严格有序，循环等待没有这个要求。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.4.2 死锁的处理策略 预防死锁 避免死锁 死锁的检测与解除 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.4.3 死锁预防 破坏四个必要条件中的一个 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.4.4 死锁避免 在资源动态分配过程中，防止系统进入不安全状态，以避免死锁。 系统安全状态：指系统能够按照某种进程推进顺序，为每个进程分配其所需要的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序地完成，此时称这个序列为安全序列。如果系统无法找到一个安全序列，则系统处于不安全状态。 使用银行家算法可以找到安全序列，从而判断系统是否处于安全状态。 银行家算法 数据结构： 可利用资源矢量Available，Available_j=K表示系统中现有Rj类资源有K个 最大需求矩阵Max：Max[i,j]=K表示进程i需要Rj类资源的最大数目为K 分配矩阵Allocation：Allocation[i,j]=K，表示进程i已经分配Rj类资源为K 需求矩阵Need：Need[i,j]=K，表示进程i还需要Rj类资源的数目为K 其中Need=Max-Allocation 具体步骤： 得到Request_i为进程Pi的请求矢量，Request_i[j]=K，表示进程i对Rj的请求为K个。 进行两重检查。如果Request_i[j]\u003eNeed[i,j]，即请求的比预先需求的还多，报错；如果Request_i[j]\u003eAvailable[j]，此时大于系统剩余资源量，报错。 试探性将资源分配给进程，修改各个数据结构 执行下列安全性算法，如果系统处于安全状态，则完成分配。不然本次分配作废，数据结构恢复。 安全性算法： 初始时安全序列为空 从Need矩阵中找到符合下面要求的行：该行对应的进程不在安全序列中而且该行小于等于Available向量（即系统的资源足够满足该进程的所有资源需求） 将该进程加入到安全序列中，释放它的所有资源。 重复 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.4.5 死锁检测和解除 资源分配图 用圆圈代表一个进程，用框代表一类资源。 从资源指向进程，表示分配。 从进程指向资源，表示申请。 死锁定理 通过资源分配图简化可以检测系统状态是否为死锁状态。 在资源分配图中，找到一个点（有一条有向边与之相连，且该有向边对应的资源申请数小于系统中已有空闲资源数量，就是可以放掉的进程），消去它的所有请求边和分配边 重复，如果能消去图中所有的边，则称该图是可以完全简化的。 死锁解除： 资源剥夺法：挂起死锁进程，抢占它的资源 撤销进程法：强行撤销部分、甚至全部死锁进程并剥夺这些进程的资源 进程回退法：让一个或多个进程回退到足以回避死锁的地步。 第3章 内存管理 物理空间划分多个页框，逻辑空间划分多个页，一个页框一般只有一个页，所以页大小和页框大小是相等的 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:8:4","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1 内存管理 重点： 分页和分段，特别是逻辑地址到物理地址的映射，有时会和计算机组成原理的部分知识一起出题。 ！需要多看，为什么要使用TLB，为什么要使用多级页表，以及一些相关的推导，最好能自己手动推一下。 PS：这应该是计组的知识，TLB是相联存储器，又称为关联存储器，是按内容寻址而不是按地址寻址的存储器。 需要注意的是，TLB中的虚地址和对应数据的地址直接的关系可以是任意的，直接相联、组相联、全相联都可以，需要取决于具体的题意才能够确定。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:9:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"如何确立页表项的大小 页表项的作用是找到该页在内存的位置。 以32位逻辑地址空间，字节为编址单位，一页4KB为例。 地址空间中总共有2^32B/4B=2^30=1M页，所以需要log2(1M)=20位才能够保证范围能容纳所有页面。 又以字节为编址单位，即页表项的大小\u003e=ceil(20/8)=3B 因此，为了保证页表项能够指向所有页面，页表项的大小应该大于等于3B，一般取2的整数，比如4B。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1.4 非连续分配管理方式 段页式逻辑地址：段号+页号+页内偏移量 计算上有： 逻辑地址结构，以及从结构中产生的一些计算。需要重点掌握的有页和段的论述部分。 段地址=段号+段内偏移量，所以2^段内偏移量=段的最大大小 计算页表的一些信息，比如逻辑地址=页目录号+页号+页内偏移量，已经知道逻辑地址空间大小有2^16页，页大小为2^10字节，页表项为2字节，那么表示整个逻辑地址空间的页目录表中包含表项的个数至少是128. 解析：页的大小是2^10B，而页表项大小为2B，所以一页可以存放2^9个页表项。逻辑地址空间大小为2^16页，需要2^16个页表项目，需要2^7=128个页面来保存页表项。 类似页的结构：现有一个容量为10GB的磁盘分区，磁盘空间以簇为单位进行分配，簇的大小为4KB。若采用位图法管理该分区的空闲空间，即用一位(bit)标识一个簇是否被分配，则存放该位图所需簇为（）个 显然簇的总数为2.5M，共需要2.5M位标识，也就是320KB，320KB/4KB=80个簇 2010年真题 若计算机主存按字节编址，逻辑地址和物理地址都是32位，页表项大小为4字节。请回答下列问题： 若使用一级页表的分页存储管理方式，逻辑地址结构为：页号（20位）+页内偏移量（12位）。则页的大小是多少字节？页表最大占用多少字节？ 若使用二级页表的分页存储管理方式，逻辑地址结构为：页目录号（10位）+页表索引（10位）+页内偏移量（12位），设逻辑地址为LA，请分别给出其对应的页目录号和页表索引的表达式。 采用1中的分页存储管理方式，一个代码段起始逻辑地址为0000 8000H，其长度为8KB，被装载到从物理地址0090 0000H开始的连续主存空间中。页表从主存0020 0000H开始的物理地址处连续存放，如下图所示（图1， 地址大小自下向上递增 ）。请计算出该代码段对应的两个页表项的物理地址、这两个页表项中的页框号以及代码页面2的起始物理地址 答： 因为主存按字节编址，页内偏移量12位，所以页的大小2^12B=4KB，页表项数位2^20，故该一级页表最大为2^20*4B=4MB 页目录号为(((unsigned int)(LA))»22) \u0026 0x3ff 页表索引为(((unsigned int)(LA))»12) \u0026 0x3ff 代码页面1的逻辑地址为0000 8000H，表明其位于第8个页处，对应页表中第8个页表项，所以第8个页表项的物理地址=页表起始地址+8*页表项的字节数=00200000H+8*4=00200020H 得到答案 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:10:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2 虚拟内存管理 虚拟存储器的概念：实际上并不存在，只是由于系统提供了部分操作，使得用户感觉好像存在一个比实际物理内存大得多的存储器。 虚拟存储器的大小由计算机的地址结构决定，而非是内存和外存的简单相加。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.2 请求分页管理方式 请求分页管理方式不同于基本分页系统，在一个作业运行之前不要求全部一次性调入内存。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.3 页面置换算法 决定应该换入哪页，换出哪页 最佳置换算法OPT，淘汰的算法是在最长时间内不再访问的算法。不可实现。 FIFO，队列类算法，最先进入最先淘汰 LRU，最近最少使用算法，堆栈类算法。选择最近最长时间未访问过的页面进行淘汰，实现上需要寄存器和栈的硬件支持。 时钟置换算法（简单时钟）：第一次装入置1、访问到置1，循环置0。使用时会替换掉置0的第一个。性能接近LRU 复杂CLOCK。\u003c访问位，修改位\u003e，显然，先置换未访问未修改，然后是未访问已修改，已访问未修改，已访问已修改。 Belady异常，仅FIFO情况下会出现，分配的物理块数量增加，页故障数反而会增加。（先减后增） ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.3 操作系统页面分配策略 固定分配局部置换：为每个进程分配固定数目的物理块。问题在于难以确定每个进程需要多少个物理块。 可变分配全局置换：进程分配一定数目的物理块，系统维护空闲物理块队列，缺页时从队列中取出一个给该进程。缺点是可能盲目增加物理块，将导致系统多道程序并发能力下降。 可变分配局部置换：每个进程分配以一定数目的物理块，缺页时只能从内存中选一页换出。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.4 页面分配策略 从何处调入页面：外存分为两部分，用于存放文件的文件区（离散分配，访问较慢）、用于存放对换页面的对换区（连续分配，访问较快） 系统拥有足够的对换区空间：全部走对换区。运行前进程有关文件被复制到文件区 没有足够多对换区空间：不会被修改的文件走文件区；换出后走对换区 UNIX方式：与进程有关的文件都放在文件区，所以未运行过的页面都走文件区。曾经运行过但又被换出的页面放在对换区。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:4","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.6 工作集 工作集(驻留集)：指某段时间内，进程要访问的页面集合。 比如工作集大小为6，即前6个被访问过的页面的集合（去重） 工作集模型防止抖动：让操作系统跟踪每个进程的工作集，并为每个进程分配大于其工作集的物理块。如果所有工作集之和超过可用物理块的总数，则将页面调出并将物理块分配给其他进程以防止抖动。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:5","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.7 地址翻译 书上199自己看。 2009年真题 请求分页管理系统中，假设某进程的页表内容如下图 页面大小为4KB，一次内存的访问时间是100ns，一次快表（TLB）的访问时间是10ns，处理一次缺页的平均时间是10^8ns（已经包含了更新TLB和页表的时间），进程的驻留集大小固定为2，采用最近最少使用置换算法（LRU）和局部淘汰策略。假设1.TLB初始为空；2.地址转换时先访问TLB，若TLB未命中，再访问页表（忽略访问页表之后的TLB更新时间）；3.有效位为0表示页面不在内存，产生缺页中断，缺页中断处理后，返回到产生缺页中断的指令处重新执行。设有虚地址访问序列2362H、1565H、25A5H，请问： 1 依次访问上述三个虚拟地址，各需多少时间？给出计算过程 2 基于上述访问序列，虚地址1565H的物理地址是多少？请说明理由 解： 1 根据页式管理的工作原理，应当首先考虑页面大小，以便将页号和页内偏移分离。页面大小为4KB，即页内偏移为12位，页号占据高位。可以得到页号： 2362H：P=2，访问快表10ns，初始为空，访问页表100ns得到页框号，合成物理地址之后访问主存100ns，合计210ns 1565H：P=1，访问快表10ns，落空；访问页表100ns，落空；缺页中断10^8ns，再次访问快表，合成物理地址之后访问主存100ns，合计100000220ns 25A5H：P=2，访问快表，因为第一次访问的时候将页号放入TLB，命中；访问主存，100ns，合计110ns 2 访问虚地址1565H时，产生缺页中断，合法驻留集为2，因此必须从页表中淘汰一个页面。根据置换算法，淘汰0号页面，因此1565H的对应页框号为101H。由此得到物理地址101565H 容易漏掉的知识：驻留集（工作集）是指某段时间间隔内，进程要访问的页面集合。经常被使用的页面需要在工作集中，而长期不被使用的页面要从工作集中被丢弃。 2012年真题 某请求分页系统的页面置换策略如下： 从0时刻开始扫描，每隔5个时间单位扫描一轮驻留集（扫描时间忽略不计）且在本轮没有被访问过的页框将被系统回收，并放入到空闲页框链尾，其中内容在下一次分配之前不清空。当发生缺页时，如果该页曾被使用过且还在空闲页框链表中，则重新放回进程的驻留集中；否则，从空闲页框链表头部取出一个页框。 忽略其他进程的影响和系统开销。初始时进程驻留集为空。目前系统空闲的页框号依次为32、15、21、41.进程P依次访问的\u003c虚拟页号，访问时刻\u003e为\u003c1,1\u003e、\u003c3,2\u003e、\u003c0,4\u003e、\u003c0,6\u003e、\u003c1,11\u003e、\u003c0,13\u003e、\u003c2,14\u003e。请回答下列问题。 1 当虚拟页为\u003c0,4\u003e时，对应的页框号是什么？ 2 当虚拟页为\u003c1,11\u003e时，对应的页框号是什么？说明理由。 3 当虚拟页为\u003c2,14\u003e时，对应的页框号是什么？说明理由。 4 这种方法是否适合于时间局部性好的程序？说明理由 原因：不太会写为什么 解答： 1 页框号为21.因为起始驻留集为空，0页对应的是空闲链表中第三个空闲页框，其对应的页框号为21. 2 页框号为32.理由：11\u003e10，故发生第三轮扫描，页号为1的页框已经在第二轮处于空闲页框链表中，此时该页被重新访问，因此应被重新放回驻留集中，其页框号为32. 3 页框号为41。理由：因为第2页从来没有被访问过，它不在驻留集中，因此从空闲页框链表中取出链表头的页框41，页框号为41 4 合适。理由：如果程序的时间局部性越好，从空闲页面链表中重新取回的机会越大，该策略的优势就越明显。 2015年真题 某计算机系统按字节编址，采用二级页表的分页存储管理方式，虚拟地址格式如下：页目录号（10位）+页表索引（10位）+页内偏移量（12位） 请回答以下问题 1 页和页框大小各为多少字节？进程的虚拟地址空间大小为多少页？ 2 假定页目录项和页表项均占4个字节，则进程的页目录和页表共占多少页？要求写出计算过程。 3 若某指令周期内访问的虚拟地址为0100 0000H和0111 2048H，则进行地址转换时共访问多少个二级页表？要求说明理由。 解答： 1 页和页框大小均为4KB，进程的虚拟地址空间大小为2^32/2^12=2^20页 2 (2^10 * 4)/2^12(页目录所占页数)+(2^20*4)/2^12(页表所占页数)=1025页 3 需要访问一个二级页表。因为虚拟地址0100 0000H和01112048的最高10位的值都是4，访问的是同一个二级页表。 容易遗漏的知识： 分页单元把所有的RAM分成固定长度的页框，每个页框对应一个页，所以一个页与一个页框的长度是一致的。页是逻辑地址上的划分，页框是物理地址上的划分。 第四章 文件系统 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:11:6","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1 文件系统基础 在系统运行时，计算机以进程为基本单位进行资源的调度和分配。 与之对应，在用户进行的输入、输出中，以文件为基本单位。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1.3 目录结构 文件控制块FCB：用来存放控制文件需要的各种信息的数据结构。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1.4 文件共享 基于索引结点的共享方式（硬链接）：文件目录存在指针，指向同一个索引节点（带有计数器和文件物理地址） 利用符号链实现文件共享（软链接）：文件目录中创建新的文件，只包含被链接文件的路径名。称为符号链接。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1.5 访问控制 最普通的方式时为每个文件和目录增加一个访问控制列表。优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理。 精简的访问列表采用拥有者、组和其他用户三种用户类型。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:12:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2 文件系统实现 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:13:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2.1 文件系统层次结构 笔记本上有，略过。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:13:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2.2 目录实现 线性列表：最简单的目录实现方式是使用存储文件名和数据块指针的线性表。 哈希表：哈希表根据文件名得到一个值，并返回一个指向线性表中元素的指针。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:13:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2.3 文件实现 文件分配方式： 连续分配：要求每个文件在磁盘中占有一组连续的块。这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。支持顺序访问和直接访问，实现简单；缺点在于文件长度不宜动态增加，而且反复增删文件会产生外部碎片。 链接分配：采用离散分配的方式，消除外部碎片，显著提高磁盘空间利用率。实现是使用一个表格，指明文件的开始指针和结尾指针，中间用链表实现。缺点是无法直接访问盘块，只能够通过指针顺序访问文件，中间有损坏会导致文件数据的丢失。（延伸出FAT，文件分配表会将分配给文件的所有盘块号放在该表中，需要时导入内存里，可以大大减少访问磁盘的次数） 索引分配：将每个文件的所有盘块号放在一起构成索引块 文件存储空间管理 文件存储设备的管理实质上是对空闲块的组织和管理。 空闲块的组织、分配与回收问题： 空闲表法：连续分配方式，系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应于一个空闲表项，包括表序号、第一个空闲盘块号、空闲盘块数。 空闲链表法：将所有空闲盘区拉成一条空闲链（空闲盘块链/空闲盘区链，每个盘区可以包含多个盘块） 位示图法：利用二进制的一位来表示磁盘中一个盘块的使用情况。盘块的分配时就会顺序扫描位示图，找到值为0的二进制为，计算出位置，并修改位示图。 成组链接法：空闲表法和空闲链表法都不适合用于大型文件系统，因为表长会过长。UNIX使用这种方法，思想是把顺序地n个空闲扇区地址保存在第一个空闲扇区中，其后一个空闲扇区则保存另一顺序空闲扇区的地址，如此继续。通过这种方式可以快速找到大批空闲块地址。 2010年真题 设文件索引结点中有7个地址项，其中4个地址项是直接地址索引，2个地址项是一级间接地址索引，1个地址项是二级间接地址索引。每个地址项大小是4B，若磁盘索引块和磁盘数据块大小均为256B，则可表示的单个文件最大长度是（） A.33KB B.519KB C.1057KB D.16516KB 解析：每个索引块大小为256B，每个磁盘索引块有256/4=64个地址项。 因此，4个直接地址索引指向的数据块大小为4*256B 2个一级间接索引包含的直接地址索引数为4*(256/4) 1个二级间接索引包含的直接地址索引数为4*(256/4)*4*(256/4)，所指向的块的大小再乘256B 总计1057B，选C 2015年真题 在文件的索引节点中存放直接索引指针10个，一级和二级索引指针各1个。磁盘块大小为1KB，每个索引指针占4个字节。若某文件的索引节点已在内存中，则把该文件偏移量（按字节编址）为1234和307400处所在的磁盘块读入内存，需访问的磁盘块个数为（） A. 1,2 B.1,3 C.2,3 D.2,4 解析：B 10个直接索引指针所指向的数据块的大小为10*1KB=10KB 每个索引指针占4B，则每个磁盘块可存放1KB/4B=256个索引指针 一级索引指针指向的数据块大小为：256*1KB=256KB 二级索引指针指向的数据块大小为：2562561KB=2^16KB=64MB 按字节编址，1234B\u003c10KB，则由直接索引指针可得到其所在的磁盘块地址。文件的索引节点已在内存中，则地址可直接得到，故仅需1次访存 偏移量为307400时，因为10KB+256KB\u003c307400B\u003c64MB，可知该偏移量的内容在二级索引指针所指向的某个磁盘块中，索引节点已在内存中，故先访盘2次得到文件所在的磁盘块地址，再访盘1次即可读出内容，故共需3次访盘 2015年真题 文件系统用位图法表示磁盘空间的分配情况，位图存于磁盘的32-127号块中，每个盘块占1024个字节，盘块和块内字节从0开始编号。假设要释放的盘块号为409612，则位图中要修改的位所在的盘块号和块内字节序号分别为（） A.81、1 B.81、2 C.82、1 D.82、2 解析：盘块号=起始块号+ceil(盘块号/(1024*8))=32+50=82 块内字节号而不是位号，=ceil((盘块号%(1024*8))/8)=1 2011年联考复习指导 某文件系统为一级目录结构，文件的数据一次性写入磁盘，已写入的文件不可修改，但可多次创建新文件。请回答以下问题： 1 在连续、链式、索引三种文件的数据块组织方式中，哪种更合适？要求说明理由。为定位文件数据块，需要FCB中设计哪些相关描述字段？ 2 为快速找到文件，对于FCB，是集中存储好，还是与对应的文件数据块连续存储好？要求说明理由。 解析： 1 在磁盘中连续存放，磁盘寻道时间更短，文件随机访问效率更高；在FCB中加入的字段为：\u003c起始块号，块数\u003e或者\u003c起始块号，结束块号\u003e 2 将所有的FCB集中存放，文件数据集中存放。这样在随机查找文件名时，只需访问FBC对应的块，可减少磁头移动和磁盘I/O访问次数 2016年真题 某磁盘文件系统使用链接分配方式组织文件，簇大小为4KB。目录文件的每个目录项包括文件名和文件的第一个簇号，其他簇号存放在文件分配表FAT中。 1 假定目录树如下图所示，各文件占用的簇号及顺序如下表所示，其中dir、dir1时目录，file1、file2是用户文件。请给出所有目录文件的内容 2 若FAT的每个表项仅存放簇号，占2个字节，则FAT的最大长度为多少字节？该文件系统支持的文件长度最大为多少？ 3 系统通过目录文件和FAT实现对文件的按名存取，说明file1的106、108两个簇号分别存放在FAT的哪个表项中。 4 假设仅FAT和dir目录文件已读入内存，若需将文件dir/dir1/file1的第5000个字节读入内存，需要访问哪几个簇？ 解析： 1 两个目录文件dir和dir1的内容如下表所示： 2 FAT的最大长度为2^16*2B=128KB，文件的最大长度是2^16*4KB=256MB - 为什么FAT的表项个数是2^16？因为题目中提到FAT的每个表项占2个字节，也就是16位， - 没有提示最大上限，所以用完就是2^16个表项。 3 file1的簇号106存放在FAT的100号表项中，簇号108存放在FAT的106号表项中 - 如果不熟悉FAT的话看到会一脸懵逼，熟悉的也常常反应不过来 - FAT是链接分配的一种，是隐式链接，通过内存中的一个表格来完成簇的索引 - 比如对于file1，100号表项中存放着106，106号表项存放着108,108号表项存放着EOF 4 需要访问目录文件dir1所在的48号簇以及文件file1的106号簇 2012年真题 某文件系统空间的最大容量为4TB，以磁盘块为基本分配单位。磁盘块大小为1KB。文件控制块（FCB）包含一个512B的索引表区。请回答以下问题。 1 假设索引表区仅采用直接索引结构，索引表区存放文件占用的磁盘块号，索引表项中块号最少占多少个字节？可支持的单个文件最大长度是多少字节？ 2 假设索引表区采用如下接哦股：第0-7字节采用\u003c起始块号，块数\u003e格式表示文件创建时预分配的连续存储空间。其中起始块号占6B，块数占2B，剩余504个字节采用直接索引结构，一个索引项占6B，则可支持的单个文件最大长度是多少字节？为了使单个文件的长度达到最大，请指出起始块号和块数分别所占字节数的合理值并说明理由。 解析： 1 文件系统中所能容纳的磁盘块总数为4TB/1KB=2^32，要完全表示所有磁盘块，索引项的块号最少要占32/8=4B。而索引表区采用直接索引结构，故512B的索引表区能容纳512B/4B=128个索引项。每个索引项对应一个磁盘块，所以该系统可支持的单个文件最大长度是128*1KB=128KB 2 这里考察的分配方式不同于我们熟悉的三种经典分配方式，但是题目中给出了详细的解释。所求的单个文件最大长度一共包含两个部分:预分配的连续空间和直接索引区 连续区块数占2B，共可以表示2^16个磁盘块，即2^26B。直接索引区共504B/6B=84个索引项。所以该系统可支持的单个文件最大长度是2^26B+84KB。 为了使单个文件的长度达到最大，应使连续区的块数字段表示的空间大小尽可能接近系统最大容量4TB。分别设起始块号和块数分别占4B，这样起始块号可以寻址的范围是2^32个磁盘块，共4TB，即整个系统空间。同样的，块数字段可以表示最多2^32个磁盘块，即4TB。 2014年真题 文件F由200条记录组成，记录从1开始编号。用户打开文件后，欲将内存中的一条记录插入到文件F中，作为其第30条记录。请回答下列问题，并说明理由。 1 若文件系统采用连续分配方式，每个磁盘块存放一条记录，文件F存储区域前后均有足够的空闲磁盘空间，则完成上述插入操作最少需要访问多少次磁盘块？F的文件控制块内容会发生哪些改变？ 2 若文件系统采用链接分配方式，每个磁盘块存放一条记录和一个链接指针，则完成上述插入操作需要访问多少次磁盘块？若每个存储块大小为1KB，其中4个字节存放链接指针，则该文件系统支持的文件最大长度是多少? 解析 1 系统采用顺序分配方式时，插入记录需要移动其他记录块，整个文件共有200条记录，要插入新记录作为第30条，而存储区前后有足够的空间，且要求最少的访问块数，则要把文件前29条记录前移。若算访盘次数移动一条记录读出和写回各是一次访盘，共需要58次移动，加上存回第30条记录，共59次。 2 文件系统采用链接分配方式时，插入记录并不用移动其他记录，只需要找到相应的记录，修改指针即可。插入的记录为其第30条记录，那么需要找到文件系统的第29块，一共需要访盘29次，然后把29块的下块地址赋给新块，把新块写回内存会访盘1次，然后修改内存中第29块的下块地址字段，在存回磁盘，一共访盘31次","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:13:3","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3 磁盘组织和管理 不知道重不重要，但是感觉知识点很多 一般而言，磁盘会以文件簇为单位分配空间。 低级格式化： 将磁盘当作空白版，分成扇区，以便硬件控制器能读和写。低级格式化会为磁盘的每个扇区采用特别的数据结构，包括校验码等。 将磁盘分为由一个或多个柱面组成的分区，每个分区可以作为一个独立的磁盘 逻辑格式化：创建文件系统，在这一步，操作系统将初始的文件系统数据结构存储到磁盘上。这些数据结构包括空闲和已经分配的空间以及一个初始为空的目录。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:14:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3.2 磁盘调度算法 寻找时间Ts：活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除了跨越n条磁道的时间外，还包括启动磁臂的时间s，即Ts=mn+s，其中m是与磁盘驱动器速度有关的常数，约为0.2ms 延迟时间Tr：磁头定位到某一磁道的扇区（块号）所需要的时间，设磁盘的旋转速度为r，则Tr=1/2r 传输时间Tt：从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数b和磁盘的旋转速度：Tt=b/rN，其中r为磁盘每秒的转速，N为一个磁道上的字节数。 总平均存取时间Ta=Ts+Tr+Tt 调度算法笔记上有，就不赘述了。 PS：王道上的磁盘调度算法有问题，在2010年第45题的CSCAN算法上，只有王道是写着磁盘臂一直转动到底，然后迅速回弹的。这个说法与这个题目是不符合的。 天勤、汤子瀛的操统中SCAN和CSCAN都是到同方向最后一个请求就返回，根本就没有LOOK和CLOOK算法。 而现代操作系统这本书根本就没有提SCAN，而是用了电梯算法，和汤的书的说法类似。 汤子瀛CSCAN的截图： ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:14:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"第五章 输入输出管理 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:15:0","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.1 IO管理概述 IO控制方式 程序直接控制方式：CPU对外设进行循环检查，从外部设备读取数据到存储器（IO控制器的数据寄存器），会导致CPU的绝大部分时间都处于闲置状态。 中断驱动方式：允许IO设备主动打断CPU的运行并请求服务，从而实现CPU与IO设备地并行工作。 DMA 通道 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:15:1","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2 5.2.4 设备分配与回收 独占式使用设备：申请设备，如果设备空闲，就将其独占。 分时式共享使用设备：独占使用设备，设备利用率很低。可以通过分时共享来提高利用率。 以SPOOLing方式使用外部设备：即假脱机IO技术，实质上就是对IO操作进行批处理。实质上是以空闲换时间的技术。 5.2.5 SPOOLing（假脱机技术） 为了缓和CPU的高速性和IO设备低速性之间的矛盾引入的假脱机技术。该技术是利用专门的外围控制机，讲低速IO设备上的数据传送到高速磁盘上。 意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中采用的一项将独占设备改造成共享设备的技术。 输入井和输出井：在磁盘上开辟出的两个存储区域，输入井模拟脱机输入时的磁盘，用于收容IO设备的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。 输入缓冲区和输出缓冲区：在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井，输出缓存区用于暂存输出井送来的数据，以后再传送到输出设备。 输入进程和输出进程 输入进程模拟脱机输入时的外围控制机，将用户要求的数据从输入机通过输入缓冲区再送到输入井。当CPU需要输入数据时，直接将数据从输入井读入内存。 输出进程模拟脱机输出时的外围控制机，把用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。 SPOOLing系统的主要特点有：提高了IO速度；将独占设备改造成共享设备；实现了虚拟设备功能。 题目 [2016-31]下列关于SPOOLing技术的叙述中，错误的是 A.需要外存的支持 B.需要多道程序设计技术的支持 C.可以让多个作业共享一台独占设备 D.由用户作业控制设备与输入/输出井之间的数据传送 答案选D 我是用排除法做的 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/:15:2","tags":["考研","操作系统"],"title":"操作系统-概述","uri":"/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":" 整理磁盘时发现考研408时自己的笔记 第一章 绪论 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:0:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.1 数据结构的基本概念 数据：信息的载体 数据元素：数据的基本单位。一个数据元素可由若干个数据项组成 数据对象：具有相同性质的数据元素的集合 数据类型：是一个值的集合和定义在此集合上一组操作的总称。原子类型：值不可再分的数据类型；结构类型：值可以再分解的若干类型；抽象数据类型：抽象数据组织和与之相关的操作。 抽象数据类型：ADT，指一个数学模型以及定义在该模型上的一组操作。 数据结构=逻辑结构+存储结构+数据的运算 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:1:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"1.1.2 数据结构的三要素 逻辑结构：指数据元素之间的逻辑关系，如集合、线性结构、树形结构、图状结构或网状结构 数据的存储结构：指数据结构在计算机中的表示，也称物理结构。包括顺序存储、链式存储、索引存储和散列存储。 数据的运算：施加在数据上的运算包括运算的定义和实现。 第2章 线性表 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:1:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.1 线性表的定义和基本操作 线性表是具有相同数据类型的n个数据元素的有限序列。 逻辑上，每个元素有且只有一个直接前驱，有且只有一个直接后继（表头表尾元素例外） 使用顺序存储的时候即为顺序表。 使用链式存储即为链表。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:2:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2 线性表的顺序表示 线性表的顺序存储又称为顺序表，是一组地址连续的存储单元。特点是表中元素的逻辑顺序与物理顺序相同。 PS：动态分配并不是链式存储，同样属于顺序存储结构，只是分配的空间大小可以在运行时决定。 最主要的特点是随机访问，而且逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素。 插入，平均时间复杂度O(n) 删除，平均时间复杂度O(n) 按值顺序查找O(n)，二分可以到O(logn) 错题：线性表的顺序存储结构是一种顺序存取的存储结构。 这个是错误的，是随机存取的存储结构。顺序存取是一种读写方式，不是存储方式，有别于顺序存储。 PPS：表的元素从1开始计数，C中的数组从0开始计算。 题目： [2010真题]1. 设将n(n\u003e1)个整数存放到1维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0\u003cp\u003cn)个位置，即将R中的数据由(X0,X1,…,Xn-1)变换为(Xp,Xp+1,…,Xn-1,X0,X1,…,Xp-1)。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 [2011年真题]2.一个长度为L（L\u003e=1）的升序序列S，处在L/2个位置的数被称为中位数。例如，若序列S1=（11,13,15,17,19），则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在由两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求： (1)给出算法的基本思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 [2013年真题]3.已知一个整数序列A=(a0,a1,…,an-1),其中0\u003c=ai\u003cn(0\u003ci\u003cn)。若存在ap1=ap2=…=apm=x且m\u003en/2(0\u003c=pk\u003cn,1\u003c=k\u003c=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 注释有感： 读注释的效果应当同读伪代码的效果一样 如果代码的内容无法直观表述，就需要写注释。 题目答案： 1.(1)可以将这个问题看作是把数组ab转换成数组ba（a代表前p个元素，b代表数组余下的n-p个元素），先将a逆置得到a-1b，再将b逆置，最后将ab逆置。 如对abcdefgh左移3个单位 Reverse(0,p-1)，得到cbadefgh Reverse(p,n-1)，得到cbahgfed Reverse(0,n-1)，得到defghabc (2)使用C语言描述算法 void Reverse(int R[],int from,int to){ int i,temp; for(i=0;i\u003c(to-from+1)/2;i++) {temp=R[from+i];R[from+i]=R[to-1];R[to-1]=temp} }//Reverse void Converse(int R[],int n,int p) { Reverse(0,p-1); Reverse(p,n-1); Reverse(0,n-1); } (3)上述三个Reverse的时间复杂度分别为O(p/2),O((n-p)/2)和O(n/2)，故所设计的算法的时间复杂度是O(n)，空间复杂度是O(1) 另外，可以使用大小为p的辅助数组，先将左边p个元素导入，再将n-p个元素左移，再放回去。时间复杂度O(n)，空间复杂度O(p) 2.(1)算法的基本思想如下： 分别求两个序列的中位数a和b， 若a=b，则算法结束 若a\u003cb，则舍弃A序列小的一半，B序列大的一半，要求两个序列舍弃的长度相等 若a\u003eb，则舍弃A序列大的一半，B序列小的一半，要求两个序列舍弃的长度相等 在保留的升序序列中，重复上述过程直到只含一个元素，较小者即为所求的中位数 (2)代码： int M_Search(int A[],int B[],int n){ int s1=0,d1=n-1,m1,s2=0,d2=n-1,m2; //分别表示序列A和B的首位数、末位数和中位数 while(s1!=d1||s2!=d2){ m1=(s1+d1)/2; m2=(s2+d2)/2; if(A[m1]==B[m2]) return A[m1];//满足条件1 if(A[m1]\u003cB[m2]){//满足条件2 if((s1+d1)%2==0){//若元素个数位奇数 s1=m1;//舍弃A中间点以前的部分且保留中间点 d2=m2;//舍弃B中间点以后的部分且保留中间点 } else{ s1=m1+1;//舍弃A中间点以前及中间点部分 d2=m2;//舍弃B中间点以后部分且保留中间点 } } else{//满足条件3 if((s2+d2)%2==0)//若元素个数为奇数 { d1=m1;//舍弃A中间点以后的部分且保留中间点 s2=m2;//舍弃B中间点以前的部分且保留中间点 } else{//若元素个数为偶数 d1=m1;//舍弃A中间点以后部分且保留中间点 s2=m2+1;//舍弃B中间点及中间点以前的部分 } } } return A[s1]\u003cB[s2]?A[s1]:B[s2]; } (3)算法的时间复杂度为O(log2n)，空间复杂度为O(1) 3.（1）给出算法的基本设计思想： 算法的策略是从前向后扫描数组元素，标记出一个可能成为主元素的元素Num。然后重新计数，确认Num是否是主元素。 算法分为以下两步： a.选取候选的主元素：依次扫描所给数组中的每个整数，将第一个遇到的整数Num保存到c中，记录Num的出现次数为1；若遇到的下一个整数仍等于Num，则计数加1，否则计数减1；当计数减到0时，将遇到的下一个整数保存到c中，计数重新记为1，开始新一轮计数，即从当前位置开始重复上述过程，直到扫描完全部数组元素。 b.判断c中元素是否是真正的主元素：再次扫描该数组，统计c中元素出现的次数，若大于n/2，则为主元素；否则，序列中不存在主元素。 (2)算法实现： int Majority(int A[],int n){ int i,c,count=1;//c用来保存候选主元素，count用来计数 c=A[0];//初始时设置A[0]为候补主元素 for(i=1;i\u003cn;i++){ if(A[i]==c) count++;//对A中的候选主元素计数 else{ if(count\u003e0)//处理不是候选主元素的情况 count--; else{//更换候选主元素，重新计数 c=A[i]; count=1; } } } if(count\u003e0){ for(i=count=0;i\u003cn;i++){//统计候选主元素的实际出现次数 if(A[i]==c) count++; } if(count\u003en/2) return c;//确认候选主元素 else return -1;//不存在主元素 } } (3)实现程序的时间复杂度为O(n)，空间复杂度为O(1) PS：对于统考算法题，去花费大量时间思考最优解法是得不偿失的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:3:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.2 线性表的链式表示 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"单链表 结点描述： typedef struct LNode{\rElemType data;//数据域\rstruct LNode *next; //指针域\r}Lnode,*LinkList; 通常使用头指针来标识一个单链表，第一个结点称为头结点。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.2 单链表上的基本操作 采用头插法建立单链表：即每次创建一个空结点链接到头指针指向的结点，然后头指针指向新创建的结点。时间复杂度O(n) 采用尾插法建立单链表：需要使用一个尾指针，每次在最后新建立一个结点然后指向它，更新尾指针。时间复杂度O(n) 3.按序号查找结点值。需要遍历链表，时间复杂度O(n) 4.按值查找表结点。同样需要遍历，时间复杂度O(n) 5.插入结点操作：将值为x的结点插入到单链表第i个位置上，主要开销在查找i-1个元素上，时间复杂度为O(n)。若给定插入元素，时间复杂度为O(1) 6.删除：O(1) 7.求表长：O(n) ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.2 双链表 结点类型： typedef struct DNode{\rElemType data;\rstruct DNode *prior,*next;\r}DNode, *DLinkList; 插入、删除结点的时间为O(1)。（虽然查找依旧是O(n)） ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.4 循环链表 循环链表中最后一个结点的指针不是NULL而是指向头结点。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"2.3.5 静态链表 使用数组描述链式结构。 #define MaxSize 50 typedef struct{ ElemType data;//存储数据元素 int next;//下一个数组元素的下标 } 以next=-1作为结束，与动态链表相同，只是不用修改指针。 错题：1.单链表中，增加一个头结点的目的时为了方便运算的实现。主要好处是：第一，有头结点后，插入和删除数据元素的算法统一了，不再需要判断是否在第一个元素之前插入或删除第一个元素；第二，不论链表是否为空，其头指针是指向头结点的非空指针，链表的头指针不变，因此空表和非空表的处理也就统一了。 2. 带头结点的双循环链表为空的条件是：L-\u003eprior=L\u0026\u0026L-\u003enext=L 编程题： [2009]1.已知一个带表头结点的单链表，结点结构为[data|link]。假设该链表只给出了头指针list，在不改变链表的前提下，请设计一个尽可能高效的算法，查找链表中倒数第k个位置上的结点（k为正整数）。若查找成功，算法输出该结点的data域的值，并返回1,；否则，只返回0，请问： (1)描述该算法的基本设计思想 (2)描述算法的详细设计步骤 (3)根据设计思想和实现步骤，采用程序设计语言实现算法，关键之处请给出简要注释。 1.（1）程序设计基本思想如下： 问题的关键是设计一个尽可能高效的算法，通过链表的一遍遍历，找到倒数第k个结点的位置。算法的基本设计思想是：定义两个指针变量p和q，初始时均指向头结点的下一个结点（链表的第一个结点），p指针移动到第k个结点时，q指针开始与p指针同步移动；当p指针移动到最后一个结点时，q指针所指示结点为倒数第k个结点。以上过程对链表仅进行一次扫描。 （2）算法的详细实现步骤如下： count=0，p和q指向链表表头结点的下一个结点 若p为空，转5 若count=k，则q指向下一个结点；否则，count=count+1 p指向下一个结点，转2 若count=k，则查找成果，输出data域的值，返回1；否则，说明k值超过了线性表的长度，查找失败，返回0 算法结束 （3）算法实现 typedef int ElemType;//链表数据的类型定义 typedef struct LNode{//链表结点的结构定义 ElemType data;//结点数据 struct LNode *link;//结点链接指针 } int Search_k(LinkList list,int k){ //查找链表list倒数第k个结点，并输出该结点data域的值 LNode *p=list-\u003elink,*q=list-\u003elink;//指针p、q指示第一个结点 int count = 0; while(p!=NULL){ //遍历链表直到最后一个结点 if (count\u003ck) count++;//计数，若count\u003ck只移动p else q=q-\u003elink; p = p-\u003elink;//之后再让p、q同步移动 } if(count\u003ck) return 0;//查找失败返回0 else{//否则打印并返回1 printf(\"%d\",q-\u003edata); return 1; } }//Search_k 第3章 栈和队列 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:4:5","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1 栈 栈：只允许一端进行插入和删除的线性表 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:5:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.1.2 栈的顺序存储结构 顺序栈 栈的顺序存储称为顺序栈，它是利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针指示当前栈顶的位置。 顺序存储类型描述： #define MaxSize 50 typedef struct{ Elemtype data[MaxSize]; int top; }SqStack; 链式栈 采用链式存储的栈称为链栈，优点是多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况，通常使用单链表实现。 typedef struct Linknode{ ElemType data; struct Linknode *next; }*LiStack; ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:5:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2 队列 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:6:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.1 队列的基本概念 队列是一种操作受限制的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。 操作特性是FIFO，故又称为先进先出的线性表。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:6:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.2 队列的顺序存储结构 分配一块连续的存储单元存放队列中的元素，并附设两个指针front和rear分别指示队头和队尾元素的位置。 队列的顺序存储类型描述 #define MaxSize 50 typedef struct{ ElemType data[MaxSize]; int front,rear; } 会出现假溢出，即data数组中仍然有存放元素的空间，但是仍然溢出了。 循环队列：将顺序队列看作是一个环状的空间 入队时少用一个队列单元 队满的条件：(Q.rear+1)%MaxSize==Q.front 队空条件为：Q.front==Q.rear 队列中元素的个数：(Q.rear-Q.front+MaxSize)%MaxSize 后者增设一个表示元素个数的数据成员，或者增设一个tag数据成员。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:6:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.3 队列的链式存储结构 可以描述为 typedef struct{ ElemType data; struct LinkNode *next; }LinkNode; typedef struct{ LinkNode *font,*rear; }LinkQueue; ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:6:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.2.4 双端队列 允许两端都可以进行入队和出队操作的队列 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:6:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.3 栈和队列的应用 括号匹配 表达式求值（后缀） 递归 二叉树层次遍历 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:7:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.4 特殊矩阵的压缩存储 压缩存储：指为多个值相同的元素只分配一个存储空间，对零元素不分配存储空间。其目的时为了节省存储空间 特殊矩阵：指具有许多相同矩阵元素或令元素，并且这些相同矩阵元素或零元素的分布有一定规律性的矩阵。常见的特殊矩阵有对称矩阵、上/下三角矩阵、对角矩阵等。 对称矩阵：只存放对角线和下三角区的元素 元素下标之间的对应关系： i行j列元素在数组中的下标是k i\u003e=j（下三角区和主对角线元素）时：k=i(i-1)/2+j-1 i\u003cj（上三角区元素aij=aji）时，k=j(j-1)/2+i-1 三角矩阵 上三角全部为0时，下三角区和主对角线元素仍如上，上三角指向常数0. 三对角矩阵 k=2i+j-3 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:8:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"3.4.4 稀疏矩阵 稀疏矩阵可以转为表，这时候会失去随机存储特性。 第4章 树与二叉树 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:8:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.1 树的基本概念 任何一棵非空树应该满足： 有且仅有一个特定的称为根的结点。 当N\u003e1时，其余结点可分为m个互不相交的有限集合T1,T2,…,Tm，其中每一个集合本身又是一棵树，并且称为根节点的子树。 树是一种逻辑结构 树中两个结点之间的路径是由两个结点之间所经过的结点序列构成的，而路径长度是路径上所经过边的个数。 树的性质： 树中的结点数=所有结点的度数+1 度为m的树中第i层上至多有m^(i-1)个结点 高度为h的m叉树至多有(m^h-1)/(m-1)个结点 具有n个结点的m叉树的最小高度为floor(logm(n(m-1)+1)) ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:9:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2 二叉树的概念 满二叉树：叶子结点集中在二叉树的最下一层，并且除叶子结点之外的每个结点的度数都为2. 完全二叉树：每一个结点与满二叉树同样编号的结点一一对应。 二叉排序树 平衡二叉树 二叉树的性质： 非空二叉树，N0=N2+1(N0+N1+N2=N1+2N2+1) … ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:10:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.2.2 二叉树的存储结构 顺序存储结构：自上而下，自左而右的存储。一般来说，完全二叉树和满二叉树采用顺序存储比较合适，可以直接映射。 链式存储结构：二叉链表包含三个域，数据域、左指针域和右指针域 typedef struct BiTNode{ ElemType data; struct BiTNode *lchild,*rchild; }BiTNode,*BiTree; ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:10:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3 二叉树的遍历和线索二叉树 先序遍历：根左右 中序遍历：左根右 后序遍历：左右根 可以借助栈将二叉树的递归遍历算法转变为非递归算法（栈+指针） 层次遍历：需要使用队列，依次将孩子结点加入队列中 由二叉树的先序遍历和中序遍历可以唯一确定一棵二叉树。同理，二叉树的后序遍历和中序遍历也可以唯一确定一棵二叉树。 二叉树的层序序列和中序序列也可以确定一棵二叉树。只有先序序列+后序序列无法确定一棵二叉树。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:11:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.3.2 线索二叉树 线索二叉树的实质是对一个非线性结构进行线性化操作，使在这个访问序列中每一个结点都有一个直接前驱和直接后继。 引入线索二叉树的目的是加快查找结点前驱和后继的速度。 在二叉树线索化时，通常规定：若无左子树，令lchild指向其前驱结点；若无右子树，令rchild指向其后继结点。同时还需要增加两个标识域来表明当前指针域所指向的对象是指向左（右）子结点还是直接前驱（后继） 线索二叉树的存储结构： typedef struct ThreadNode{ ElemType data; struct ThreadNode *lchild,*rchild; int ltag,rtag; }ThreadNode,*ThreadTree; 以这种结点结构构成的二叉链表作为二叉树的存储结构，叫做线索链表。其中指向结点前驱和后继的指针，叫做线索。加上线索的二叉树叫做线索二叉树。对二叉树以某种次序遍历使其变为线索二叉树的过程叫做线索化。 线索二叉树的构造：对二叉树的线索化，实质上就是遍历一次二叉树，在遍历过程中检查当前结点左、右指针域是否为空，若为空，则将他们改为指向前驱或后继结点的线索。 算法题： [2014年]1.二叉树的带权路径长度（WPL）是二叉树中所有叶节点的带权路径长度之和，给定一棵二叉树T，采用二叉链表存储，结点结构为(left,weight,right)。其中叶节点的weight域保存该结点的非负权值。设root为指向T的根结点的指针，请设计求T的WPL的算法，要求： (1)给出算法的基本设计思想 a.基于先序递归遍历的算法思想使用一个static变量记录wpl，把每个结点的深度作为递归函数的一个参数传递，算法步骤如下：（标准答案如下，我个人更倾向于将wpl值作为函数返回值逐层返回） 若该结点是叶结点，变量wpl加上该结点的深度与权值之积。 若该结点是非叶结点，那么若左子树不为空，对左子树调用递归算法；若右子树不为空，对右子树调用递归算法，深度参数均为本结点的深度参数加1； 最后返回计算出的wpl b. 基于层次遍历的算法思想是使用队列进行层次遍历，并记录当前的层数， 当遍历到叶节点时，累计wpl； 当遍历到非叶结点的时候，把该结点的子树加入队列； 当某结点为该层的最后一个结点时，层数自增1； 队列空时遍历结束，返回wpl (2)二叉树结点的数据类型定义如下： typedef struct BiTNode{ int weight; struct BiTNode *lchild,*rchild; } (3)算法的代码如下 a. 基于先序遍历的算法 int WPL(BiTree root){ return wpl_PreOrder(root,0); } int wpl_PreOrder(BiTree root,int deep){ static int wpl=0;//定义一个static变量存储wpl if(root-\u003elchild==NULL\u0026\u0026root-\u003erchild==NULL)//若为叶节点，累积wpl wpl+=deep*root-\u003eweight; if(root-\u003elchild!=NULL)//若左子树不空，对左子树递归遍历 wpl_PreOrder(root-\u003elchild,deep+1); if(root-\u003erchild!=NULL)//若右子树不空，对右子树递归遍历 wpl_PreOrder(root-\u003erchild,deep+1); return wpl; } b.基于层次遍历的算法 #define MaxSize 100//设置队列的最大容量 int wpl_LevelOrder(BiTree root){ BiTree q[MaxSize]; //声明队列，end1为头指针，end2为尾指针 int end1,end2; //队列最多容纳MaxSize-1个元素 end1=end2=0; //头指针指向队头元素，尾指针指向队尾的后一个元素 int wpl=0,deep=0; //初始化wpl和深度 BiTree lastNode; //lastNode用来记录当前层的最后一个结点 BiTree newlastNode; //newlastNode用来记录下一个层的最后一个结点 lastNode=root; //lastNode初始化为根节点 newlastNode=NULL; //newlastNode初始化为空 q[end2++]=root; //根节点入队 while(end1!=end2){ //层次遍历，若队列不空则循环 BiTree t=q[end1++]; //拿出队列中的头一个元素 if(t-\u003elchild==NULL\u0026\u0026t-\u003erchild==NULL){ wpl+=deep*t-\u003eweight; } //若为叶节点，统计wpl if(t-\u003elchild!=NULL){ //若非叶节点，把左节点入队 q[end2++]=t-\u003elchild; newlastNode=t-\u003elchild; } //并设下一层的最后一个结点为该结点的左结点 if(t-\u003erchild!=NULL){ //处理叶节点 q[end2++]=t-\u003erchild; newlastNode=t-\u003erchild; } if(t==lastNode){ //若该结点为本层最后一个结点，更新lastNode lastNode=newlastNode; deep+=1; //层数加1 } } return wpl; //返回wpl } c.非递归的后序遍历。非递归遍历都需要栈，而后序遍历需要额外保存信息 typedef struct{ BTNode *p;//p是二叉树的结点的指针 int rvisited; //revisited=1代表p所指向的结点的右结点已被访问过 }SNode; //栈中的结点定义 typedef struct{ SNode Elem[maxsize]; int top; }SqStack;//栈结构体 void PostOrder2(BiTree T){ SNode sn; BTNode *pt=T; InitStack(S);//从根节点开始，往左下方走，将路径上的每一个结点入栈 while(T){ Push(pt,0);//Push到栈中的两个信息，一个是结点指针，一个是其右结点是否被访问过 pt=pt-\u003elchild; } while(!S.IsEmpty()){//只要S栈非空 sn.s.getTop();//sn是栈顶结点 if(sn.p-\u003erchild==NULL||sn.rvisited){ Pop(S,pt); visit(pt); } else{//若它的右孩子存在且rvisited为0，处理其右孩子 sn.rvisited=1;//往左下方走到尽头，将路径上所有元素入栈 pt=sn.p-\u003erchild; while(pt!=NULL){ Push(S,pt,0); pt=pt-\u003elchild; } } } } ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:11:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.4 树、森林 数的存储结构：可以使用顺序存储结构或链式存储结构 双亲表示法：使用连续空间来存储每个结点，每个结点带上自己双亲在数组中的位置。 typedef struct{ ElemType data; int parent; }PTNode; typedef struct{ PTNode nodes[MAX_TREE_SIZE]; int n; }PTree; 孩子表示法：将每个结点的孩子结点都用单链表连接起来形成一个线性结构。 孩子兄弟表示法：使每个结点包含三部分内容：结点值、指向结点第一个孩子结点的指针和指向结点下一个兄弟结点的指针 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:11:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.4.2 树、森林与二叉树的转换 树转换为二叉树：每个结点左指针指向它的第一个孩子结点，右指针指向它在树中的相邻兄弟结点，表示为“左孩子右兄弟”。（因此由树转换而来的二叉树的根节点没有右子树） 森林转换为二叉树的规则类似，不过将第一棵树的根作为转换后二叉树的根，其余根节点在右子树上排开（就像同层） 二叉树转换为森林：二叉树根及其左子树为第一棵树的二叉树形式，二叉树根的右子树为第二棵，右子树的右子树为第三棵，以此类推。然后用左孩子右兄弟逆运算。二叉树转换为树或森林是唯一的。 4.4.3 树和森林的遍历 先根遍历：先访问根节点，再按从左到右的顺序遍历根节点的每一棵子树。（访问顺序与访问对应二叉树的先序遍历一样） 后根遍历：先按从左到右的顺序遍历根节点的每一棵子树，之后再访问根节点。（访问顺序与访问对应二叉树的中序遍历一样） 森林的遍历： 先序遍历森林：先访问第一棵树的根节点，遍历第一棵树根节点的子树森林，再遍历除了第一棵树之后剩下的树构成的森林。 中序遍历森林：先遍历森林中第一棵树根节点的子树森林，再访问第一棵树的根节点，再中序遍历除了第一棵树之后剩余的树构成的森林。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:11:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"树的应用——并查集 错题： 将森林转换为对应的二叉树，若在二叉树中，结点u是结点v的父结点的父结点，则在原来的森林中，u和v不可能是这个关系：u的父结点与v的父结点是兄弟关系。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:11:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.5 树与二叉树的应用 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:12:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.5.1 二叉排序树 BST左子树非空，则左子树上所有点小于根节点的值；右子树非空，则右子树上所有点大于根节点的值。 查找、插入略 构造：依次输入数据元素，并将它们插入到二叉排序树上适当的位置。 删除（较复杂）：删除结点必须维护二叉排序树的性质 如果被删除结点是叶节点，则直接删除 若结点z只有一棵左子树或右子树，则让z的子树称为z父结点的子树，替代z的位置。 若z有左、右两棵子树，则令z的直接后继（或直接前驱）替代（左子树中最右的，或者右子树中最左的），并将直接后继删除，转换成第一或第二种情况。 效率分析 显然，对于高度为H的二叉树，插入和删除的运行时间都是O(H)，但如果二叉树在最坏的情况，会退化成链表，这时性能会指数增加。 二叉树上的查找与二分查找的性能接近。但是二分查找的判定树是唯一的，二叉排序树是不唯一的，相同的关键字其插入顺序不同可能生成不同的二叉排序树。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:12:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.5.2 平衡二叉树AVL 为了避免二叉树的高度增长过快，规定在插入和删除二叉树结点的时候，保证任意结点的左、右子树高度的绝对值差不超过1。 平衡因子=左子树高度-右子树高度，显然只能取-1、0、1. 平衡二叉树的插入：插入结点后，要检查其插入路径上的结点是否因为这次操作而导致了不平衡。每次调整的对象都是最小不平衡树，即在插入路径上离插入结点最近的平衡因子的绝对值大于1的结点作为根的子树 LL平衡旋转（右单旋转）：A的左孩子的左子树上插入了一个新的结点导致失衡。这时候向右旋转，B作为A的左孩子变为根节点，A变为B的右孩子，B的右子树变成A的左子树。 RR平衡旋转（左单旋转）：A的右孩子的右子树上插入了一个新的结点导致失衡。这时候向左旋转，B作为A的右孩子变为根节点，A变为B的左孩子，B的左子树变为A的右子树。 LR平衡旋转（先左后右双旋转）：A的左孩子的右子树上插入了一个新的结点导致失衡，进行两次旋转操作。A为根结点，B为A的左孩子，C为B的右孩子。将C作为根节点，B为C的左孩子，A为C的右孩子。C的左子树变为B的右子树，C的右子树变为A的左子树。 RL平衡旋转（先右后左双旋转）：A的右孩子的左子树上插入了一个新的结点导致失衡。A为根节点，B为A的右子树，C为B的左子树。将C作为根节点，A为C的左子树，B为C的右子树，C的左子树为A的右子树，C的右子树为B的左子树。 删除相同 查找为log2n ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:12:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"4.5.3 哈夫曼树和哈夫曼编码 哈夫曼树的带权路径长度最小 构造 对于给定的N棵仅含有一个结点的二叉树，构成森林 构造一个新结点，选取森林中权值最小的两个结点作为左右子树，更新结点为左右子树权值之和。 重复，直到只剩下一棵树 特点： 每个初始结点都成为了叶节点，且权值越小的点路径长度越大。 节点总数2N-1 不存在度为1的点。 前缀编码：如果没有一个编码是另外一个编码的前缀，则称这样的编码为前缀编码。 第5章 图 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:12:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.1 图的基本概念 图G由顶点集V和边集E组成。|V|表示图G中顶点的个数，也称为图G的阶 表可以是空表，树可以是空树，但是图不可以是空图，即图中不能一个顶点都没有。图中至少要有一个点，但是边集可以为空。 简单图：图中没有重复边，不存在顶点到自身的边，称为简单图 多重图：两个结点之间边数多于一条，又允许顶点通过同一条边和自己关联。 完全图：无向图中任意两个点之间存在边，共有n(n-1)/2条边；有向图中任意两个顶点之间存在方向相反的两条弧，称为有向完全图。 连通图：图中任意两个顶点是连通的，称为连通图。 强连通图：有向图中，任意两个顶点之间存在双向路径，称为强连通图。 稀疏图：|E|\u003c|V|*log|V|时，看作稀疏图，反之则是稠密图。 简单路径：在路径序列中，顶点不重复出现的路径称为简单路径。 回路：第一个顶点和最后一个顶点相同的路径称为回路或环；（如果一个图有n个顶点，大于n-1条边，则一定有环）除第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路叫做简单回路。 度指的是以该顶点为一个端点的边的数目。对于有向图，度=入度+出度。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:13:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2 图的存储及基本操作 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2.1 邻接矩阵法 #define MaxVertexNum 100//顶点数目的最大值 typedef char VertexType;//顶点的数据类型 typedef int EdgeType;//带权图中边上权值的数据类型 typedef struct{ VertexType Vex[MaxVertexNum];//顶点表 EdgeType Edge[MaxVertexNum][MaxVertexNum];//邻接矩阵，边表 int vexnum,arcnum;//图的当前顶点数和弧数 }MGraph; 特点： 无向图的邻接矩阵是对称的，所以实际只需要存储上/下三角矩阵的元素 对于无向图，第i行非零元素的个数正好是第i个结点的度。 对于有向图，入度和出度可以根据第i行计算 邻接矩阵A，A^n的元素A^n[i][j]等于由顶点i和顶点j的长度为n的路径的数目。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2.2 邻接表法 当一个图为稀疏图时，使用邻接矩阵表示法显然要浪费大量的存储空间。图的邻接表法结合了顺序存储和链式存储方法。 顶点表：顶点域+边表头指针 边表：邻接点域+指针域 #define MaxVertexNum 100//图中顶点数目的最大值 typedef struct ArcNode{//边表结点 int adjvex;//该弧所指向的顶点的位置 struct ArcNode *next;//指向下一条弧的指针 //InfoType info;//网的边权值 }ArcNode; typedef struct VNode{//顶点表结点 VertexType data;//顶点信息 ArcNode *first;//指向第一条依附该结点的弧的指针 }VNode,AdjList[MaxVertexNum]; typedef struct{ AdjList vertices;//邻接表 int vexnum,arcnum;//图的顶点数和弧数 }ALGraph;//ALGraph是以邻接表存储的图类型 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2.3 十字链表 有向图的一种链式存储方式。在十字链表中，有向图的每一条弧有一个结点，对应于每个顶点也有一个结点 弧结点：尾域+头域+链域hlink+链域tlink+相关信息info。尾域和头域分别指示弧尾和弧头这两个结点，链域hlink指向弧头相同的下一条弧，链域tlink指向弧尾相同的下一条弧，info域指向该弧的相关信息。 顶点结点：data+firstin+firstout，data存放顶点相关的数据信息，firstin和firstout两个域分别指向以该顶点为弧头或弧尾的第一个弧结点。 注意，顶点结点之间是顺序存储。 十字链表存储结构： #define MaxVertexNum 100//图中顶点数目的最大值 typedef struct ArcNode{//边表结点 int tailvex,headvex;//该弧的头尾结点 struct ArcNode *hlink,*tlink;//分别指向弧头相同和弧尾相同的结点 //InfoType info;//相关信息指针 }ArcNode; typedef struct VNode{//顶点表结点 VertexType data;//顶点信息 ArcNode *firstin,*firstout;//指向第一条入弧和出弧 }VNode; typedef struct{ VNode xlist[MaxVertexNum];//邻接表 int vexnum,arcnum;//图的顶点数和弧数 }GLGraph;//GLGraph是以十字邻接存储的图类型 本质上还是邻接表，但是针对有向图寻找入弧作出了优化，因此很容易可以求得顶点的出度和入度。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2.4 邻接多重表 邻接多重表是无向图的另一种链式存储结构 邻接表中难以求两个顶点之间是否存在边，以及难以执行删除边的操作。 边点：mark标识域，标记该边是否被搜索过；ivex和jvex为该边依附的两个顶点在图中的位置；ilink指向下一条依附于顶点ivex的边；jlink指向下一条依附于顶点jvex的边，info为指向和边相关的各种信息的指针域。 顶点：data，存储相关信息；firstedge指向第一条依附于该顶点的边 #define MaxVertexNum 100//图中顶点数目的最大值 typedef struct ArcNode{//边表结点 bool mark;//访问标记 int ivex,jvex;//分别指向该弧的两个结点 struct ArcNode *ilink,*jlink;//分别指向两个顶点的下一条边 //InfoType info;//相关信息的指针 }ArcNode; typedef struct VNode{//顶点表结点 VertexType data;//顶点信息 ArcNode *firstedge;//指向第一条依附该结点的边 }VNode; typedef struct{ VNode adjmulist[MaxVertexNum];//邻接表 int vexnum,arcnum;//图的顶点数和弧数 }AMLGraph;//AMLGraph是以邻接多重表存储的图类型 PS：稀疏矩阵可以使用十字链表和三元组表进行压缩 补充： 三元组表：即只储存非零元素的位置，(i,j,aij)表示在图中的i行j列的元素aij 二叉链表：用于存储二叉树的链表。二叉树一般使用从上到下，从左到右的顺序存储，具体实现上使用链表。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.2.5 图的基本操作 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:14:5","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.3 图的遍历 BFS：分层遍历，借助辅助队列。 性能分析：空间复杂度O(|V|)（全部入队） 采用邻接表时，每个顶点入队一次，每条边至少访问一次，时间复杂度O(|V|+O|E|)。采用邻接矩阵时，查找每个顶点的邻接点所需时间为O(V)，所以总的时间复杂度为O(|V|^2) 使用BFS可以求解非带权图的单源最短路 广度优先生成树对于邻接矩阵而言是唯一的，对于邻接表是不唯一的。 DFS 递归算法，需要借助递归工作栈，空间复杂度为O(|V|) 以邻接矩阵表示时，查找每个顶点的邻接点所需时间为O(|V|)，故总的时间复杂度为O(|V|^2)。当以邻接表表示时，查找所有顶点的邻接点所需时间为O(|E|)，访问顶点所需时间为O(|V|)，总的时间复杂度为O(|V|+|E|) 基于邻接表的深度优先搜索树是不唯一的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:15:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.3.3 图的遍历与图的连通性 可以用图的遍历算法来判断图的连通性 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:15:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4 图的应用 历年考察重点 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:16:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4.1 最小生成树MSTP 一个连通图的最小生成树是图的极小连通子图，它包含图的所有顶点，且边的权值之和最小。 性质： 最小生成树的树形不是唯一的，但是边的权值一定是最小的。（若G中各边权值互不相等，则G的最小生成树是唯一的） 最小生成树的边数为顶点数减1 Prim算法 Dijkstra思路相同。思路如下： 添加任意顶点至最小生成树子图中。 重复将子图到非子图范围内最小的边添加进来，并将对应的结点加入子图中。 添加完全部，算法结束 时间复杂度为O(|V|^2)，如果使用优先队列可以达到O(|V|log|V|)，适用于求解边稠密的图的最小生成树。 kruskal 初始化，每个顶点构成一棵独立的树，得到一个森林 将权值最小的边选定，如果将该边的两个顶点没有都加入最小生成树，则添加该边 完成 可以用并查集实现判断顶点是否在最小生成树中。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:16:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4.2 最短路径 dijkstra求解单源最短路 dist[]：记录从源点v0到其他各顶点的最短路径长度，初始为该点到各顶点的值（不连通则为无穷大） path[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点。算法结束时，可以根据其值追溯得到源点v0到顶点vi的最短路径 操作： 初始化集合为源点，初始化dist 从顶点集合中选出dist值最小的一个点，将该点纳入初始集合 松弛dist，对所有经过点j到达的顶点的权值进行更新。如果发生更新，设置path[i]指向j 重复2、3操作共n-1次，直到所有顶点包含到初始集合中。 显然，主要开销就是找dist的最小值，可以使用优先队列优化。 dijkstra是基于贪心策略的，在边上带有负权值的时候不适用（准确来说，是对于有负圈的图，dijkstra无法结束） 时间复杂度O(|V|^2) floyd求各顶点之间的最短路 时间复杂度O(|V|^3)，但是很简单。 思路就是使用邻接矩阵来存储任意两个点之间的距离。对于任意两个点，枚举可能的中间结点并更新这个矩阵。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:16:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4.3 拓扑排序 有向无环图：一个有向图中不存在环，则称为有向无环图DAG AOV网：如果用DAG图表示一个工程，其顶点表示活动，用有向图\u003cV1,Vj\u003e表示活动Vi必须先于Vj进行的这样一种关系，记为AOV网。 拓扑排序：每个顶点出现且只出现一次。若顶点A在序列中排在顶点B的前面，则图中不存在B到A的路径。 操作： 找到入度为0的点，输出 删除这个点，删除它的所有边，重复1直到没有其他点 显然，如果图中存在环，则它不可能有拓扑序列。 如果一个点有多个直接后继，则拓扑排序的结果通常不唯一。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:16:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"5.4.4 关键路径 没错，和IT项目管理的关键路径法的那个关键路径是一个东西。 在带权有向图中，以顶点表示事件，有向边表示活动，边上的权值表示活动的开销，这样的网络称为AOE网。 AOE网的性质： 只有在某顶点表示的活动发生后，从该顶点出发的各有向边所代表的活动才能开始。 只有在进入某一顶点的各有向边所代表的活动都已经结束时，该顶点所代表的事件才能发生。 仅有一个入度为0的顶点，称为源点；有一个出度为0的顶点，表示汇点。 把从源点到汇点的所有路径中，具有最大路径长度的路径称为关键路径，把关键路径上的活动称为关键活动。 事件vk，最早发生事件ve(k),最迟发生事件vl(k),活动ai的最早开始时间=ve(k)，最迟开始时间l(i)=vl(j)-weight(vk,vj)。 而一个活动ai的最迟开始时间与最早开始时间的差额d(i)=l(i)-e(i)，指该活动完成的时间余量。对于d(i)=0的活动，称为关键活动。 目的就是找到所有关键活动，组成关键路径。 错题：MST的一个限制条件 当带权连通图中的任意一个环中所包含的边的权值均不相同时，其MST是唯一的。 第6章 查找 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:16:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.1 查找的基本概念 查找：在数据中寻找满足某种条件的数据元素的过程称为查找。 查找表：用于查找的数据集合称为查找表，由同一类型的数据元素组成，可以组成一个数组或链表等数据类型。四个基本操作：1.查询某个特定的数据元素是否在查找表中。2.检索满足条件的某个特定的数据元素的各种属性。3.在查找表中插入一个数据元素。4.从查找表中删除某个数据元素。 静态查找表：如果一个查找表只涉及操作1和2，即不需要动态修改查找表中的内容。与之相对应，需要动态地插入或删除的查找表称为动态查找表。静态查找表查找方法：顺序查找、折半查找、散列查找等；动态查找表：二叉排序树查找、散列查找。 关键字：数据元素中唯一标识该元素的某个数据项的值，具有唯一性。 平均查找长度：在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:17:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.2 顺序查找和折半查找 顺序查找，即线性查找。一般分为对无序线性表的查找和按关键字有序的顺序表的顺序查找。 一般线性表的顺序查找 即逐个查找，显然查找成功时平均查找长度ASL=pc=(n+1)/2，查找不成功时n+1。 有序表的顺序查找 查找成功时平均查找长度和一般线性表的顺序查找是一样的。查找失败的时候会提前结束，为n/2+n/(n+1) ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:18:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.2.2 折半查找 又称二分查找 算法如下： int Binary_Search(SeqListr L,ElemType key){ int low=0,high=L.TableLen-1,mid; while(low\u003c=high){ mid=(low+high)/2; if(L.elem[mid]==key) return mid; else if(L.elem[mid]\u003ekey) high=mid-1; else low = mid+1; } return -1; } 查找成功的平均查找长度为log2(n+1)-1，时间复杂度O(log2n) ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:18:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.2.3 分块查找 又称索引顺序 查找，既有动态结构，又可以快速查找 基本思想： 把查找表分为若干个小块 块内无序，块间有序 索引表中记录各块的最大关键字和地址 设将长度为n的查找表分为b块，每块s个记录。 索引表中顺序查找的平均查找长度=(s^2+2s+n)/(2s) 索引表中二分查找的平均查找长度=ceil((log2(b+1)))+(s+1)/2 PS：表长n个记录，均分成b块，每块记录数为s，则b=n/s。当s=ceil(sqrt(n))的时候，ASL最小为ceil(sqrt(n))+1 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:18:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.3 B树和B+树 B树重点考察，B+树只考察基本概念 王道P263 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:19:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.3.1 B树及其基本操作 B树，又称为多路平衡查找树，满足以下特性： 树中每个结点至多有m个子树（最多有m-1个关键字） 若根节点不是终端结点，则至少有两棵子树 出根节点外的所有非叶节点至少有m/2棵子树（即至少含有m/2-1个关键字） 所有非叶结点的结构如下：n,P0,K1,P1,K2,…Kn,Pn，其中K为结点的关键字；P为指向子树根节点的指针。且子树Pi-1所有的关键字均小于Ki，n为结点中关键字的个数，m/2-1\u003c=n\u003c=m-1 所有叶节点都出现在同一层次上，并且不带信息（实际上不存在） B树是所有结点的平衡因子均等于0的多路查找树 B树的大部分操作所需要的磁盘存取次数与B树的高度成正比。首先要明确，B树的高度不包括最下层叶节点所处的那一层。 对于任意一棵n个关键字，高度为h、阶数为m的B树 因为n\u003c=(m-1)*(1+m+m^2+…+m^(h-1))=m^h-1，因此h\u003e=logm(n+1) 若让每个结点的关键字个数达到最少，则容纳同样多关键字的B树的高度可以达到最大。h\u003c=log(m/2)((n+1)/2)+1 PS:m/2对所有奇数向上取整 B树的查找 与二叉查找树相似，只是每个结点都是多个关键字的有序表，在每个结点做的是多路分支决定 两个基本操作：1.在B树中找结点；2.在结点内找关键字。由于B树存在磁盘上，前一个查找操作是在磁盘上进行的，后一个查找操作是在内存中进行的。 B树上查找到某个结点后，先在有序表中查找，然后到对应的子树中查找。 B树的插入 定位：利用前述的B树查找算法，找出插入该关键字的最底层中某个非叶节点 插入：在B树中，每个非失败结点的关键字个数都在ceil(m/2)-1到m-1之间。当插入后的结点关键字小于m，则可以直接插入；否则必须对结点进行分裂。 分裂的方法：取一个新的结点，将插入key后的原节点从中间位置将其中的关键字分为两部分。若此时导致父结点的关键字个数也超过了上限，则传递分裂，如果传到了根节点，则B树高度增加1. B树的删除：类似，但是稍微复杂一点。 删除的关键字在叶节点上且符合条件：直接删除 删除的关键字在非叶结点上且符合条件：会从孩子结点提取合适的前驱或后继关键字，升上来。如果孩子结点全部不满足。如果都不满足，合并孩子结点。 删除的关键字后数量不符合要求：从自己的兄弟结点借一个，然后修正和父结点关键字的关系；如果兄弟都没有，那就合并。 5.B+树 B树的一种变形树，m阶的B+树和m阶的B树区别： B+树的非叶子节点不保存关键字记录的指针，只进行数据索引，使得B+树每个非叶子结点能保存的关键字大大增加。 B+树的叶子结点保存了父结点的所有关键字记录的指针，所有数据地址必须到叶子节点才能获取到。所以每次数据查询的次数都一样。 B+树可以进行顺序查找 B+树叶子结点的关键字从小到大有序排序，左边结尾数据都会保存右边开始数据的指针。 非叶子结点的子节点数=关键字数 在具体应用上，B+树比B树更适用于实际应用中的操作系统的文件索引和数据库索引，因为前者磁盘读写代价更低，查询效率更稳定。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:19:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4 散列表 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。散列函数可能将不同的关键字映射到同一地址，称为冲突。冲突是不可避免的。 散列表：根据关键字而直接进行访问的数据结构。即散列表建立了关键字和存储地址之间的一种直接映射关系。 理想情况的时间复杂度为O(1) ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:20:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4.2 散列函数的构造方法 直接定址法：直接取关键字的某个线性函数值作为散列地址。H(key)=a*key+b 除留余数法：H(key)=key%p 数字分析法：设关键字是r进制，而r个数码在各位上的分布不均等。选取分布较均匀的若干位作为散列地址。适用于已知的关键字集合。 平方取中法：取关键字的平方值的中间几位作为散列地址。这样子的散列地址比较均匀，适用于关键字的每一位取值都不够均匀或小于散列地址所需的位数。 折叠法：将关键字分割成位数相同的几部分，然后取几部分的叠加和。适用于关键字位数很多，且关键字每位数字分布大致均匀时。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:20:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4.3 处理冲突的方法 以下用Hi表示第i次探测的散列地址 开放定址法:指的是可存放新表项的空闲地址即向它的同义词表项开放，又向它的非同义词开放。Hi=(H(key)+di)%m，di为增量序列，m表示散列表表长 （1）线性探测法，d=0,1,2,…,m-1，称为线性探测法。当冲突发生时，顺序查看表中下一个单元，直到找出一个空闲单元或查遍全表。无法避免堆积问题，可能严重降低效率，退化成链表。堆积问题会直接降低查找效率。 （2）平方探测法：d=0,1^2,-1^2,2^2,-2^2,…,k^2,-k^2，其中k\u003c=m/2，散列表m必须是一个可以表示成4k+3的素数，又称为二次探测法。可以避免堆积问题，但是不能探测到散列表上所有的单元，只能探测至少一半单元。 （3）再散列法：当di=Hash2(key)，又称为双散列法，需要使用两个散列函数，第一个散列函数发生冲突时，用第二个散列函数计算关键字的地址增量。Hi=(H(Key)+i*Hash2(Key))%m，i是冲突的次数，最多经过m-1次探测会遍历表中所有位置，回到H0位置。 （4）伪随机序列法：di=伪随机数序列 PS：开放定址情况下，不能随意物理删除表中的已有元素，因为可能会截断其他具有相同散列地址的元素的查找地址。需要给它做删除标记。副作用是，多次删除后，尽管表面上散列表很满，但实际上还有许多位置没有利用，因此要定期清理散列表。 拉链法（链接法,chaining） 将所有的同义词存在一个线性链表上 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:20:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.4.4 散列查找及性能分析 散列表的查找效率取决于三个因素：散列函数、处理冲突的方法和装填因子 装填因子：散列表中的装填因子一般记为a，定义为一个表的装满程度，即a=表中记录数n/散列表长度m 散列表的平均查找长度依赖于散列表的装填因子a。直观看，a越大，表示装填的记录越满，越可能发生冲突。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:20:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.5 字符串匹配 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:21:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.5.1 简单的模式匹配算法 串的模式匹配，就是求第一个字符串在第二个字符串中的位置 int Index(SString S,SString T){ int i=1,j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ if(S[i]==T[j]){ ++i; ++j; } else{//失败，指针回退 i=i-j+2; j=1; } } if(j\u003eT[0]) return i-T[0]; else return 0; } 时间复杂度为O(nm)，n、m分别为主串和模式串的长度 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:21:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"6.5.2 KMP 添加了失配函数，如果发生失配，并不直接归位，而是沿着next跳转。 void get_next(char T[],int next[]){ i=1; next[1]=0; j=0; while(i\u003c=T[0]){//T[0]保存字符串的长度 if(j==0||T[i]==T[j]){ ++i;++j;next[i]=j; } else{ j=next[j]; } } } //王道版本的KMP int KMP(char S[],char T[],int next[],int pos){ //利用模式串T的next函数在主串S中第pos个位置之后的位置的KMP算法 i=pos; j=1; while(i\u003c=S[0]\u0026\u0026j\u003c=T[0]){ if(j==0||S[i]==T[j]){ ++i; ++j; } else{ j=next[j]; } } if(j\u003eT[0]){ return i-T[0]; } else return 0; } 我更喜欢算法导论版本的伪代码KMP //匹配串T，模板串P KMP-MATCHER(T,P){ n=T.length m=P.length pi=COMPUTE-PREFIX-FUNCTION(P)//根据模板串计算转移函数pi q=0 for i=1 to n{ while q\u003e0 \u0026\u0026 P[q+1]!=T[i]{//如果失配，沿转移函数前进 q=pi[q] } if P[q+1]==T[i]{ q = q+1 } if q==m{ Print i-m q = pi[q]//寻找下一个匹配 } } } COMPUTE-PREFIX-FUNCTION(P){ m=P.length let pi[1...m] be a new array pi[1]=0 k=0 for q=2 to m{ while k\u003e0 \u0026\u0026 P[k+1]!=P[q] k=pi[k] if P[k+1]==P[q] k=k+1 pi[q]=k } return pi } 第7章 排序 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:21:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.1 排序的基本概念 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:22:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.1.1 排序的定义 排序，就是重新排列表中的元素，使表中的元素按关键字递增或递减的过程。 算法稳定性：如果有两个元素Ri=Rj，其对应的关键字keyi=keyj，且排序时Ri在Rj的前面。如果使用某一排序算法排序后，Ri仍然在Rj前面，该算法是稳定的，否则称排序算法是不稳定的。 内部排序：指在排序期间元素全部存放在内存中的排序。 外部排序：指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间移动的排序。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:22:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.2 插入排序 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:23:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.2.1 直接插入排序 某一时刻状态：有序序列L[1…i-1]、L[i]、无序序列L[i+1…n] 为了将L[i]插入，执行以下操作： 查找出L[i]在有序序列的插入位置k 将L[k…i-1]的元素后移一个单位 将L[i]复制到L[k] void InsertSort(ElemType A[],int n){ int i,j; for(i=2;i\u003cn;i++) { if(A[i].key\u003cA[i-1].key){ A[0]=A[i];//复制为哨兵，A[0]不存放元素 for(j=i-1;A[0].key\u003cA[j].key;--j)//从后往前查找待插入位置 A[j+1]=A[j];//向后挪位 A[j+1]=A[0];//复制到插入位置 } } } 效率分析； 空间效率O(n) 时间效率：O(n^2) 稳定性：稳定的排序方法 实用性：适用于顺序存储和链式存储的线性表。 PS：大部分排序算法都仅适用于顺序存储的线性表。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:23:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.2.2 折半插入排序 查找有序子表的部分用折半查找来实现。在确定出待插入位置后，就可以统一地向后移动元素了。 void InsertSort(ElemType A[],int n){ int i,j,low,high,mid; for(i=2;i\u003c=n;i++){ A[0]=A[i]; low=1;high=i-1; while(low\u003c=high){ mid=(low+high)/2; if(A[mid].key\u003eA[0].key) high = mid-1; else low = mid+1; } for(j=i-1;j\u003e=high+1;--j) A[j+1]=A[j];//统一后移，空出位置 A[high+1]=A[0]; } } ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:23:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.2.3 希尔排序 直接插入排序适用于基本有序的算法和数据量不大的排序表，基于此提出了希尔排序，又称缩小增量排序。 基本思想：先将待排序表分割成若干个形如L[i,i+d,i+2d,…i+kd]的特殊子表，分别进行直接插入排序。党整个表中元素基本有序时，再对全体进行一次直接插入排序。 过程： 先取一个小于n的步长d1，把表中全部记录分成d1个组，所有距离为d1的倍数的记录放在同一个组中，同时在各组中进行直接插入排序； 然后取第二个步长d2\u003cd1，重复该过程，直到所取到的d1=1，即所有记录已放到同一组中，再进行直接插入排序，由于此时已经具有较好的局部有序性，故很快可以得到结果。 PS：到目前为止，尚未求得最好的增量序列。希尔提出的办法是d1=n/2,di+1=floor(di/2)，并且最后一个增量等于1. 如下： void ShellSort(ElemType A[],int n){ /* 修改如下： 1. 前后记录位置的增量是dk，不是1 2. r[0]只是暂存单元，不是哨兵，当j\u003c=0时，插入位置已到 */ for(dk=n/2;dk\u003e=1;dk/=2){//补偿变化 for(i=dk+1;i\u003c=n;++i){ if(A[i].key\u003cA[i-dk].key){//需将A[i]插入有序增量子表中 A[0]=A[i]; for(j=i-dk;j\u003e0\u0026\u0026A[0].key\u003cA[j].key;j-=dk){ A[j+dk]=A[j];//记录后移，查找插入的位置 } A[j+dk]=A[0]; } } } } 性能分析： 空间效率：仅使用了常数个辅助单元，因而空间复杂度为O(1) 时间效率：当n在某个特定范围内，约为O(n^1.3)，在；最坏情况下希尔排序的时间复杂度为O(n^2) 稳定性：不稳定 实用性：仅适用于顺序存储 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:23:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.3 交换排序 根据序列中两个关键字的比较结果来交换这两个记录在序列中的位置。重点考冒泡排序和快速排序，一般不会单独考察冒泡排序 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:24:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.3.1 冒泡排序 基本思想：太简单，略。 每趟冒泡的结果都会将一个元素放在最终位置，比如用王道的算法，每次排序之后会将序列中最小的元素放在序列最前面。 记忆：想冒泡泡一样，每次从头撸到尾，最后一个就有序了，然后少撸一截。撸n-1遍。 冒泡有个很好的性质，就是如果撸一遍以后没有可以交换的对象了，那么之后也不再有可以交换的对象，可以提前结束算法。 void BubbleSort(ElemType A[],int n){ //冒泡排序，从小到大 for(i=0;i\u003cn-1;i++){ flag = false;//表示本趟冒泡是否发生交换 for(j=n-1;j\u003ei;j--){ if(A[j-1].key\u003eA[j].key){ swap(A[j-1],A[j]); flag = true; } } if(!flag){ return;//本趟遍历后没有交换，说明序列已经有序 } } } 效率分析； 空间复杂度O(1) 时间复杂度O(n^2) 稳定性：稳定的 冒泡排序产生的有序子序列一定是全局有序的，即有序子序列中的所有元素的关键字一定小于无序子序列中的关键字（不同于直接插入排序）看，即到达最终位置。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:24:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.3.2 快速排序 基本思想是基于分治的。 void QuickSort(ElemType A[],int low,int high){ if(low\u003chigh){ int pivotpos=Partition(A,low,high);//划分 QuickSort(A,low,pivotpos-1); QuickSort(A,pivotpos+1,high); } } int Partition(ElemType A[],int low,int high){ //严谨的一趟排序过程 ElemType pivot=A[low]; while(low\u003chigh){ while(low\u003chigh\u0026\u0026A[high]\u003e=pivot) --high; A[low]=A[high];//将比枢轴值小的元素移动到左端 while(low\u003chigh\u0026\u0026A[low]\u003c=pivot) ++low; A[high]=A[low];//将比枢轴值大的元素移动到右端 } A[low]=pivot;//枢轴元素存放到最终位置 return low; } 也有结合起来的版本，比如我NOIP时期的代码： #include \u003cstdio.h\u003eint n,a[100009]; void sort (int a[],int left,int right) { int low,high,pivot; int temp; low=left,high = right; pivot=a[(left+right)/2]; while (low\u003c=high) { while (a[low]\u003cpivot) low++; while (pivot\u003ca[high]) high--; if (low\u003c=high) { temp=a[low]; a[low]=a[high]; a[high]=temp; low++,high--; } } //记忆后面两句话的时候一定要记得，此时low\u003ehigh if (left\u003chigh) sort(a,left,high); if (low\u003cright) sort(a,low,right); } int main () { int i,j; scanf(\"%d\",\u0026n); for (i=1;i\u003c=n;i++) scanf(\"%d\",\u0026a[i]); sort(a,1,n);//从0开始是个好习惯，不过我费事改了 for (i=1;i\u003c=n;i++) printf(\"%d \",a[i]); } 效率分析： 递归的空间复杂度平均为O(log2n)（函数调用栈） 时间复杂度：O(nlog2n)，最坏情况下O(n^2)。 稳定性：不稳定 PS：每一趟排序后会将一个元素（基准元素）放到最终位置上 优化： 在子序列规模较小时放弃递归调用快排，使用直接插入排序等完成后续的排序工作 尽量取可以将数据中分的枢轴元素，比如根据头、尾、中间三个元素的中间值等。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:24:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.4 选择排序 基本思想：每一趟在后面n-i+1个待排序元素中选择关键字最小的元素，作为有序子序列的第i个元素，直到第n-1趟完成。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:25:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.4.1 简单选择排序 void SelectSort(ElemType A[],int n){ for(i=0;i\u003cn-1;i++){ min=i; for(j=i+1;j\u003cn;i++){ if(A[j]\u003cmin) min=j; } if(min!=i) swap(A[i],A[min]) } } 效率： 空间复杂度O(1) 时间复杂度O(n^2) 稳定性：不稳定 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:25:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.4.2 堆排序 堆排序是一种树形选择排序方式。特点是将L[1..n]看成是一棵完全二叉树的顺序存储结构，以此完成排序。 堆是一种特殊的二叉树，它的根节点的值大于/小于其两个孩子的值，这样根节点就是最大/最小的。通过不断提取最大值，可以得到一个序列，这个序列就是最终的排序结果。 void BuildMaxHeap(ElemType A[],int len){ for(int i=len/2;i\u003e=0;i--) AdjustDown(A,i,len); } void AdjustDown(ElemType A[],int k,int len){ //AdjustDown将元素k向下调整 A[0]=A[k]; for(i=2*k;i\u003c=len;i*=2){//沿key较大的子节点向下筛选 if(i\u003clen\u0026\u0026A[i]\u003cA[i+1]){ i++;//取key较大的子节点的下标 } if(A[0]\u003e=A[i]) break;//筛选结束 else{ A[k]=A[i];//将A[i]调整到双亲结点上 k=i;//修改k值，以便继续向下筛选 } } A[k]=A[0];//被筛选结点的值放入最终位置 } void HeapSort(ElemType A[],int len){ BuildMaxHeap(A,len);//初始建堆 for(i=len;i\u003e1;i--){//n-1趟的交换和建堆过程 Swap(A[i],A[1]);//输出堆顶元素 AdjustDown(A,1,i-1);//整理，将剩余的i-1个元素整理成堆 } } void AdjustUp(ElemType A[],int k){ //参数k为向上调整的结点，也为堆的元素个数 A[0]=A[k]; int i=k/2; while(i\u003e0\u0026\u0026A[i]\u003cA[0]){ A[k]=A[i];//双亲结点下调 k=i; i=k/2; } A[k]=A[0]; } 空间效率：空间复杂度为O(1) 时间效率：建堆时间O(n)，之后n-1次向下调整，每次调整的时间复杂度为O(h)，故平均而言，时间复杂度为O(nlog2n) 稳定性：不稳定的 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:25:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.5 归并排序和基数排序 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:26:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.5.1 归并排序 将两个或两个以上的有序表组合成一个新的有序表。假定待排序表含有n个记录，则可以看成是n个有序子表，然后不断两两归并直到合成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。 递归形式的2-路归并排序算法是基于分治额，对子表递归地排序。 ElemType *B=(ElemType *)malloc((n+1)*sizeof(ElemType));//辅助数组B，长度n+1 void Merge(ElemType A[],int low,int mid,int high){ //表A的两端low...mid和mid+1...high各自有序，将它们合并成一个有序表 for(int k=low;k\u003c=high;k++) B[k]=A[k];//将A中的所有元素复制到B中 for(i=low,j=mid+1,k=i;i\u003c=mid\u0026\u0026j\u003c=high;k++){ if(B[i]\u003c=B[j]){//比较B的左右两段中的元素 A[k]=B[i++];//将较小值复制到A中 } else{ A[k]=B[j++]; } } while(i\u003c=mid) A[k++]=B[i++]; while(j\u003c=high) A[k++]=B[j++]; } void MergeSort(ElemType A[],int low,int high){ if(low\u003chigh){ int mid=(low+high)/2;//从中间划分两个子序列 MergeSort(A,low,mid); MergeSort(A,mid+1,high); Merge(A,low,mid,high); } } 效率： 空间复杂度O(n) 时间复杂度O(nlog2n) 稳定性：稳定的 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:26:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.5.2 基数排序 它不是基于比较进行排序的，而是采用多关键字排序思想，又分为最高位优先排序和最低位优先排序。 以r为基数的最低位优先基数排序的过程：假设线性表由结点序列a0,a1,…,an-1构成，每个结点的关键字由d元组组成 分配：开始时，把Q0,Q1,…,Qr-1各个队列置成空队列，然后依次考察线性表中的每一个结点aj，如果aj的关键字的第i位符合要求，就把aj放入Qk队列中 收集：把Q0,Q1,…,Qr-1各个队列中的结点依次首尾相接，得到新的结点序列，从而组成新的线性表。 效率： 空间效率：一趟排序需要的辅助存储空间为r（r个队列），但以后的排序中重复使用这些队列，所以基数排序的空间复杂度为O(r) 时间复杂度：d趟分配和收集，一趟分配需要O(n)，一趟收集需要O(r)，所以基数排序的时间复杂度为O(d(n+r))，它与序列的初始状态无关。 稳定性：稳定的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:26:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.6 各种内部排序算法的比较及应用 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:27:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.6.1 内部排序算法的比较 省略，看书 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:27:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.7 外部排序 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:28:0","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.7.1 外部排序的基本概念 在排序过程中需要多次进行内存和主存之间的交换，对外村文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序方法就称为外部排序。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:28:1","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.7.2 外部排序的方法 通常根据外存设备的不同分为磁盘文件排序和磁带文件排序两大类。磁盘是直接存取设备，磁带是顺序存取设备。 外部排序通常采用归并排序方法，有两个相对独立的阶段： 根据内存缓冲区的大小，将外存上含n个记录的文件分成若干长度为h的子文件，依次读入内存并利用有效的内部排序方法对它们进行排序，并将排序后得到的有序子文件重新写回外存（通常称这些有序子文件为归并段或顺串） 对这些归并段进行逐趟归并，使归并段逐渐由小变大，直至得到整个有序文件为止。 一般情况下，外部排序的总时间=内部排序所需的时间+外存信息读写的时间+内部归并所需的时间 即t_ES=rt_IS+dt_IO+S(n-1)t_mg，其中r是初始归并段的个数，t_IS是对每一个初始归并段进行内部排序的时间，d是访问外存块的次数，t_IO是每一个块的存取时间，S是归并趟数，n是每趟参加二路归并的记录个数，t_mg是每作一次内部归并，取得一个关键字最小记录的时间。 显然磁盘存取的时间远远大于内部排序和内部归并的时间，因此要提高外排序的速度，应该着力减少d，即I/O次数。 增大归并路数m，或减少初始归并段数r，都能减少归并趟数S，以减少读写磁盘次数d，达到提高外部排序速度的目的。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:28:2","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.7.3 多路平衡归并与败者树 上节提到，可以增加归并路数m来减少归并趟数S，进而减少访问外存的次数。然而增加归并路数m又会增加算法内部排序的时间。因此不能使用普通的内部归并排序算法。 为了使内部归并不受m的增大的影响，引入了败者树。可以看作是一棵完全二叉树，每个叶结点存放各归并段在归并过程中参加比较的记录。内部结点用来记录左右子树中的失败者，让胜利者继续向上比较，一直到根节点。 m路归并的败者树深度为ceil(log2m)，因此m个记录中选择最小关键字，最少需要ceil(log2(m))次比较，内部归并的比较次数就与m无关了。因此，只要内存空间允许，增大归并路数m可以有效减少归并树的高度，从而减少I/O次数d，提高外部排序的速度。 值得注意的是m并不是越大越好，m增大时要相应地增加输入缓冲区的个数。如果可供使用的内存空间不变，就势必要减少每个输入缓冲区的容量，使得内外存交换数据的次数增大。当m值过大时，虽然归并趟数减少，但读写外存的次数仍会增加。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:28:3","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机基础"],"content":"7.7.4 置换-选择排序（生成初始段） 如果采用前面介绍过的内部排序方法，将得到长度都相同的初始归并段。因此，需要使用新的算法那来生成初始归并段。 设初始待排文件FI，初始归并段文件为FO，内存工作区为WA，内存工作区可容纳w个记录。置换-选择算法的步骤如下： 从待排方法FI输入w个记录到工作区WA。 从内存工作区WA中选出其中关键字取最小值的记录，即为MINIMAX（以后再选出关键字比它大的记录归入本归并段，比它小的归入下一归并段） 将MINIMAX记录输出到FO中去 若FI未读完，则从FI输入下一个记录到WA中。 ","date":"2021-03-09","objectID":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/:28:4","tags":["考研","数据结构"],"title":"数据结构-概述","uri":"/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/"},{"categories":["计算机论文阅读"],"content":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty 2019 TCC,CCF C类 看到C类效果这样心里还是有点底，这个用来PK应该是没问题的 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:0:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"1 本文提出了一种混合方法来为基于云的网络应用分配云资源。结合了按需分配和预付费资源的有点，实现了混合的解决方案来最小化总部署费用的同时，满足流量变化下的QoS。 贡献可以分为以下部分： 部署了动态云资源分配方法，解决了在资源预分配和动态分配两阶段的资源调度问题。开发了随机优化方法来将用户需求建模为随机变量，并实现了10%的部署代价提升。 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:1:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"2 Related work 动态资源分配分为两个阶段： 第一阶段，资源在不考虑用户需求的情况下被分配。 第二阶段，为了保证QoS，采用on-demand的方式分配资源。 由于是离散的，因此不能使用凸优化方法，不能保证有全局最优解。 Robust Cloud Resouce Provisioning，考虑了三个不确定性：demand、price和cloud resource availability 在第一阶段，预付费资源完成，将特定数量的资源分配给了应用。 在第二阶段，判定资源是否够用，开始采购on-demand资源 总体来说该作者列的引文都是关于stochastic programming的 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:2:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"3 System model and assumptions ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:3:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"3.1 Problem Definition 为了满足不同用户的需求，云服务提供商会提供不同配置的VM，这将作为算法的输入。 算法主要将数据库应用与一般网络应用进行区分。(database instnace and computing instance) 然后进行了一系列的数学符号定义 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:3:1","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"4 Dynamic Cloud Resource Allocation Algorithm 本文采用的是两阶段算法，第一阶段，使用预付费的资源来满足最低QoS的需求。 第二阶段，将non-deterministic user demand建模成随机变量，来动态分配on-demand的资源。 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:4:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"4.1 DCRA Flowchart Overview 在reservation phase，算法会决定满足最细骄傲用户需求的资源，来作为分配预付费资源的依据。 在dynamic provision phase，DCRA算法会在每一个周期内(15-min)监控用户的实际需求。 除此之外，对于云服务提供商而言，如果购买了on-demand的机器，它不会在意你是使用了一小时还是几秒钟。因此，较短的动态分配周期并不能帮助减少分配的花费，但是可以帮助减少资源不足的情况，因为它可以尽快启动机器。 在动态阶段，如果监控平均用户流量$r_{avg}$超过了最低期望流量$r_{min}$，网络服务将处于资源不足的状态，这时就应该启动资源动态分配算法来满足动态的流量需求。输入当前流量，输出期望的on-demand资源数量。 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:4:1","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"4.2 Cloud Resource Reservation Optimization reserved phase，目标是确保资源在最小代价下满足QoS的最小需求。 代价函数包括了，DB实例的代价、存储代价、计算实例代价和IO的代价。 满足的约束是，实例的数量与单位实例能处理流量的乘积，要大于最小的流量估计值。 这里默认web application request arrival rate服从泊松过程分布，直接用了排队论的公式来联系到达速率、响应时间与CPU占用率之间的关系。 接下来是一些合法性约束条件，确保后续不会出现非法解 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:4:2","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"4.3 Dynamic Cloud Provision Optimization 我觉得它这里还是说的不错，流量本身是uncertaint nature，这使得deterministic resource allocation optimization不足以应对现实的情况。 作者引经据典，指出demand uncertainty can be modeled by a normal distribution。 作者希望使用stochastic optimization approach，考虑服从正态分布的随机过程。 最优化的目标optimization variables是on-demand的计算资源和数据库的实例数，以及它们的服务速率来满足更新的请求速率。 建模的目标式流量的期望值$r_{ave_c}$与$r_{ave_{db}}$及其方差。为了保证满足95%的置信区间，选用两倍的方差。 同样采用排队论方式建模，来建立请求率与访问时间之间的关系。 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:4:3","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"5 Performance Analysis ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:5:0","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"5.1 Experimental Setup 用户请求到达率依据排队论建模（2011,Optimal Resource Allocation for Multimedia Cloud Based on Queuing Model） reserved instance固定使用一年的合约，on-demand资源使用小时级合约 测试流量，其中之一为RUBiS流量；另外一个是SPEC。这两个都是benchmark流量。 ","date":"2021-03-05","objectID":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/:5:1","tags":["云资源调度"],"title":"Dynamic Cloud Resource Allocation Considering Demand Uncertainty","uri":"/posts/20210305_dynamic-cloud-resource-allocation-considering-demand-uncertainty/"},{"categories":["计算机论文阅读"],"content":"Profit Maximization for Cloud Brokers in Cloud Computing CCF A类 IEEE Transactions on Parallel and Distributed Systems，2019 ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:0:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"摘要 为了降低云用户的耗费，引入cloud broker（下称中间商）。中间商从云服务提供商处以reserved instance的形式租用VM，并把它们以比on-demand更低的价格与相同的付费模式租给用户。 本文关注于如何设置中间商的价格模型，为它的VM定价使得其利润最大化，在其能为用户节省成本的前提下。将最优化的多服务器配置问题和VM的定价问题建模为利润最优化问题，并使用启发式的方法来求解。近-最优解可以被用来指导配置和虚拟机的定价。 ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:1:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"3 The Models 模型主要使用的是多服务器排队论模型、收入模型和花费模型 reserved instance和on demand instance的价格使用$\\beta_{re}$和$\\beta_{od}$来指代，单位为dollar per unit time，一般unit time指的是小时。 ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:2:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"3.2 Multiserver queue system 本文所研究的中间商broker只从单一的云服务提供商处租用资源，并把它们提供给用户。因此，中间商提供的VM是同构的(homogeneous)。资源在CPU、内存、带宽等方面是一致的。本文假设用户使用了M/M/n/n的排队系统，来对其流量等进行建模。 在M/M/n/n排队系统中，VM的到达流量被认为是一个速率$\\lambda$的泊松流，到达时间独立同分布且呈指数分布。考虑到中间商使用价格来吸引用户，因此实际速率$lambda$会受到两个因素的影响，即实际用户需求$\\lambda_{max}$与资源价格。 通过租用VM并搭建私有云的方式，中间商可以向用户提供on-demand的产品。现假设中间商所拥有的虚拟机数量为n，则多队列系统的队列长度不超过n，此时可以根据排队论公式计算出平均服务时间与资源占用率。 得到等式1，描述$\\pi_k$的式子，这个变量为在排队论系统中有k个服务请求的概率。 显然，如果请求得不到满足，用户就会流失。因此流失概率等于系统中有n个请求的概率，即$P_L = \\pi_n$ ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:2:1","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"3.3 Cost Modeling 即购买服务器的钱，显然是$C=n\\beta_{re}$ ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:2:2","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"3.4 Revenue modeling 3.4.1 Analysis on the Revenue-affecting Factors 有两个主要影响盈利的因素，一个是用户的需求，即请求到达率$\\lambda$。在价格不变的情况下，请求到达率越高，收入也就越高。因此提升用户需求是获取更高收入的主要手段。 但是，用户的需求是随着VM的销售价格而变化的，因此第二个影响因素就是VM的销售价格。 价格从两个方面影响收入。首先，价格直接影响收入，在给定需求下，高价格导向高收入。其次，低价格是该盈利模式的核心竞争力，提升价格将导致客户流失。 考虑到收入与成本，销售VM的价格只能在$\\beta_{od}$与$\\beta{re}$区间内。 考虑关系，价格越低，用户流量$\\lambda_{max}$越高，可以构建出price-demand function。采用线性建模是因为这样最常见。 ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:2:3","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["计算机论文阅读"],"content":"4 没看明白 ","date":"2021-03-04","objectID":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/:3:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210304_profit-maximization-for-cloud-brokers-in-cloud-computing/"},{"categories":["Java基础学习"],"content":"第一章 Java程序设计概述 太简单了，直接略过。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"1.2 Java“白皮书”的关键术语 简单性：指相对于C++简单（指针、多重继承等），但设计者也并没有试图清楚C++中所有不适当的特性 面向对象：java与C++主要不同在于多重集成，以及接口概念 网络技能 健壮性 安全性 体系结构中立 可移植性 解释性：过去Java解释器可以在任何移植了解释器的机器上执行java字节码，现在使用即使编译器将字节码再翻译成机器码 高性能 多线程 动态性 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:1:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第二章 Java程序设计环境 我选择使用了JetBrainde IDEA社区版，直接忽略 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:2:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第三章 Java的基本程序设计结构 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.3 数据类型 主要关心的是boolean类型，包含false和true，与C++是同一个类型的 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.4 变量 合法特殊字符为任何代表字母的Unicode字符，但是不能出现+(操作符)和copyright（除字母外的其他Unicode字符）。其中$尽量不要在自己的代码中使用，一般出现在Java编译器或者其他工具生成的名字中。 需要显示初始化变量，与C++一致。 在java中，使用final指示常量，如final double CM_PER_INC=2.54。final表示该变量只能赋值一次，一旦赋值就不能修改，习惯上常量名使用大写。 类常量可以使用static final进行设定，在某个类内部定义 public class test{ public static final double CM_PER_INC=2.54; } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.5 运算符 求余符号为% 3.5.6 强制类型转换 double x = 9,997; int nx = (int) x; ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.6 字符串 任何语言的字符串都是值得重视的。 java使用类型String定义字符串 String greeting = \"Hello\"; String s = greeting.substring(0,3);//Hel 前闭后开区间，对于substring(a,b)，子串长度为b-a String t = \"123\"+\"456\";//123456 3.6.3 不可变字符串 String类不能直接修改字符串，只能够使用子串+拼接的方式进行间接修改。 原理是编译器让所有的字符串共享，可以想象字符串被放在公用的存储池中，赋值字符串后，新字符串与原字符串指向相同的对象。 3.6.4 检测字符串是否相等 可以使用s.equals(t)检测是否相等，但不能使用==，后者只能确定两个字符串是否放在同一个位置上，这点C++应该也是一样的。 3.6.5 可以调用string.length()返回长度 可以调用string.charAt(index)返回指定位置的char类型变量。 3.6.7 字符串API ……不用想着背了，肯定是用到的时候再查的。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.7 输入输出 IO也是很重要的 标准输出流：System.out.println 标准输入流： import java.util.*;//Scanner类定义在java.util包中 Scanner in = new Scanner(System.in);//Scanner绑定标准输入流 String nextline = in.nextLine();//读取下一行 String nextword = in.next();//读取下一个单词 int age = in.nextInt();//读取整数 格式化输出：System.out.printf(\"%8.2f\",x);，同样，与C++类似 3.7.3 文件输入输出 也是一般最常用的 Scanner in = new Scanner(Paths.get(\"myfile.txt\"));//读取文件 PrintWriter out = new PrintWriter(\"myfile.txt\");//写文件 相对路径为启动环境的根目录。使用集成开发环境时，路径地址可以使用String dir = System.getProperty(\"user.dir\");获得 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:5","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.8 控制流程 3.8.1 块作用域 block，指花括号括起来的若干条简单java语句 java支持带标签的break来跳出多重循环，标签必须放在希望跳出的最外层循环之前，加上引号 read_data: while(...){ for(...){ break read_data;//直接跳到指定循环之外 } } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:6","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.9 大数值 java.math中的BigInteger和BigDecimal，可以处理任意长度数字序列的树枝。前者为任意精度整数运算，后者为任意精度浮点数运算。可以使用valueOf方法将普通数值转换为大数值。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:7","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"3.10 数组 int[] a = new int[100]，声明数组 匿名数组smallPrimes = new int[]{1,2,3,4,5}，可以在不创建新变量的情况下重新初始化一个数组 数组拷贝int[] luckyNumbers = smallPrimes;为引用，想要拷贝数值应该使用Arrays.copyOf方法（可以使用该方法来增加数组长度） 数组排序Arrays.sort(arr) 3.10.7 不规则数组 double[][] balances = new double[YEARS][RATES] Java本质上没有多维数组，只有一维数组。因此，二维数组的每一行可以拥有不同的长度 int[][] odds = new int[NMAX+1][] for(int n=0;n\u003c=NMAX;n++){ odds[n] = new int[n+1]; } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:3:8","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第4章 对象与类 类之间的关系： 依赖\"use a\"。如果一个类的方法操纵另一个类，就说一个类依赖于另一个类。应该尽可能降低互相依赖的类的数量 聚合\"has a\"。一个类的对象包含另一个类，即为聚合 继承\"is a\"。 空对象null 4.2.3 更改器方法与访问器方法 GregorianCalendar now = new GregorianCalendar(); int month = now.get(Calendasr.MONTH);//访问器 deadline.set(Calendar.YEAR,2001);//更改器 对实例域作出修改的访问成为更改器方法，仅访问实例域的方法称为访问器方法。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.3 用户自定类 类方法构成 public String getName() 其中public表示访问控制，String表示返回值，函数名内部为形参表 4.3.2 多个源文件的使用 java编译器可以认为内置了make功能，就算使用java XXX.java命令没有显示编译其他的java文件，它也会查找其他的java文件。 4.3.3 剖析 一般建议实例域采用private来维持封装 4.3.4 构造器 C++中的构造函数，没有看到有什么不同的 PS：Java中的所有对象都是在堆中构造的，容易遗漏new操作符 PPS：不要在构造器中定义与实例域重名的局部变量，会重复。 4.3.5 隐式参数 即对于类方法 public void raiseSalary(double byPercent){ double raise = salary*byPercent/10; salary += raise; //一般推荐this.salary += raise;，这样可以显式区分局部变量和实例域 } java中可以选择显示调用this指针，也可以不调用。这里类方法中的第一个参数为隐式参数，即类自己。该类方法的副作用就是salary会一起改变。 方法可以访问所有类的私有域（与C++类似，抱歉我C++学的不好） class Employee{ private String name; public boolean equals(Employee other){ return name.equals(other.name); } } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.4 静态域 对象中的变量一般是跟着对象走的，但是static的变量可以看作独立于具体对象之外。这样，对于所有的对象，它们共享同样的静态域。 4.4.3 静态方法 静态方法是一种不能向对象实施操作的方法，可以认为静态方法没有this参数。 可以使用静态方法来实现工厂函数。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.5 方法参数 一般来说，存在按值调用和按引用调用。Java总是默认采用按值调用，但是需要注意，=赋值号一般总是直接复制对象的地址，除非使用clone 这也就是说，方法得到的是所有参数值的一个拷贝。但是如果参数是自定类的话，则拷贝的内容为类的地址，因此可以认为是引用传值。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.6 对象构造 4.6.1 重载 即构造函数重载，相同的构造函数可以使用相同的名字、不同的参数。 4.6.6 调用另一个构造器 关键字this引用方法的隐式参数 public Employee(double s){ //call Employee(String,double) this(\"Employee #\"+nextId,s); nextid++; } 这样对于公共的构造器代码，只用编写一次即可。 4.6.8 对象析构 为类添加finalize方法，将在垃圾回收器清除对象之前调用。 PS：在实际应用中不要依赖finalize方法，因为实际很难知道具体什么时间会调用这个函数 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.7 包 Java允许使用包将类组织起来，有点类似C++中的namespace 4.7.1 类的导入 导入的方式，一种是输入全名java.util.Date today = new java.util.Date(); 也可以使用import java.util.*;导入全部类，这样就不用写入全名了。 另外，*只能导入一个包，不能使用java.*的方式导入所有包。 4.7.2 静态导入 import static java.lang.System.*可以导入静态方法和静态域。 4.7.3 将类放入包中 想要将类放入包中，就必须将包的名字放在源文件的开头，可以必须写全名，例如 package com.horstmann.corejava;，而不能只是package corejava 同时，包中的文件需要被放置在与完整的包名匹配的子目录中，例如上面的包应该被放在com/horstmann/corejava下。 4.7.4 包作用域 对于private定义的类，只有同一个包能够访问。而public类则是导入包即可见。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:5","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.8 类路径 主要是使用JAR文件。一般将JAR文件放在一个目录中，然后设置类路径classpath(一般是java -classpath/-cp XXX)，就可以读取。在UNIX环境中，类路径的不同项目之间采用冒号分割。也可以设置环境变量CLASSPATH ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:6","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.9 文档注释 JDK的工具，javadoc，可以由源文件生成一个HTML文档。 有点类似python的doc，不过是放在定义的前面而不是后面，并且对于/**开头的注释来说，每一行的开头都要有* 方法注释还可以使用以下的标记： @param变量描述 @return 返回描述 @throws 类描述 通用注释： @author姓名 @version版本文本 @since 对引入特性的版本描述 执行命令javadoc -d docDirectory nameOfPackage，即可生成docDirectory下的指定包的HTML文件。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:7","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"4.10 类设计技巧 一定要保证数据私有，绝对不要破坏封装。我觉得在这里主要是因为JAVA的语言特性，对象默认传递地址使得一旦发生修改，查找起来会非常痛苦。 一定要对数据初始化 不要在类中使用过多的基本类型（便于理解） 不是所有的域都需要独立的域访问器和域更改器。 将职责过多的类进行分解 类名和方法名要能体现它们的职责。（PS：个人观点，不要出现magic number） ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:4:8","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第5章 继承 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.1 类、超类和子类 可以使用关键词extends表示继承，且JAVA中只有公有继承，没有C++中的私有继承和保护继承 一些显然但容易忘的事实：子类方法并不能直接访问超类的私有域，必须借助于公有接口。如果需要调用超类的同名方法，应该使用特定关键字super 同时，super可以在构造器中使用，比如 public Manager(String test){ super(test); } super与this指针具有类似之处，它们都能调用方法和构造器。但是super是不能赋值的，它只能指示编译器。 5.1.2 多态 比如Manager继承了Employee，显然Employee变量即可以是Employee对象，也可以是Manager对象或者其他继承对象。 5.1.3 动态绑定 多态的特征依赖于编译器调用对象方法的执行过程： 编译器查看对象的声明类型和方法名。编译器会遍历所有同名方法，列举所有同名方法 编译器将查看调用方法时提供的参数类型，即重载解析。至此，编译器获得需要调用的方法名字和参数类型。 对于private方法、static方法和final方法，编译器可以唯一的确认调用。这种称为静态绑定。 与之对应，调用的方法依赖于隐式参数(this)的实际类型，这种方式称为动态绑定。 5.1.4 阻止继承 不允许扩展的类称为final类 类中特定方法也可以声明为final，这样子类就不能覆盖这个方法。（final类中的所有方法自动称为final方法） 这样做的意义是为了保证它们在子类中不会改变语义。 5.1.5 强制类型转换 Manager boss = (Manager) staff[0];，其中staff可能是继承类数组。如果staff中是超类，则会报错。 可以使用 if (staff[1] instanceof Manager){ boss = (Manager) staff[1] } 确保staff中存储的是Manager或其子类。 PS：null instanceof C不会产生异常，只会返回false。 5.1.6 抽象类 对于上层的通用类，可能设计成抽象类会更好。 abstract class Person{ public abstract String getDescription() } 抽象类可以不用实现具体方法，但是可以包含具体数据和具体方法。 PS：很多人认为，在抽象类中包含具体方法是有害的。、 5.1.7 如果希望超类中的某些部分被子类访问，应该设为protected而非private。 但是这样只能访问自己对象的超类中的指定部分，而不能访问其他对象的超类中的指定部分。这与private还是有一定区别的。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.2 Object：所有类的超类 Object.equals()，判断一个对象是否等于另一个对象，即判断两者是否具有相同的引用。 Object.toString()，返回表示对象值的字符串。中间可以使用getClass().getName()获得类名的字符串。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.3 泛型数组列表 Java允许在运行时确定数组的大小。 int actualSize = ...; Employee[] staff = new Employee[actualSize]; 当然，这样子也无法动态更改数组大小。因此，一般使用ArrayList类来进行实现。该类类似于C++中的vector ArrayList\u003cEmployee\u003e staff = new ArrayList\u003cEmployee\u003e(); ArrayList只能使用get和set来访问数组元素。 size方法：返回数组列表中实际元素数量。 ensureCapacity(int capacity)，提前分配足够空间 trimToSize方法，可以将存储区域的大小调整为所需要的存储空间数目。 add方法，在数组列表的尾端添加一个元素 toArray方法，可以将ArrayList的内容赋值给一个数组。 get(index) set(index,ele) remove(index) 删除一个元素，后面的元素向前移动，返回被删除的元素 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.4 对象包装器与自动装箱 比如尖括号内的类型不能是基础类型，所以必须写成ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e(); 此时list.add(3);会自动变换成list.add(Integer.valueOf(3));该过程成为自动装箱autoboxing，或者autowrapping ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.5 参数数量可变的方法 例如System.out.printf的实现public PrintStream printf(String fmt,Object... args){return format(fmt,args);} 其中...打死表这个方法可以接收任意数量的对象，后者args是一个Object[]数组。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:5","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.6 枚举类 public enum Size{SMALL,MEDIUM,LARGE}; ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:6","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.7 反射 能够分析类能力的程序称为反射 5.7.1 Class类 Object类中的getClass()方法可以返回一个Class类型的实例。虚拟机为每个类型管理一个Class对象，可以使用==运算符进行比较，比如 if (e.getClass() == Employee.class) 以及使用newInstance()来快速地创建一个类的实例e.getClass().newInstance()，可以创建一个与e具有相同类类型的实例，调用默认的构造器。 String s = \"java.util.Date\"; Object m = Class.forName(s).newInstance();//forName根据类名进行查找，所以创建了一个java.util.Date类型的变量 可以使用Constructor.newInstance(Object[] args)来调用指定的构造器 5.7.2 捕获异常 try{ }catch(Exception e){ e.printStackTrace(); } 5.7.3 利用反射分析类的能力 反射机制最重要的内容——检查类的结构 java.lang.reflect包中有三个类： Field，描述类的域 Method，描述类的方法 Constructor，描述类的构造器 Field有getType方法，返回描述域所属类型的Class对象。 5.7.4 在运行时使用反射分析对象 Employee harry = new Employee(\"Harry Hacker\",35000,10,1,1989); Class cl = harry.getClass();//拿到Employee对应的class对象 Field f = cl.getDeclaredField(\"name\");//拿到Employee class的name作用域 Object v = f.get(harry);//harry的name field的具体值，即Harry Hacker 该代码有一个问题，name是私有域，因此会爆出错误。只有利用get方法才能得到可访问域的值。除非拥有访问权限，不然只能查看任意对象有哪些域，而不允许读取它们的值。 可以调用setAccessible方法来覆盖访问控制，这样就可以访问私有域了。 另一个问题是get方法返回的是Object，因此如果返回值是double的时候会有问题。此时应该使用getDouble方法，反射机制会自动打包。 泛用的toString()例子 package objectAnalyzer; import java.lang.reflect.AccessibleObject; import java.lang.reflect.Array; import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.ArrayList; public class ObjectAnalyzer{ private ArrayList\u003cObject\u003e visited = new ArrayList\u003c\u003e(); /** * 将一个对象转为列举所有field的数组 * @param obj an object * @return a string with the object's class name and all field names and value */ public String toString(Object obj){ if (obj == null) return \"null\"; if (visited.contains(obj)) return \"...\"; visited.add(obj); Class cl = obj.getClass(); if (cl==String.class) return (String) obj; if (cl.isArray()){ String r = cl.getComponentType() + \"[]{\"; for(int i = 0;i\u003cArray.getLegnth(obj);i++){ if(i\u003e0) r+=\",\"; Object val = Array.get(obj,i); if(cl.getComponentType().isPrimitive()) r += val; else r += toString(val); } return r + \"}\"; } String r = cl.getName(); //inspect the fields of this class and all superclasses do{ r += \"[\"; Field[] fields = cl.getDeclaredFields(); AccessibleObject.setAccessible(fields,true); //get the names and values of all fields for (Field f: fields){ if(!Modifier.isStatic(f.getModifiers())){ if(!r.endsWith(\"[\")) r += \",\"; r += f.getName() + \"=\"; try{ Class t = f.getType(); Object val = f.get(obj); if(t.isPrimitive()) r += val; else r += toString(val); } catch(Exception e){ e.printStackTrace(); } } } r += \"]\"; cl = cl.getSuperclass(); } while(cl != null); return r; } } 5.7.5 使用反射编写泛型数组代码 比如制作一个通用的Arrays.copyOf(array,legnth)，这个方法可以用来扩展已经填满的数组。 第一次尝试： public static Object[] badCopyOf(Object[] a,int newLength){ Object[] newArray = new Object[newLength]; System.arrayCopy(a,0,newArray,0,Math.min(a.legnth,newLength)); return newArray; } 问题在于，该函数返回的是对象数组Object[]，这是基类数组。显然，将基类数组赋值给子类数组会报错。 为了编写通用数组代码，就必须创造与原数组类型相同的新数组，即要用到反射类。最关键的就是java.lang.reflect.Array.newInstance静态方法，它能够构造新数组，调用它时必须提供数组的元素类型和数组的长度。 public static Object goodCopyOf(Object a,int newLength){ Class cl = a.getClass();//拿到对应的class对象 if(!cl.isArray()) return null; Class componentType = cl.getComponentType();//拿到类型 int length = Array.getLength(a); Object newArray = Array.newInstance(componentType,newLength);//创建数组 System.arraycopy(a,0,newArray,0,Math.min(length,newLength)); return newArray; } 此时，CopyOf代码可以扩展任意数组，而不只是对象数组。这也是为什么将a设置为Object类型而非Object[]类型。 5.7.6 调用任意方法 表明上看，java没有方法指针，设计者认为接口是更好的方案。但是反射机制运行用户调用任何方法。 Field类的get方法查看对象域，而Method类有一个invoke方法，允许调用包装在当前Method对象中的方法。 Object invoke(Object obj,Object... args)，第一个参数是隐式参数，其余对象提供显式参数。 对于静态方法，第一个参数可以忽略，设置为null 假设m1为Employee类的getName方法(String getName(void))，则String n = (String) m1.invoke(harry);就直接调用了这个方法。(PS:harry为对应的Employee对象) 得到Method对象可以使用Method getMethod(String name,Class.. parameterTypes)，根据方法的名称和参数类型来得到想要的方法，例如Method m2 = Employee.class.getMethod(\"raiseSalary\",double.class); ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:7","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"5.8 继承设计的技巧 将公共操作和域放在超类 不要使用受保护的域 使用继承实现\"is-a\"关系 除非所有继承的方法都有意义，否则不要使用继承 在覆盖方法时，不要改变预期的行为 使用多态，而非类型信息 不要过多地使用反射 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:5:8","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第6章 接口与内部类 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"6.1 接口 接口不是类，而是对类的一组需求描述，类要遵从接口描述的统一格式进行定义 例如： public interface Comparable{ int compareTo(Object other); } 即要求任何实现Comparable接口的类都需要包含compareTo方法，并且具体事项都是符合的。 接口中的所有方法自动地属于public，因此不必提供关键字public 为了让类实现接口，一般包含两个步骤： 将类声明为实现给定的接口，类定义处仿照继承，implements interfaceName 对接口中的所有方法进行定义 PS：虽然接口并没有把方法声明为public，但是实现接口时，必须把方法声明为public。否则，编译器将认为这个方法的访问属性是包可见性，即类的默认访问属性，之后编译器就会给出试图提供更弱的访问权限的警告信息。 6.1.1 接口的特性 接口不是类，不能进行实例化，比如new等。到那时可以声明接口的变量，例如Comparable x。接口变量必须引用实现了接口的类对象，有点类似于严格限定的抽象基类。 类似地，也可以使用instanceof检查一个对象是否实现了某个特定的接口。anObject instanceof Comparable 接口之间可以继承： public interface Movable{ void move(double x,double y); } public interface Powered extends Movable{ double milsPerGallon(); } 接口不能包含实例域或静态方法，但是可以包含常量： public interface Powered extends Movable{ double milsPerGallon(); double SPEED_LIMIT = 95; // a public static final constant } 接口中的域将被自动设为public static final 每个类只能有一个超类，但是可以实现多个接口. 6.1.2 接口与抽象类 使用抽象类表示通用属性时会存在一个问题：每个类只能扩展于一个类，这使得多个通用属性不能共存。而多个接口可以共同实现。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"6.2 对象克隆 调用clone()执行复制而不是引用。但需要注意，clone方法对属性中的自定义类型只能进行shallow copy。 而且clone方法是protected的，意味着类只能克隆自己。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"6.3 接口与回调 callback是一种常见的程序设计模式，一般我在js见的比较多，或者说C++中的函数指针，在某个事件发生后，直接调用指定的这个可变的函数。 在java中，传递的是一个实现了指定接口的对象。例子就不举了 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"6.4 内部类 即定义在另一个类中的类。内部类可以访问该类定义所在的作用域中的所有数据，并相对于同一个包隐藏起来。 当想要使用一个回调函数而又不想编写过多代码时，可以使用匿名内部类。 C++使用的是嵌套类。嵌套时类之间的关系而并不是对象之间的关系。对于一个嵌套类，可能并不会实现嵌套内的类。而内部类中里面的类会有一个隐式引用，指向实例化该内部对象的外围类对象，因此会很有意思。 static内部类则没有这种附加指针，与C++的嵌套类类似。 6.4.1 使用内部类访问对象状态 内部类可以隐式地访问创建它的外部对象，并使用外部对象域中的所有数据。这个引用在内部类中是不可见的（类似于外部嵌套的块作用域） 这个步骤是编译器自动在构造器中完成的（不太清楚，可能需要自行进行实验） 6.4.2 内部类的特殊语法规则 从正规来说，外围类引用的语法是比较复杂的。OuterClass.this表示外围类的引用，其中OuterClass为外围类的类名。 同时，构造器也可以使用更直观的方式outer Object.new InnerClass(construction parameters) 在外围类的作用域外，可以这样引用内部类：OuterClass.InnerClass 6.4.3 内部类是否有用、必要和安全 编译器使用了特殊的方法来访问，这原则上是破坏了封装。理论上，熟悉类文件结构的黑客可以创建虚拟机指令来调用指定方法的类文件。 6.4.4 局部内部类 即直接在类方法中定义类，这样它的作用域被限定在声明这个局部块中，完全与外部世界隔绝。 6.4.5 由外部方法访问final变量 局部类不仅能够访问外部类，还能够访问局部变量。不过，局部变量必须声明为final。 声明为final的原因是需要局部变量与局部类内建立的拷贝要保持一致。 如果仍然需要更新，则该局部变量可以声明为一个长度为1的数组。数组引用不变，但是其值可以改变，有点类似于C++的常数指针。 6.4.6 匿名内部类 例子 public void start(int interval,final boolean beep){ ActionListener listener = new ActionListener(){ public void actionPerformed(ActionEvent event){ Date now = new Date(); System.out.pritnln(\"At the tone, the time is \"+now); if(beep) Toolkit.getDefaultToolkit().beep(); } }; Timer t = new Timer(interval,listener); t.start(); } 格式类似于new SuperType(construction parameters){inner class methods and data} 其中SuperType可以是接口或者要扩展的类。由于匿名类没有类名，自然也就没有构造器。取而代之，构造器参数传递给超类的构造器。尤其是内部类实现接口的时候，不能有任何构造参数。 6.4.7 静态内部类 如果使用内部类知识为了把一个类隐藏在另外一个类的内部，并不需要内部类引用外围类对象。可以将内部类声明为static，以便取消产生的引用。 当然，只有内部类可以声明为static。静态内部类不存在对生成它的外围类的引用，其他完全一样。在静态方法中构造的内部类必须为静态内部类。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"6.5 代理 运用代理可以在运行时创建一个实现了一组给定接口的新类。该功能只在编译时无法确定需要实现哪个接口时才使用。 我不太感兴趣，直接跳过。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:6:5","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第11章 异常、断言、日志和调试 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"11.1 处理错误 异常分类：所有异常都是由Throwable继承而来。下一层是Error和Exception，Exception下分IOException和RuntimeException。 Error描述了Java运行时系统地内部错误和资源耗尽错误，应用程序不应该抛出这种类型的对象，基本无能为力。 11.1.2 声明已检查异常 如果遇到了无法处理的情况，java方法可以抛出一个异常。因此方法需要告诉编译器可能发生什么错误，在其首部声明可能抛出的异常。public FileInputStream(String name) throws FileNotFoundException，对构造器进行声明，说明可能会抛出FileNotFoundException异常。 多个已检查异常应该使用逗号隔开 不需要声明Java的内部错误（从Error继承的错误），因为任何代码都可能抛出，无法控制。同样，也不应该声明从RuntimeException继承的未检查异常，对于这些错误，更应该将时间花费在修正程序中的错误，而不是说明这些错误发生的可能性上。 11.1.3 如何抛出异常 //1 throw new EOFException(); //或者，2 EOFException e = new EOFException(); throw e; 这个EOFException还接受一个String类型的参数。 找到一个合适的异常类 创建这个类的一个对象 将对象抛出 11.1.4 创建异常类 可能会遇到标准异常类都没有能够充分描述清楚的问题，需要自定义异常类。需要定义一个派生于Exception的类，或者派生于Exception子类的类。 习惯上，该类要包含两个构造器，一个是默认的构造器；另一个是带有详细描述信息的构造器（超类的toString()方法会打印出这些详细信息） ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"11.2 捕获异常 使用 try{ //code }catch (ExceptionType e){ //do something } 来完成异常的捕获。如果方法中的任何代码抛出了catch子句中没有声明的异常类型，那么这个方法就会立刻退出。 11.2.1 捕获多个异常 一个try块可以捕获多个异常，每个异常使用一个单独的catch子句 11.2.2 再次抛出异常与异常链 try{ //some code access db }catch(SQLException e){ throw new ServeletException(\"database error:\"+e.getMessage()); //或者这样 Throwable se = new ServeletException(\"database error\"); se.initCause(e); throw se; //捕获到异常时，可以使用Throwable e = se.getCause();获得原始异常 } 这方面的内容可以看一下这个问题，还挺有意思的。 11.2.3 finally子句 主要是为了解决资源回收问题，比如关闭说几句 不管是否有异常被捕获，finally子句中的代码都被执行。因为在大部分语言中都有这一部分，我就略过了。 11.2.5 分析堆栈跟踪元素 可以调用Throwable类的printStackTrace方法访问堆栈跟踪的文本描述信息。或者使用getStackTrace方法获得StackTraceElement对象的一个数组，从而自行分析。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"11.4 使用断言 在python中经常用assert的选手应该很熟悉这个。即在一些非常关键、非常确信的地方使用该语句，以保证程序的正常运行。 Java中包括assert 条件;与assert 条件:表达式;这两种。如果结果为false，则会抛出一个AssertionError异常。第二种形式中，表达式将被传入AssertionError的构造器，并转换成一个消息字符串。 11.4.1 启用和禁用断言 感觉和python挺不一样的，更多是作为调试手段。可以在运行程序时使用-enableassertions或-ea选项启用。在启用或禁用断言时不必重新编译程序。 也可以在某个包或某个类内使用断言：java -ea:MyClass -ea:com.mycompany.lib... MyApp 11.4.2 使用断言完成参数检查 断言的使用场景： 断言的失败是致命的、不可恢复的错误。 只用于开发和测试阶段。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"11.5 记录日志 11.5.1 基本日志 日志系统管理着一个Logger.global的默认日志记录器Logger.getGlobal().info(\"File-\u003eOpen menu item seelcted\");，会自动包含时间、调用的类名和方法名。 但如果在相应的地方调用Logger.getGlobal().setLevel(Level.OFF);，将会取消所有的日志。 11.5.2 高级日志 自定义日志记录器，调用getLogger方法可以创建或检索记录器 private static final logger myLogger = Logger.getLogger(\"com.mycompany.myapp\") 日志记录器级别：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST，默认只记录前三个级别。 默认的日志记录将显示日志调用的类名和包名，但如果虚拟机对执行过程进行了优化，就得不到准确地调用信息，此时可以使用logp方法获得调用类和方法的确切位置。 11.5.3 修改日志管理器配置 配置文件优先于main方法调用。 不感兴趣，略过。 11.5.5 处理器 处理器可以处理日志记录器发来的记录。对于一个要被记录的日志记录，它的日志记录级别必须高于日志记录器和处理器的阈值。日志管理器配置文件设置的默认控制台处理器的日志记录级别为java.util.logging.ConsoleHandler.level=INFO 另外，还可以安装自己的处理器 Logger logger = Logger.getLogger(\"com.mycompany.myapp\"); logger.setLevel(Level.FINE); logger.setUserParentHandlers(false); Handler handler = new ConsoleHandler(); handler.setLevel(Level.FINE); logger.addHandler(handler); 日志到此略过，感觉这些都好老了。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:7:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"11.6 调试技巧 …建议使用JUnit编写单元测试。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:8:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第12章 泛型程序设计 和C++比较类似，我估计一时半会用不上，先跳过。 一些值得注意的点 调用时可以省略泛型，编译器可以根据参数自动推断。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"12.4 类型变量的限定 public static \u003cT extends Comparable\u003e T min(T[] a) ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"12.7 泛型类型的继承规则 Pair与Pair没什么关系。通常，Pair\u003cS\u003e与Pair\u003cT\u003e没什么联系。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"12.8 通配符类型 Pair\u003c? extends Employee\u003e表示任何泛型Pair类型，它的类型参数是Employee的子类。 12.8.1 通配符的超类型限定 很容易发现12.4的类型变量限定与其很类似。但它还有一个附加的能力，即可以指定一个超类型限定，如下所示? super Manager，这个通配符限制为Manager的所有超类型，可以为方法提供参数，但不能使用返回值。 例如void setFirst(? super Manager)，编译器不知道setFirst方法的确切类型，但是可以用任意Managerr对象调用它，而不能用Employee对象调用。 12.8.2 无限定通配符 例如Pair\u003c?\u003e，返回值一般只能赋予Object Pair与Pair的不同在于，前者可以用任意Object对象调用原始的Pair类的指定方法 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"12.9 反射和泛型 12.8.3 通配符捕获 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:9:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第13章 集合 说实话，这部分我建议红书Algorithm，单纯看操作很容易流于形式，还是需要结合具体的算法才比较好。 熟悉STL的话可以直接略过，没什么不同的。 13.1.2 Java类库中的集合接口和迭代器接口 Java类库中的集合类基本接口为Collection接口，有两个基本方法 public interface Collection\u003cE\u003e { boolean add(E element);//用于向集合中增加元素 Iterator\u003cE\u003e iterator();//返回一个实现了Iterator接口的对象，可以使用迭代器依次访问集合中的元素 } 迭代器： public interface Iterator\u003cE\u003e { E next();//通过反复调用next，可以逐个访问集合中的每个元素 boolean hasNext();//如果还有多个可访问的元素，返回true void remove();//将会删除上次调用next方法时返回的元素（即当前所指的元素）。在调用remove前不调用next是不合法的。 } 迭代器的使用，比较优雅的可以使用For-each for(String element:c){ //do something with element } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:10:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"13.2 具体的集合 13.2.1 链表 动态数组ArrayList存在的问题时，从数组中间删除一个元素要付出巨大的代价。 为此实现了链表LinkedList，可以在任何位置高效地插入和删除。与泛型集合相比，链表是有序集合，其add方法可以将对象添加到链表的尾部或中间（由迭代器实现）。 链表可能出现问题，详见替代操作 List\u003cString\u003e list = new LinkedList\u003cString\u003e(); ListIterator\u003cString\u003e iter = list.listIterator(); String oldValue = iter.next();//拿到第一个值 iter.set(newValue); //给第一个值设置新值。这与前面remove的逻辑相同，在调用next后才能执行正确的逻辑。 13.2.3 散列集 散列表可以很快的计算出散列码，我不太清楚java的hash code是怎么算的，但一般来说都是唯一的。 HashSet类，散列表集合。该散列表使用的是桶实现，将散列表对桶的总数求余，得到的结果为保存这个元素的桶的索引。会碰上散列冲突问题，因此每个桶内部应该是链表。 13.2.4 树集 树集是有序集合，可以以任意形式插入但是顺序输出。TreeSet使用的是红黑树，效率会略高于HashSet，但是可以接受。 13.2.7 优先队列 说实话这个我用的比较多，因为红黑树比较难写。优先队列一般是堆，每次弹出优先级最高的任务。 13.2.8 映射表 map映射表，根据某些键的信息来查找与之对应的元素。HashMap是非常常用的工具。 与散列表不同，映射表中键是唯一的，同一个键中后赋的值会直接覆盖先赋的值。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:10:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"13.3 集合框架 提供了一个从更高角度看类实现的方式，挺有意思的。写起来比较麻烦，建议看原书。 13.3.2 批操作 目前为止的大部分例子都使用迭代器来进行，同时也可以使用bulk operation批操作来避免频繁地使用迭代器。 比如 Set\u003cString\u003e result = new HashSet\u003c\u003e(a); result.retainAll(b);//保留在a与b中都出现的元素看，构成交集 13.3.3 集合与数组之间的变换 数组变为集合可以使用Arrays.asList包装器 集合变数组可以使用toArray方法，但是不能直接调用（因为返回的是Object[]类型），而是应该String[] values=staff.toArray(new String[0])，将每个值在内部进行类型转换。 后续略过 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:10:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"第14章 多线程 java并发是非常复杂的，这里只能简单地学习一下 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:0","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.1 什么是线程 让我来回答的话就是进程内的子程序，是独立调度和分派的基本单元。多线程技术可以把容易阻塞的IO和人机交互功能与密集计算功能分开执行，从而提高程序的执行效率。 如何启动线程 将任务代码移到实现了Runable接口类的方法中。 public interface Runnable{ void run();//这个接口非常简单，就只需要一个方法 } class MyRunnable implements Runnable{ public void run(){ //task code } } 创建一个类对象，并基于此创建Thread对象，启动进程。 Runnable r= new MyRunnable(); Thread t = new Thread(r); t.start() PS：如果直接调用run方法，只会执行同一个线程中的任务，而不会启动新线程。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:1","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.2 中断线程 自然终止：当线程的run方法执行方法体中的最后一条语句后，经由执行return语句返回，或者出现了方法中没有捕获的异常，线程将终止。 强制终止：调用interrupt方法可以用来请求终止线程。原理是调用该方法后，线程的中断状态将被置位。每个线程都会不时检查这个标识，以判断线程是否被中断。Thread.currentThread().isInterrupted() 但，如果线程被阻塞，就无法检测终端状态。此时会被Interrupted Exception异常中断。 没有任何一个语言方面的需求要求一个被中断的线程应该被终止，中断一个线程不过是为了引起它的注意，被中断的线程可以决定如何响应中断。线程一般将中断你作为一个终止的请求。 如果长期处于阻塞状态，应该检测InterruptedException异常 public void run(){ try{ while(more work to do){ //do more work Trhead.sleep(delay); } }catch(InterruptedException e){ //thread was interrupted during sleep }finally{ //clean up, if required } //exiting the run method terminates the thread } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:2","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.3 线程状态 线程有六种状态： New 新创建 Runnable 可运行 Blocked 被阻塞 Waiting 等待 Timed waiting 计时等待 Terminated 被终止 要确定一个线程的当前状态，可以调用getState方法 14.3.1 新创建线程 New：当调用new Thread(r)时，线程还没有开始运行 14.3.2 可运行线程 一旦调用thread的start方法，就是可运行状态。其是否运行，取决于操作系统给线程提供运行的时间。且一旦一个线程开始运行，它不必始终保持运行 14.3.3 被阻塞线程和等待线程 此时暂时不活动，直到线程调度器重新激活它。 当一个线程试图获取一个内部的对象锁，而该锁被其他线程持有，则该线程进入阻塞状态。当锁释放后，该线程将变为非阻塞状态 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态。被阻塞状态与等待状态有很大的不同。 有几个方法有超时参数，调用它们导致线程进入计时等待。这一状态将一直保持到超时期满或者接受到适当的通知。 14.3.4 被中止的线程 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:3","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.4 线程属性 包括线程优先级、守护线程、线程组以及处理未捕获异常的处理器。 线程优先级：默认情况下，一个线程继承它的父线程的优先级，可以使用setPriority方法设置一个MIN_PRIORITY1与MAX_PRIORITY10之间的任何值，默认是5. 14.4.2 守护线程 可以通过t.setDaemon(true)将线程转换为守护线程，为其他线程提供服务。如果只剩下守护线程，VM将退出。 守护线程不应该去访问固有资源，如文件、数据库因为它会在任何时候甚至任何一个操作的中间发生中断。 14.4.3 未捕获异常处理器 线程的run方法不能抛出任何被检测的异常。但是也不需要catch子句来处理可被传播的异常，在线程死亡之前，异常被传递到一个用于未捕获异常的处理器。 该处理器必须属于一个实现Thread.UncaughtExceptionHandler接口的类，这个接口只有一个方法void uncaughtException(Thread t,Throwable e)。可以使用setUncaughtExceptionHandler方法为任何线程安装一个处理器，也可以用静态方法setDefaultUncaughtExceptionHandler为所有线程安装一个默认的处理器。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:4","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.5 同步 这个就是操作系统的相关知识了，不赘述 14.5.3 锁对象 有两种机制防止代码块受到并发访问的干扰，一个是synchronized关键字，它自动提供了一个锁以及相关的条件，在需要显式锁的时候是很便利的。 第二个是ReentrantLock类，使用例子如下： myLock.lock(); // a ReentrantLock object try{ //critical section }finally{ myLock.unlock(); } 这一结构确保任何时候只有一个线程进入临界区。一旦一个线程封锁了对象，其他任何线程都无法通过lock语句，他们会被阻塞直到第一个线程释放锁对象。 PS：把解锁语句放在finally中至关重要，不然临界区的代码如果抛出异常，锁必须释放。 14.5.4 条件对象 线程进入临界区之后，要满足某一条件才能执行。该条件限制获得锁但是不能做有用工作的线程。 可以使用conditionName = newCondition()方法来设定新的条件对象。如果不满足条件，线程会调用conditionName.await()方法放弃锁。放弃锁与没获得锁有本质上的不同，它的阻塞状态直到条件满足后才能解除。 条件满足使用conditionName.signalAll()满足，激活所有因为这一条件等待的线程。 14.5.5 synchronized关键字 如果一个方法使用synchronized关键字声明，那么对象的锁将保护整个方法。即下面两个是相等的 public synchronized void method(){ //method body } //等价于 public void method(){ this.intrinsicLock.lock(); try{ //method body }finally{ this.intrinsicLock.unlock(); } } 14.5.6 同步阻塞 每一个Java对象有一个锁，线程可以通过调用同步方式获得锁。另外一个获得锁的机制就是进入一个同步阻塞 synchronized(obj){ //critical section } 14.5.7 监视器概念 监视器monitor，可以在不需要程序员考虑加锁的情况下，保证多线程的安全性。 监视器的特性： 是只包含私有域的类 每个监视器类的对象有一个相关的锁 使用该锁对所有方法进行加锁。比如调用obj.method()，则obj对象的锁在方法调用开始时自动获得，并且当方法返回时自动释放。 该锁可以有任意多个相关条件 但是Java类和监视器差距很大 14.5.8 Volatile域 如果仅仅为了读写一个或两个实例域而使用同步，开销过大。 volatile域为实例域的同步访问提供了一种免锁的机制。如果声明一个域为volatile，那么编译器和虚拟机就知道该域可能被另一个线程并发更新。 private boolean done; public synchronized boolean isDone(){return true;} public synchronized void setDone(){done = true;} //上述使用内部锁，但是并不一定是个好主意 private volatile boolean done; public boolean isDone(){return true;} public void setDone(){done = true;} //但是不保证原子性 14.5.14 读/写锁 java.util.concurrent.locks包定义了两个锁类，即ReentrantLock类和ReentrantReadWriteLock类。后者解决了操作系统中的读/写者问题，允许对读者线程共享访问控制，写者进行互斥访问控制。 创建对象private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock(); 声明读写锁private Lock readLock = rwl.readLock();与private Lock writeLock = rwl.writeLock(); 对所有获取方法加读锁 public double getTotalBalance(){ readLock.lock(); try{ //some method }finally{ readLock.unlock(); } } 对所有修改方法加写锁 public void transfer(...){ writeLock.lock(); try{ //some method }finally{ writeLock.unlock(); } } ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:5","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.6 阻塞队列 应该是为了解决生产者-消费者问题。实际编程应该尽量原理基本结构，并使用高层结构。 java.util.concurrent包提供了阻塞队列的几个变种。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:6","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.7 线程安全的集合 如果多线程要并发地修改一个数据结构，那会很容易破坏它。 14.7.1 高效地映射表、集合和队列 java.util.concurrent包提供了映射表、有序集和队列的高效实现： ConcurrentHashMap ConcurrentSkipListMap ConcurrentSkipListSet ConcurrentLinkedQueue 与大多数集合不同，size方法不必在常量时间内操作，而是需要遍历。 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:7","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.8 Callable与Future Runnable封装一个异步运行的任务。Callable与其类似，但是有返回值。 public interface Callable\u003cV\u003e{ V call() throws Exception; } Future保存异步计算的结果（有点类似最近看到最新JS的那个future）。可以启动一个计算，将Future对象交给某个线程，然后忘掉它。Future的所有者在结果计算好之后就可以获得它。 public interface Future\u003cV\u003e{ V get() throws ...; V get(long timeout, TimeUnit unit) throws; void cancel(boolean mayInterrupt); boolean isCancelled(); boolean isDone(); } 第一个get方法的调用被阻塞，直到计算完成；如果在计算完成之前，第二个方法的调用抄书，抛出一个TimeoutException异常。如果运行该计算的线程被中断，两个方法都将抛出InterruptedException。如果计算已经完成，那么get方法将立即返回。 可以使用cancel方法取消计算。 FutureTask包装器，可以将Callable转换成Future和Runnable，它同时实现两者的接口： Callable\u003cInteger\u003e myComputation = ...; FutureTask\u003cInteger\u003e task = new FutureTask\u003cInteger\u003e(myComputation); Thread t = new Thread(task);//task is a Runnable t.start(); ... Integer result = task.get();//task is a Future ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:8","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.9 执行器 构建线程有一定的代价。如果程序中创建了大量生命期很短的线程，应该使用线程池(thread pool)。线程池中包含许多准备运行的空线程，将Runnable对象交给线程池，就会有一个线程调用run方法。 当run方法退出时，线程不会死亡，而是在池中准备为下一个请求提供服务。 另一个使用线程池的理由：减少并发线程的数目。 执行器Executor类，使用许多静态工厂方法来构建线程池： newCachedThreadPool。构建线程池，如果有空闲线程可用则立刻执行；否则，创建一个新线程。 newFixedThreadPool newSingleThreadExecutor newScheduledThreadPool newSingleThreadScheduledExecutor ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:9","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["Java基础学习"],"content":"14.10 同步器 java.util.concurrent包提供能帮助人们管理相互合作的线程集的类： CyclicBarrier：允许线程集等待直到其中预定数目的线程到达一个公共障栅barrier，然后可以选择执行一个处理障栅的动作。 CountDownLatch：允许线程集等待直到计数器为0 Exchanger：允许两个线程在要交换的对象准备好时交换对象。 Semaphore：允许线程集等待直到被允许继续执行为止 SynchronousQueue：允许一个线程把对象交给另一个线程 ","date":"2021-03-03","objectID":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/:11:10","tags":["Java","计算机书籍阅读笔记"],"title":"《Java核心技术 卷I：基础知识》读书笔记","uri":"/posts/20210303_java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E5%8D%B7i%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"categories":["计算机论文阅读"],"content":"A two-phase cloud resource provisioning algorithm for cost optimization ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:0:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"1 Introduction 主要的三种付费方式： On-demand pricing model Reserved pricing model spot pricing model 现有的模型大多都只考虑了on-demand的收费方式，有一些考虑了on-demand和reserved的收费方式。但是它们的目标都只是使用reserved收费的资源来满足最低服务需求，并用on-demand的资源来满足剩余需求。 本文的目标是找到最佳的实例数，即resource provisioning problem。为了降低资源的租用成本，本文使用了on-demand和reserved instance两种方式来进行一个两阶段的资源分配，并决定最佳的reserved instance的实例数来最小化花费。为此，需要基于预测的流量信息来满足SLA的要求。 主要贡献： 使用on-demand和reserved instance的两阶段资源部署算法来减少资源租用花费 在第一阶段，将资源配置问题建模为two-stage stochastic programming problem，并用sample average approximation的方式和dual decomposition method的方式来求解 在第二阶段，使用ARIMA-Kalman model来预测流量，并决定on-demand的实例数量。 使用现实世界的流量和Amazon EC2购买模型来验证结果。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:1:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"2 related work 主要提到了云资源分配问题可以被建模为stochastic programming problem，然后使用branch and bound and cutting plane method求解，或者使用启发式方法，比如genetic algorithm, particle swarm optimization, hybrid algorithm等。一般使用PSO来探索解空间，使用GA来更新结果。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:2:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"3 Problem Formulation 本节主要内容为模型的假设，包括VM的配置与价格模型。基于这些假设，我们可以对云资源分配问题进行建模。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:3:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"3.1 云环境 云资源提供商提供多种不同的VM给用户，$V={V_1,…,V_M}$代表了不同种类的虚拟机，M为虚拟机的种类。每一个VM的种类有着自己的资源配置和处理容量。令$C_i$表示$V_i$类虚拟机在不违反QoS的情况下所能处理的最大并发用户数或者最大服务请求速率。 我们采用小时计费的方式，并考虑两种不同的模型：on-demand实例和instance实例。令$p_i^o$表示类型$V_i$的on-demand费用，令$p_i^R$与$p_i^r$分别代表reserved instance的总支付费用与每小时费用。令$T$代表reserved instance的使用时间。这样，虚拟机类型$V_i$的实际成本为$p_i^R/T+p_i^r$，即平均每小时的总费用加上每小时的实际费用。一般来说，reserved instance的每小时费用都要低于on-demand的付费。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:3:1","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"3.2 Cloud Resource Provisioning Problem 在一个reservation period中考虑这个cloud resource provision problem，令t=1,2,…,T为该reservation period中的hour index，令$d_t$为时间t时的workload，$R=(n_1^r,n_2^r,…,n_M^r)$表示reservation decision，其中$n_i^r$为$V_i$类虚拟机的数量。这样，就可以计算出reserved实例的processing capacity $\\sum_{i=1}^{M}n_i^r C_i$，以及总费用。 对于每一个时间点t，如果reserved instance能够满足需求，显然也没有再购买on-demand资源的必要 因此，on demand的使用费用可以写为$U(R,d_t) = min \\sum_{i-1}^M n_{ti}^o p)i^o$，其中$n_{ti}^o$就是类型$V_i$在时间t所使用的on-demand的实例数 此时，resource reservation problem可以建模为最小化reserved instance费用与on-demand instance的费用。显然这个问题是依赖于reservation阶段的流量的，这个在现在来说是不知道的，但我们可以基于历史数据来预测流量的分布情况$p_D(d)$。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:3:2","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"4 Resource Reservation ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:4:0","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"4.1 Sample Average Approximation(SAA) 如果scenarios的数量比较大的话，直接求解前面的最优化式子是非常困难的。sample average approximation就是用来减少scenarios数量的方法。考虑到workload是一个一维的随机变量，就可以使用uniform discretization grid来产生一个scenarios的集合${\\tilde{d_1},\\tilde{d_2},…,\\tilde{d_N}}$，其中$N$是采样大小。用采样结果来拟合复杂的概率结果，化简two-stage stochastic problem。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:4:1","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"4.2 Dual Decomposition-Based Branch and Bound (DDBnB) scenario decomposition是引入copy $R_j$作为每个scenario中第一阶段决策动作$R$，然后重新建模原问题。 ","date":"2021-03-01","objectID":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/:4:2","tags":["云资源调度"],"title":"A two-phase cloud resource provisioning algorithm for cost optimization","uri":"/posts/20210301_a-two-phase-cloud-resource-provisioning-algorithm-for-cost-optimization/"},{"categories":["计算机论文阅读"],"content":"未完成 本次阅读的关注重点是，如何根据已经给定的流量需求来分析所需要的满足SLA的实例数量？ 是否可以用强化学习来进行？ Business-Driven Long-Term Capacity Planning for SaaS Applications 2015 TCC ，没记错应该是C类 ","date":"2021-03-01","objectID":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/:0:0","tags":["云资源调度"],"title":"Business-Driven Long-Term Capacity Planning for SaaS Applications","uri":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/"},{"categories":["计算机论文阅读"],"content":"摘要 本文关注的是capacity planning，从定义上，该技术的目标是估计提供计算资源所需的资源数量，从而实现高的QoS级别，为公司带来更高的经济效益。 在现实中，可以有这样的场景，SaaS出于经济效益的考虑去购买IaaS服务商的实例。这样，SaaS可以减少在操作上的花费与复杂度，但是需要对自身的长期资源使用情况进行一定程度的估算。 本文采用了模拟实验，使用同步的电子商务数据流。分析显示，使用启发式方法来优化能够每年提升9.65%的利润。 重点在于启发式搜索的方式 ","date":"2021-03-01","objectID":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/:1:0","tags":["云资源调度"],"title":"Business-Driven Long-Term Capacity Planning for SaaS Applications","uri":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/"},{"categories":["计算机论文阅读"],"content":"3 Utility model Utility是微观经济学上的概念，用来描述客户的偏好。一般而言，更大的值代表了更高的偏好性。因此，客户的行为也会受到Utility的影响，即他们会倾向选择最喜欢的输出。 Utility function将outcome映射到utility value上。 本文提出的Utility model将SaaS的利润（作为提供一个应用的结果）映射到utility value上。这样，一个capacity planning的agent就可以使用本模型来制作capacity plan来最大化utility value。此时，就可以达到SaaS provider的最大利润。 ","date":"2021-03-01","objectID":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/:2:0","tags":["云资源调度"],"title":"Business-Driven Long-Term Capacity Planning for SaaS Applications","uri":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/"},{"categories":["计算机论文阅读"],"content":"3.1 Revenue model utility model认为SaaS provider可以提供一个或多个计划给他们的顾客，每一个顾客根据自身的需要选择一个计划并与SaaS provider签订合同。 revenue model包括： SaaS consumer周期性地收取费用（每月或每年） 每一个application有着使用限制，由provider提供 合同包括赔偿条款，即SLA违约的情况 SaaS将提供应用A给一个SaaS顾客的集合$U={u_1,…,u_{|U|}}$。同时，SaaS provider会构建一个计划的集合$P={p_1,…,p_{|P|}}$，每一个计划$p_j$会满足一类顾客的需求，因此期望上$|P|\u003c|U|$，每一个顾客会选择一个计划来使用应用A。 在签订计划后，顾客$u_k$可以在时间$[n_k^b,n_k^e]$区间内使用应用A，比如如果$p_j$是半年计划，这两个时间点的差值就是六个月。简单期间，SaaS提供的所有计划都以一个月作为最小单位。并且，新的顾客只能在每一个周期$n$到达之后才能加入，n随着时间推移单调递增。 顾客$u_k$签订合同之后，SaaS provider就必须配置并部署应用A来服务。之后，顾客$u_k$需要支付配置费用configuration fee$I_j^b$，该费用由计划$p_j$决定。 后续太罗嗦了就省了。本文的核心模型是utility model，就是一个收益模型，利润=总收入-总支出，基本没用。 核心算法有两个 一个是utilization model，这个utilization指的是reserved instance的利用率，比如说一个reserved instance买一年，需要有效使用50%才能比单纯买on-demand便宜，这个50%就是utilization。 然后这个算法本身的输入是包含了一个trace，就是说实例是预先分配好的，后续的工作只是在不同的云服务提供商中通过启发式方法比较出最优的那一家。就……挺不相关的。 ","date":"2021-03-01","objectID":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/:2:1","tags":["云资源调度"],"title":"Business-Driven Long-Term Capacity Planning for SaaS Applications","uri":"/posts/20210301_business-driven-long-term-capacity-planning-for-saas-applications/"},{"categories":["面试相关"],"content":"简历的内容 简历，总结而言是经历的总结。 简历自答： 用一句话或者三个词描述自己是一个怎么样的人 我热爱/喜欢做的事情是什么 我擅长做的事情是什么/特长/核心竞争力 我的目标是什么（短期/长期） 我的近两个i有哪些(自我总结) 由五个小问题引出两个总结性的问题：定位思考与职业匹配 一个例子： 教育背景（记得加学期、可以写GPA） 专业技能 项目经历（文字要凝练，做了什么，什么身份 科研成果（亮点突出，一句话能让第一眼能让面试官判断，论文几篇、什么量级） 实习经历（量化描述，用数据支撑自己在实习期间做的事情。用一句话，因为你给这个项目、给公司带来了哪些不同。如果没有实习经历，尽量还是要找一个实习经历） 竞赛成绩（标注量级） 获奖情况（奖学金情况，标注量级） 校园活动 其他经历 ","date":"2021-02-24","objectID":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:0","tags":["学习笔记"],"title":"阿里春招简历小课堂笔记","uri":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["面试相关"],"content":"注意事项 简历中的文字颜色不应该超过两种，最好只使用一种，不要加粗，且格式最好保持前后一致。 ","date":"2021-02-24","objectID":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:1","tags":["学习笔记"],"title":"阿里春招简历小课堂笔记","uri":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["面试相关"],"content":"总结 七颗龙珠： 真实诚信。而且大公司简历会在系统中留档 自我总结 亮点突出 量化描述 文字凝练（一眼看懂，不用思考，简单明了，重点突出） 格式整洁（全文上下保持同一格式，不要加过多的颜色，由其是文字颜色） 一页为佳 ","date":"2021-02-24","objectID":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:1:2","tags":["学习笔记"],"title":"阿里春招简历小课堂笔记","uri":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["面试相关"],"content":"春招信息 开启时间：3月份 信源：钉钉校招群，阿里官网 申请机会：春招秋招各两次，分别是网申和内退。春招通过之后，秋招可以有直通面试。 春招没有过，秋招不受影响 实习一般多久？最少一个月，可以两个月到三个月。疫情期间开放远程实习，但是建议现场实习。 无法来实习，仍然建议参与春招，来积累经验，体验过程。 内推过程：集团内部的同学将我的简历放到系统里面，然后会发一个链接，我再进行完善。 春招有日常实习。 ","date":"2021-02-24","objectID":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/:2:0","tags":["学习笔记"],"title":"阿里春招简历小课堂笔记","uri":"/posts/20210224_%E9%98%BF%E9%87%8C%E6%98%A5%E6%8B%9B%E7%AE%80%E5%8E%86%E5%B0%8F%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"},{"categories":["计算机论文阅读"],"content":"Temporal fusion transformers for interpretable multi-horizon time series forecasting ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:0:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"摘要 文章关注的是multi-horizon forecasting，这方面包含了很多的输入数据，包括static covariate，known future input，以及其他只在过去被观察到的外源时间序列（即没有它们如何与目标值交互的信息）。 作者指出现有的这些模型都是黑盒模型，并没有展示出它们如何使用当前场景的所有输入。在本文中，我们介绍了Temporal Fusion Transformer，一个新的基于attention的架构，包含高性能的多领域预测与时域上可解释的功能。 为了学习不同尺度上时域的关系，TFT使用了循环层来进行本地的处理与可解释的自注意力层，用作长期依赖。 TFT使用特殊的组件来选择相关的特征，以及使用一系列的门机制来抑制不必要的组件，允许在大范围内都具有较强的性能。 通过一系列真实世界的数据库，我们证明了其卓越的性能。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:1:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"1 Introduction 与one-step-ahead prediction相比，multi-horizon forecast显得更为常用。（不太清楚static covariate到底是什么，听起来有点像是多变量时间序列预测） 传统的multi-horizon forecasting应用可以访问大量的数据源，包括未来已经知道的数据（比如假期的时间）、其他外源的时间序列数据（比如游客的流量）以及静态的元数据（商店的位置），但是我们不知道它们是如何与最终的目标数据进行交互的。 DNN使用注意力机制与循环神经网络来加强对过去相关的时间步的选择，包括Transformer-based model。 现有的这些模型大多都是黑盒模型，其中的参数之间包含了复杂的非线性关系。这使得实现模型难以解释它们的预测结果，使得用户难以去相信模型的输出并让模型建设者去进行修改与调试。 可惜的是，通用的可解释性方法并不适用于时间序列。在它们过去的工作中（LIME和SHAP）并咩有考虑输入特征的时间顺序问题。 核心的贡献包括： static covariate encoder，对一些静态的数据进行编码并送入到神经网络中。 贯穿全局的门机制与基于样本的变量选择，来最小化不相关输入的贡献。 Seq2Seq的架构来进行本地处理已知输入 temporal self-attention decoder层，来学习长期关系 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:2:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"2 Related work multi-horizon预测可以分为两种： Iterated approaches，使用One-step-ahead prediction model，并重复调用多次。 另一方面，直接方法被训练来直接预测多个预定义的horizon，它们的架构一般是基于Seq2Seq模型。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:3:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"3 Multi-horizon forecasting 时间序列预测的定义 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:4:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4 Model Architecture 主要部件 Gating mechanism，用来跳过架构中没有使用的组件，提供一种自适应的深度和网络复杂度来应对不同的环境 Variable selection network，用来选择一个时间步内相关的时间序列 Static covariate encoder，用来将静态特征整合进网络中。 temporal processing，用来学习长期和短期的特征，从观察值和已知值中得到随时间变化的输入。一个Seq2Seq层用来进行本地处理，同时长期依赖关系被可解释的attention block捕捉。 Prediction interval，使用quantile forecast进行预测。但是这个可以不用做进一个模型里面，传统的时间序列预测方法中就有类似的做法。 我的感觉是，最大的区别在于attention层的位置。原版中attention层是在每一个Block中的，总共有6个Block来组成一个区域。而现在TFT只在中间使用了一个self-attention层，更接近于原本的Seq2Seq模型。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:0","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.1 Gating mechanisms 外部输入与目标的关系一般是不知道的，这使得知晓哪些变量是相关变得非常困难。更重要的是，决定是否采用非线性处理同样非常困难，有些时候使用简单的模型可能效果反而更好，比如数据集很小或者充满噪声。 作者实现了Gated Residual Network，输入为已知输入a和可选context vector c。与传统的Transformer相比， 核心层是Gated Residual Network，$GRN(a,c) = LayerNorm(a+GLU( … )))$，与原版的区别有两个，一个是使用了GLU来抑制不需要的输入变量，一个是用了ELU(Exponential Linear Unit activation function)，ELU的一个性质是当输入远远大于0的时候会作为identity function，当其远远小于0的时候则是一个常数。 GLU则是使用了sigmoid来进行激活函数，并做Hadamard乘积来完成这个压制功能。GLU可以控制GRN中原始输入a的贡献。GLU的输出接近于0的时候这就是一个跳层，从而抑制非线性关系的贡献。dropout在Layer Norm之间进行。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:1","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.2 Variable Selection Network 虽然知道有很多的输入变量，但是它们之间的相关性与对输出的贡献仍然是未知的。 变量选择网络除了让TFT知道哪一个变量是最重要的之外，同样使得它能够移除不必要的、可能对性能产生负面效果的noisy input。 使用entity embedding来作为分类变量的特征表示方法，对连续变量用线性转换（使得向量长度符合网络要求）。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:2","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.3 Static Covariate Encoder 与其他的时间序列预测架构不同，TFT将静态的元数据中有用的信息也整合进了预测过程中。 这一部分产生context vector，四个context vector会作为输入导入到不同的网络过程中。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:3","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.4 Interpretable mutli-head attention 说实话没太看明白，不过这里主要的改进不是对注意力机制本身，而是对其可解释性。具体来说是对A函数进行修改。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:4","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.5 Temporal Fusion Decoder 这里都没怎么看明白，比较细节 4.5.1 Locality Enhancement with Sequence-to-Sequence Layer 作者在这里支出，时间序列中的点的重要性并不是由它自己决定的，而是由它周围的值决定的，比如离群点、变点或者循环模式等。通过利用本地内容，构建利用特征信息的特征，就可以提升最终的预测性能。 比如[12]采用了单个CNN来进行locality enhancement，使用同一个过滤器来提取本地的特征。但是对于observed input存在的情况下，这种方法可能并不成立，因为过去和未来的输入并不总是一致的。 为此，作者实现了Seq2Seq架构的模型来处理这种特征维数的变化，将前k个给encoder，将后d个给decoder，然后产生一组时序特征，输入到decoder中。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:5","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"4.6 Quantile outputs 我不太清楚为什么置信区间输出是放在神经网络里面的，从理论上置信区间输出应该是根据过去预测值与过去真实值的残差进行的，通过对残差的方差进行估计，拟合正态分布可以得到未来的预测值的置信区间。 文中输出的是10th,50th和90th，产生的方法是对原预测值进行线性转换。但是监督数据是怎么来的，挺奇怪的。 ","date":"2021-02-15","objectID":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/:5:6","tags":["时间序列预测"],"title":"Temporal fusion transformers for interpretable multi-horizon time series forecasting","uri":"/posts/20210215_temporal-fusion-transformers-for-interpretable-multi-horizon-time-series-forecasting/"},{"categories":["计算机论文阅读"],"content":"Wen Q, Sun L, Song X, et al. Time series data augmentation for deep learning: A survey[J]. arXiv preprint arXiv:2002.12478, 2020. 一篇关于时间序列增强的论文，很有意思。 Time Series Data Augmentation for Deep Learning: A Survey ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:0:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"摘要 时间序列相关的问题中，时间序列数据可能并不充足。因此，数据增强方式（CV中所使用的）就变得十分重要了。 同时从经验上比较不同的时间序列数据增强方式，比如时域与频域、增强组合，以及对不平衡类的加权。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:1:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"1 Introduction 基于时间序列的各种工作都取得了比较好的成绩，但是这些成功都严重依赖于大量的训练数据来避免过拟合。很不幸的是，并不是所有的时间序列工作都有这么充足的训练数据，因此数据增强方法对于一个成功的深度学习模型来说是非常重要的。 数据增强的基本想法是产生合成的数据集来覆盖没有探索到的输入空间，并维护正确的分类标签。数据增强方法在AlexNet于图像分类任务中得到了验证。 尽管如此，很少有工作注重于通过增强方法找到更好的时间序列数据。 时间序列数据的本质属性并没有被现在的数据增强方法所使用。时间序列数据的一个重要属性是所谓的temporal dependency。时间序列数据可以被转换为时域和频域，因此可以基于这个来设计数据增强方法，并被用于转换的领域。特别是作用于多变量时间序列预测中。因此，简单的将图像或者语言处理领域的增强方法使用过来可能并不会产生比较好的效果。 此外，数据增强方法是基于任务的。比如，对于时间序列分类任务有效的增强方法并不一定对异常检测有效。 此外，时间序列分类问题中可能会遇到类别不均匀的情况，如果产生比较平衡的类别数据也是一个问题。 结构：首先从时域的简单转换开始。 讨论更多时间序列中的高级转换，在时域与频域变换方面 引入高级方法，比如基于分解的方法、基于模型的方法、基于学习的方法等。最后还介绍了GAN在时间序列领域的应用。 基于分解的方法：就是普通的时间序列分解方法，把时间序列分解为趋势项+周期项+残差 基于模型的方法，使用统计学方法学习数据，并用这个模型产生更多的数据 数据压缩方法：GAN方法 评价方法在时间序列预测、时间序列分类与时间序列异常检测中进行。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:2:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"2 Basic Data Augmentation Methods ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:3:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"2.1 Time Domain 时域上的变化是最直接的，比如注入高斯噪声或更复杂的噪声（spike、step-like trend、slope-like trend）此外还有在异常检测领域中使用的标签扩展方法 窗口剪切(window cropping or slicing)与CV中的切割是类似的。这是一种降采样的方法，随机地从原始时间序列数据中提取连续片段。对于分类问题，片段的类别与原始类别是一样的， Window wrapping是类似于DTW的方法，选择一个随机地时间分安慰，然后对其进行上采样或者降采样 flipping时是一种通过翻转产生新序列的方法，其值为原时间序列的相反数，然而标签始终是相同的。 另外一种转换方法在Fawaz 2018中被提到，使用DTW和基于DBA的组合方法来产生新的时间序列，其在UCR数据集的分类效果提升显著。 噪声注入，是将小规模噪声或离群点注入时间序列，同时不改变其标签。注入包括高斯噪声，spike（尖峰） 标签扩展方法，这是为时间序列异常检测所使用的。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:3:1","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"2.2 Frequency Domain 大部分的数据增强方法注重于时域，但是也有部分方法放在了频域上。 比如Gao 2020的工作对振幅amplitude spectrum和周期phase spectrum进行利用，使用了基于CNN的异常检测。 使用高斯噪声来代替原本的振幅，phase的值由原本的随机选择片段加上一个均值为0的高斯噪声。这被称为APP方法。 Lee 2019提出了AAFT和IAAFT，在傅里叶变换中采用随机地phase shuffle in phase spectrum，使用rank-ordering的时间序列在inverse FFT中。这样时间序列经过变化后能够保留时序相关性、power spectra和amplitude的分布 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:3:2","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"2.3 time-frequency domain 时域-频域分析是时间序列分析的重要技术，可以用来构建神经网络输入数据。但是这方面的工作同样较少。 Steven Eyobu and Han, 2018采用short FFT来为传感器数据产生时域-频域特征，指导人类活动分类任务的数据增强，使用LSTM网络。 用了两种数据增强方式，一种是基于定义的评价标准进行了本地的平均化，对产生的特征集合的特征进行了平均。另一种是打乱了特征向量来产生变化。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:3:3","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"3 Advanced Data Augmentation Methods 略过，Learning-based的可能可以看一下，但我不觉得GAN对时间序列预测有什么帮助。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:4:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"4.3 Time Series Forecasting 作者实现了MQRNN、DeepAR与Transformer，使用第二部分提到的数据增强方法，平均每个方法都有16%以上的强化，对于m4-hourly数据集提升特别显著，MQRNN提升了一倍多，其他的也有50%。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:4:1","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"5 Discussion and Future work 时域与频域分析上，CWT和DWT等小波变换方法值得考虑。 如何将不同的增强方法组合起来也是值得让人思考的。 ","date":"2021-02-03","objectID":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/:5:0","tags":["时间序列预测","综述文章"],"title":"Time Series Data Augmentation for Deep Learning: A Survey","uri":"/posts/20210203_time-series-data-augmentation-for-deep-learning_a-survey/"},{"categories":["计算机论文阅读"],"content":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions 2021 International Journal of Forecasting 文章对基于RNN的时间序列预测方法进行了比较全面地综述，而且这是发表在IJF上的文章，意味着这篇文章会更偏向于预测本身，而不是模型。 文章结构：第二部分是背景知识，包括传统univariate forecasting technique和不同的NN预测；第三部分包括RNN的实现细节和相关的数据预处理方法；第四部分解释了本文评测时所用的方法与数据集；第五部分进行了批判性的分析；第六部分进行总结；第七部分给出对未来的表述。 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:0:0","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"第二部分 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:1:0","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"2.1 Univariate Forecasting 传统的单变量方法即为时间序列基于其过去的值来完成对未来值的预测，即给定序列X={x1,x2,…,xT}，需要完成{X_{T+1},…,X_{T+H}} = F(x1,x2,…,xT) + \\epislon，这里的F是一个函数，经过序列X的训练产生得到，H是预测的跨度（horizon）\\ 传统的时间序列预测方法在NN3、NN5和M3竞赛上都取得了最佳成绩，它们在数据量很小时表现非常好。但是由于数据量的限制，它们面对大量数据时的表现就不如机器学习算法了。 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:1:1","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"2.2 ANN 之前一直使用的是传统的FCNN，但是目前更多用的是RNN。RNN的cell比较常用的有Elman RNN cell, LSTM和GRUB，此外还有一些其他的架构。这些架构都同时在时间序列预测领域和自然语言处理中得到了使用。 一些架构介绍： Smyl所用的简单复合LSTM，他后来将其与ES算法结合并取得了M4竞赛的冠军 Seq2Seq，被Sutskever引入。传统的S2S架构中Encoder与Decoder都是RNN，这方面比较出色的工作是Amazon的DeepAR。在后续的一些工作中，S2S架构不再作为直接的预测手段，而是作为一种特征提取方式被整合进时间序列预测框架中。 Seq2Seq的一种变体是引入注意力机制。S2S机制的一个问题是将所有的输入数据编码成向量会造成信息损失，而注意力机制通过对更重要的信息加权，可以尽量减少这种信息损失。比如对于以年为周期的月度数据，显然上一年的相同月份的权重应该会更大 使用RNN的组合(ensemble RNN)，比如Smyl将这个问题分成两部分，即产生一组专门的RNN，并将其组合起来进行预测。也可以使用其他的组合方式，比如将meta-learner的输出作为RNN的输入继续进行预测，也有boosting的方法。 global方法，即权重全局计算（跨越不同的时间序列），但是状态保留在各自的时间序列中。 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:1:2","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"第三部分 Methodology 都是很简单的介绍，没什么细节 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:2:0","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"第四部分 测试框架 数据集：用的挺全的 在这部分中我比较关心的是时间序列预处理的方式。时间序列预处理是非常麻烦的，最优的肯定是全局预处理，但是这只对于波动不大的时间序列管用，而且对于极端情况处理的很糟糕。Smyl还是NBEATS提出了局部时间序列处理方式，即每次使用滑动窗口的最后一个值进行时间序列预处理。 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:3:0","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机论文阅读"],"content":"4.2 数据预处理 4.2.1 数据集切分 首先是要留足与forecast horizon等长的validation dataset。 4.2.2 处理缺失值 对于缺失值可以将其替换成线性插值结果或者直接赋值为0.对于NN5的数据，使用的是中位数。比如某一天的数据缺失了，那这一天的数据就使用所有星期的同一天中对应数据的中位数来填补。 4.2.3 对季节性建模 很显然的事情是，对于更长的预测范围，是必须要使用周期性数据。Claveria 2017的工作显示，对季节性进行了调整适应的数据在预测中表现地更好。 4.2.5 多步输出问题 Recursive Strategy: 每次预测一步，将前一次的预测结果作为下一次的输入 Direct Strategy: 使用多个不同的模型，每个模型预测一个horizon中的一个时间点 DiRec Strategy：结合上述两种方法，多模型的同时进行滚动预测 Direct multi-step-ahead forecast：直接预测整个horizon，即MIMO DIRMO：将Direct和MIMO结合，每一个模型预测指定的窗口大小，并结合。 Direct Multi-Horizon strategy，同样作为MIMO，可以避免错误累积 常规的产生监督数据的方式：滑动窗口法。 输入窗口选择方法： 稍微比输出窗口大，m=1.25倍输出窗口大小 令输入窗口稍微比季节性周期大，m=1.25倍季节性周期大小 4.2.6 Trend Normalization RNN所用的激活函数，包括sigmoid或者tanh都有一个区域，超出这个区域后输出都是一个常数。因此使用RNN的时候需要确认输入数据是被正则化过的。 Smyl提出了一个per window local normalization step，对使用滑动窗口法产生数据的正则化方式提出了一种比较好的局部正则化方法。 ","date":"2021-01-19","objectID":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/:3:1","tags":["时间序列预测","综述文章","RNN"],"title":"Recurrent Neural Networks for Time Series Forecasting: Current status and future directions","uri":"/posts/20210119_recurrent-neural-networks-for-time-series-forecasting_current-status-and-future-directions/"},{"categories":["计算机基础"],"content":"中山大学研一上学期现代人工智能技术复习的相关资料，主要内容为神经网络基础知识，可能涉及到线性代数、概率论、线性模型、卷积神经网络和CV进展 距离度量，重点记忆Mahalanobis距离和Minkowski距离 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:0:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"过拟合 训练集误差减小的时候，测试集误差增大。 解决方案：正则化，给误差函数增加一个惩罚项（L1/L2） ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:1:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"概率论 全概率公式，P(A) = P(A|Bi)P(Bi) 贝叶斯公式，P(Bi|A) = P(ABi)/P(A) ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:2:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"贝叶斯概率 后验概率= 先验概率*似然函数 bootstrap，自助法，频率学派使用。假设原始数据集有N个数据，可以采取随机抽取N个点的做法来生成新的数据集（可重复，可缺失）。这样可以在多个产生的数据集中评估参数估计的结果。 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:3:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"高斯分布 一元与多元的表示 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:4:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"交叉验证 信息准则：AIC与BIC ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:5:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"决策论 或者说贝叶斯决策/贝叶斯推断 最小化错误分类率。对于二分类问题，降低错误发生的概率，即把类1分给类2与类2分给类1两个事件。 最小化期望损失。使用损失函数来量化错误分类的代价。 拒绝选项 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:6:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"判别器 概率分布 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:7:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"二项分布（伯努利分布） E = p, V = p(1-p) ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:8:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"高斯分布 对于多元实值向量，使熵取最大值的是高斯分布 中心极限定理： 独立同分布的中心极限定理。当n个随机变量独立同分布且n足够大的时候，可以将独立同分布的随机变量之和当作正态变量。 对于要定义的高斯分布，其协方差的酥油特征值要严格大于零，不然不能被正确的归一化。如果一个或多个特征值为零，则该高斯分布将是奇异的，被限制在一个低维的子空间上。 高斯分布的局限性在于它是单峰的，因此难以逼近多峰分布。解决方法是使用混合高斯分布，使用足够多的高斯分布，并调整它们的均值和方差以及线性组合的系数，几乎可以以任意精度近似所有的连续概率密度。 共轭先验分布：在贝叶斯统计中，如果先验分布与后验分布是同一分布，则称为共轭分布。一般情况下，给定概率分布，能够寻找一个先验与似然函数共轭，从而后验分布的函数形式与先验分布相同。 非参数估计概率密度：Parzen窗/knn 线性判别 或者降维度 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:9:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"Fisher线性判别函数（LDA） 使得类间距离最大与类内距离最小的分类方式，损失函数为类间方差/类内方差。投影面的方向由均值的中心连线决定。 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:10:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"PCA PCA选择投影后使得样本投影点具有最大方差的方向，假设就是方差越大，信息量越多。 对于无监督学习，使用PCA降维，维度可以任意。 对于有监督学习，使用LDA降维，维度只能降到k-1 线性回归 Lasso回归，相当于MSE加上L1算子 岭回归，相当于MSE加上L2算子 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:11:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"生成模型与判别模型 对机器学习的任务而言， 其目标是根据属性X预测标记Y，即求得概率P(Y|X)，在贝叶斯中这也就是后验概率 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:12:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"判别模型 判别模型是直接求出了一个判别边界，对没有见过的实例X就可以求出边界Y 例子：SVM模型、线性回归模型、一般的人工神经网络（多层感知机）、提升方法、条件随机场、随机森林 特点：输入属性X可以直接得到Y ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:12:1","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"生成模型 生成模型需要求得P(X,Y)，即一个联合概率。对于没有见过的实例X，需要求出X与不同的标记Y之间的联合概率分布，然后取最大的那个。比如上图的右边是没有严格的判定边界的，那对于未见实例（红三角），联合概率分布大的那个类会占优。 例子：高斯混合模型、朴素贝叶斯模型、隐马尔可夫模型、VAE、GAN、受限玻尔兹曼机 特点：对于输入的X，需要求出好几个概率，选择最大的那一个。 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:12:2","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"卷积神经网络中的参数计算 不考虑通道数，对于NN大小的输入，与FF大小的卷积核，输出大小为(N-F)/stride+1 案例2，对于77的图片，33的卷积核，stride=1，补了一圈零，最后为多少？ 大小应该为77，原图片补了一圈零之后等价为99，之后按照公式计算即可。 输入773通道，经过6个33的卷积核，输出的应该为55*6的数据。此处，卷积核默认通道数与输入数据通道数相同，图片大小按照公式计算，卷积核的数量即为输出的通道数。 总结 ","date":"2021-01-09","objectID":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/:13:0","tags":["机器学习","深度学习"],"title":"现代人工智能课程复习","uri":"/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机论文阅读"],"content":"所有的论文都放在这边 Do Bitcoin Users Really Care about Anonymity? An Analysis of the Bitcoin Transaction Graph Proceedings - 2018 IEEE International Conference on Big Data, Big Data 2018 Harlev M A, Sun Yin H, Langenheldt K C, et al. Breaking bad: De-anonymising entity types on the bitcoin blockchain using supervised machine learning[C]//Proceedings of the 51st Hawaii International Conference on System Sciences. 2018. Do Bitcoin Users Really Care About Anonymity? Do Bitcoin Users Really Care about Anonymity? An Analysis of the Bitcoin Transaction Graph Proceedings - 2018 IEEE International Conference on Big Data, Big Data 2018 看了一下，感觉可能和我想的有些不太一样。这个是关于比特币交易网络分析的文章，重点在于用户对于自身匿名性的在意程度。 文章介绍了目前主流的四种去匿名性思路： 直接与比特币用户交流来追踪比特币。比如在商品交易中，一方需要提供自己的地址以进行收款。 爬取第三方信息，建立开放的区块链分析网络。通过第三方的讨论组来收集比特币地址，包括用户无意泄漏，或者一些商人和组织的有意发布。 破解比特币的客户端，使IP与P2P网络对应。在交易过程中，会有一方来初始化整个交易，通过分析交易的形式和时间戳，是可以从比特币交易数据中提取出对应的IP地址，从而解析出真实的物理地址。 分析比特币交易图，这个是现在做的比较多的。Reid and Harrigan使用了一个多输入的启发式方法来进行分析，完成地址到用户的映射，等等。 学界关于比特币的匿名性和去匿名性进行了激烈的竞争，但是没有人想过一个问题：比特币用户自身关心匿名性吗？从结果来看，越富有的账户越关心自身匿名性，但是大部分用户本身是不关心匿名性的，我们可以轻松找到大型组织的所有对应地址。 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:0:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"相关工作 不太重要，其中分析比特币交易图所列出的文献值得进行阅读。 Breaking bad: De-anonymising entity types on the bitcoin blockchain using supervised machine learning 文章来源：课程论文搜索 本文使用了有监督机器学习的方式，预测未定义实体的类型。数据集采用了从200M个交易记录中提取出的434个实体，将其分为10类。采用的方法Gradient Boosting，准确率77%，F1大约0.75。 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:1:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"Intro 与公司合作，该数据提供方标注了一些数据，但是目前比特币网络上的大部分地址是没有被标注出来的。 标注类别：exchange, gambling, hosted wallet, merchant services, mining pool, mixing, ransomware, scam, tor market or other ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:2:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"相关工作 与比特币相关的工作比较多的是采用无监督学习方式，比如聚类算法。 Could Network Information Facilitate Address Clustering in Bitcoin? 论文计划使用地址信息来进行比特币的聚类，将所有用同一个用户创建的地址聚为一类。 结果显示只有8%的聚类与单个IP相关，说明比特币用户往往会使用很多个IP。 由于比特币交易的特性，为了确认一个交易必须要向全网进行广播，因此持续的网络监听很可能可以将比特币地址与特定的IP相连接。但是如果用户使用动态分配的IP，比如在NAT路由器之后或者使用钱包应用。因此这些信息就不一定能够用在去匿名化上。 思路：使用已有的启发式算法对用户和地址进行映射，然后对整个数据集进行聚类，看聚类所得到的用户与IP的对应关系。 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:3:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"相关工作 去匿名化的第一个工作：Reid and Harrigan(前面提到过)，使用启发式方法，多输入模型分析追踪之后的交易。 Meiklejohn，基于标准用户的行为进行 A Survey on Blockchain Anomaly Detection Using Data Mining Techniques 匿名检测技术的综述 将方法分为两大类，一类为泛用检测方法，一类为专用检测方法。下面共有八个子类。 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:4:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"Universal Detection Methods 指不为特定的异常设计的检测方法 分为三个小类：entity portrait/ transaction pattern recognition/ double angle detection model ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:5:0","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"entity portrait 主要任务是存储用户的活动，并对这些活动的性质进行分析。这方面活动的目的主要是为了去匿名化。 Harlev: Breaking bad: de-anonymising entity types on the bitcoin blockchain using supervised machine learning.，这个前面有，使用了两百万个交易数据的434个实体，使用SMOTE方法解决类间不平衡问题，然后用Gradient Boosting监督学习方法进行分类。精确度77%、F1 75% Regulating cryptocurrencies: a supervised machine learning approach to de-anonymizing the bitcoin blockchain，同样使用了有监督的机器学习方法来预测没有分类的应用，训练数据中有957个实体，针对12类进行预测。使用了同样的Gradient Boosting算法（默认参数） 我们的文章，深度学习方法 Deanonymizing cryptocurrency with graph learn- ing: the promises and challenges，意图使用图学习相关方法来进行去匿名化的工作。 上述是间接进行去匿名化。下面这些方法计划学习用户的行为特征，直接进行去匿名化： A Bayesian approach to identify bitcoin users，使用贝叶斯方法，构建概率论模型来对用户的行为特征建模，完成将比特币地址与交易和IP地址对应。通过两个月对一百多个用户的观察，他们能够识别几千个比特币用户，并将他们的交易行为与地理位置绑定。 Learning to classify blockchain peers according to their behavior sequences，基于深度学习的方法，可以将用户根据行为进行分类，通过提取代表用户行为的序列数据来解决问题。 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:5:1","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"Transaction Pattern Recognition 计划通过机器学习方法决定交易的类型。 好像没什么用 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:5:2","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["计算机论文阅读"],"content":"Double angle detection 计划同时找出异常的用户和地址 Anomaly detection in bitcoin network using unsupervised learning methods Anomaly detection in the bitcoin system - a network perspective 该方法从30个已知事件中找出了一个偷窃事件。 An evaluation of bitcoin address classifi- cation based on transaction history summarization 构建了新的feature来进行Bitcoin地址的分类，将交易历史集合表示为新的特征。 T-EDGE: temporal weighted multidigraph embedding for Ethereum transaction network analysis graph embeding方法，为了避免启发式特征提取的问题，更全面地代表动态交易网络的时序和经济结构，作者通过网络压缩的方式构建了以太坊的分析框架。 A New Bitcoin Address Association Method Using a Two-Level Learner Model 来源：后续发展 做的仍然是比特币地址与用户的相关性分析，使得地址追踪变得可能。 提取了比特币地址中的重要特征(主要是历史交易数据)，将聚类问题转变为二分类问题来降低计算复杂度。采用了一个两层的learner模型来分析两个比特币地址是否属于同一个用户。 精度提升6~20%，召回率10% XGBoost,LightGBM, GBDT用在第一层，因为它们可以很好地处理所有的特征。DNN用在第二层，因为它在分类上表现出色。 达到了95%以上 启发式分析方法 在最早的时候，人们使用基于启发式的方法来分析整个网络 目前最常用的方法就是多输入启发式方法，这个方法最早由：Bitcoin: a peer-to-peer electronic cash system此文是第一个提出使用启发式方法分析比特币交易网络的。启发式方法认为无论有多少输入，交易都会从一个用户开始，因此交易的地址应该全部归属于最初发出交易的用户。如此，可以合并所有交易中的输入地址，并合并成一个聚类，识别出这个聚类的地址所有者。 Shadow address heuristic，第一次提出是在Evaluating user privacy in bitcoin中，并在A fistful of bitcoins: characterizing payments among men with no names被定义为change address。在比特币交易中，用户经常会新开一个地址来存放零钱。这个启发式方法的容错会更低一些，因为对shadow address的识别是基于对交易现象的观察而不是客观现象进行的。其他一些情况也使用了这种方法，在Data-driven de-anonymization in bitcoin中，使用了两种启发式方法来进行去匿名化，召回率69.3%，并研究了多种启发式方法结合的情况，发现结合后的提升小于1%。 在Deanonymisation of clients in bitcoin P2P network和An analysis of anonymity in bitcoin using P2P network traffic中，与之前的分析交易图不同，它们更关注交易地址与实际IP地址的对应关系。使用网络层级技术来追踪IP地址，但是很容易被防御，如果使用了CoinShuffle: practical decentralized coin mixing for bitcoin中提到的VPN或混淆技术 ","date":"2020-12-22","objectID":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/:5:3","tags":["时间序列预测"],"title":"比特币，基于交易图网络数据分析的去匿名性问题论文阅读","uri":"/posts/20201222_%E6%AF%94%E7%89%B9%E5%B8%81%E5%9F%BA%E4%BA%8E%E4%BA%A4%E6%98%93%E5%9B%BE%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%9A%84%E5%8E%BB%E5%8C%BF%E5%90%8D%E6%80%A7%E9%97%AE%E9%A2%98%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"},{"categories":["问题"],"content":"问题描述 我拿到了一个维基百科的列表，其数据如下： datehour title views 2015-10-17 13:00:00 UTC Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License 2 2015-06-01 14:00:00 UTC Dulce_Mar铆a 10 2015-06-01 21:00:00 UTC Dulce_Mar铆a 25 2015-06-01 06:00:00 UTC Dulce_Mar铆a 18 2015-08-30 12:00:00 UTC Portal:Current_events 116 UTF-8的问题暂且不谈，现在需要将其作为csv文件读入内存中，并且按照title分成不同的datehour-\u003eviews表，并按照datehour排序。将2015~2020的数据按照同样的操作进行处理，并将它们拼接成一张大表，最后将每一个title对应的表导出到csv，title写入到index.txt中。 ##解决方案 ","date":"2020-11-22","objectID":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/:1:0","tags":["问题解答","Python"],"title":"如何让pandas根据指定列的指进行partition","uri":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/"},{"categories":["问题"],"content":"朴素想法 最朴素的想法就是遍历一遍原表的所有行，构建一个字典，字典的每个key是title，value是两个list。不断将原有数据放入其中，然后到时候直接遍历keys，根据两个list构建pd，排序后导出。 ","date":"2020-11-22","objectID":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/:1:1","tags":["问题解答","Python"],"title":"如何让pandas根据指定列的指进行partition","uri":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/"},{"categories":["问题"],"content":"更python的做法 朴素想法应该是够用的，但是不美观，不够pythonic，看着很别扭。于是我搜索了How to partition DataFrame by column value in pandas? boolean index stackoverflow里有人提问如何将离散数据进行二分类，把小于和大于某个值的数据分到两个DataFrame中。直接用df1 = df[df[\"Sales\"]\u003e=s]这样的语句就可以完成。 但是这在我们的场景上并不太适用。当然，可以提前遍历一遍把title做成集合再循环遍历，不过这也不是很pythonic。 groupby 同样是上面那个问题，有人提到可以使用groupby方法。groupby听着就很满足我的需求，它让我想起了SQL里面的同名功能。 df.groupby('ColumnName').groups可以显示所有的列中的元素。 df.groupby('ColumnName')可以进行遍历，结果是一个(name,subDF)的二元组，name为分组的元素名称，subDF为分组后的DataFrame 对df.groupby('ColumnName')产生的对象执行get_group(keyvalue)可以选择一个组 此外还有聚合、转换、过滤等操作，不赘述。 ","date":"2020-11-22","objectID":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/:1:2","tags":["问题解答","Python"],"title":"如何让pandas根据指定列的指进行partition","uri":"/posts/20201122_%E5%A6%82%E4%BD%95%E8%AE%A9pandas%E6%A0%B9%E6%8D%AE%E6%8C%87%E5%AE%9A%E5%88%97%E7%9A%84%E6%8C%87%E8%BF%9B%E8%A1%8Cpartition/"},{"categories":["操作实践"],"content":"后续更新，不一定会记得更新 kubernetes虚拟机多级环境部署与Istio的安装 标签：项目实践 kubernetes istio 计划在三台2C4G的机器上安装kubernetes。其中master和slave的系统均为Ubuntu18.04桌面版。（原本想用CentOS的，下载的时候就是这样了，费事改了） 目前需要在实验室的服务器上进行部署，得了，最终结果也是一样的。 分为以下几个步骤： 安装基本软件 访问谷歌镜像仓库gcr.io 完成三台机器关于安装kubeadm的相关工作 安装Istio 部署相关应用（prometheus、grafana） 参考文献： 掘金 cnblog，这一篇是我后来看到的，写的更好一些。 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:0:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"安装基本软件 如果使用包管理软件，请务必检查自身的包管理软件为最新。 以Ubuntu的apt为例，首先请务必使用最新的镜像仓库（最好手动弄一下），然后再执行一遍sudo apt-get update来更新。 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"配置docker 略 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:1","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"配置kubectl、kubeadm、kubelet 在执行命令之前，请首先使用检查是否能够访问到指定的包。以apt为例，使用apt-cache policy \u003cpackage\u003e可以检查远程仓库中包的版本。 apt-get install kubectl kubeadm kubelet ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:2","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"系统配置 关闭防火墙 关闭SELinux 关闭swap ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:3","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"下载kubeadm所需镜像 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:2:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"从阿里云下载 首先使用kubeadm config images list列出kubeadm所需要的所有镜像 k8s.gcr.io/kube-apiserver:v1.19.2\rk8s.gcr.io/kube-controller-manager:v1.19.2\rk8s.gcr.io/kube-scheduler:v1.19.2\rk8s.gcr.io/kube-proxy:v1.19.2\rk8s.gcr.io/pause:3.2\rk8s.gcr.io/etcd:3.4.13-0\rk8s.gcr.io/coredns:1.7.0 即所有的系统镜像为v1.19.2版本，pause3.2,etcd3.4.13,coredns1.7.0 这篇博客提供了一个脚本 ######################################################################### # File Name: pull_master_image.sh # Description: pull_master_image.sh # Author: zhangyi # mail: 450575982@qq.com # Created Time: 2019-07-31 21:38:14 ######################################################################### #!/bin/bash kube_version=:v1.19.2 kube_images=(kube-proxy kube-scheduler kube-controller-manager kube-apiserver) addon_images=(etcd:3.4.13-0 coredns:1.7.0 pause:3.2) for imageName in ${kube_images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version docker image tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version k8s.gcr.io/$imageName$kube_version docker image rm registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName-amd64$kube_version done for imageName in ${addon_images[@]} ; do docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName docker image tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName docker image rm registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName done 这个脚本应该是没有问题的，有可能因为阿里云那边的容器镜像发生改变导致脚本需要变化，但大体思路是没错的。 可能的错误信息： 如果使用sh命令运行此脚本，可能会遇到pullImage.sh: 3: pullImage.sh: Syntax error: \"(\" unexpected。参考这篇回答，该问题的原因是因为使用sh xx.sh的时候是使用sh shell，是没有数组的。正确的执行方式是bash xx.sh或者如回答中一样使用./xx.sh(需要注意权限) ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:2:1","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"使用kubeadm安装kubernetes集群 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:3:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"安装集群主体 在执行完第一步和第二步之后，可以直接使用kubeadm进行安装：sudo kubeadm init --apiserver-advertise-address=192.168.1.1 --pod-network-cidr=10.244.0.0/16 --token-ttl=0（与之相反，执行kubeadm reset就可以尽量还原kubeadm init或者kubeadm join所带来的影响） 命令参考：官方，也可以在命令行下查看。 apiserver-advertise-address：这个参数指定了监听的API地址。若没有设置，则使用默认网络接口。 apiserver-bind-port：这个参数指定了API服务器暴露出的端口号，默认是6443。 pod-network-cidr：规定了pod能够使用的IP地址段。我之前用的是16位子网掩码，但是现在给的子网就是24位掩码，我也不确定使用其他子网能不能行……先保险起见吧。 kubernetes-version：指定kubeadm安装的kubernetes版本。这个是很重要的，因为默认情况下kubeadm会安装与它版本相同的kubernetes版本，而由于国内的网络问题，每次都需要重新下载一遍镜像，非常的麻烦。如果之后版本使用这个脚本，可以加上--kubernetes-version=v1.19.2 image-repository：默认是\"k8s.gcr.io\"。我觉得如果修改这个可以不用像之前那样从阿里云下载下来后手动tag，不过没有尝试。 token-ttl：令牌被删除前的时间，默认是24h。kubeadm初始化完毕后会生成一个令牌，让其他节点能够加入集群，过时之后这个令牌会自动删除。如果设置为0之后令牌就永不过期。 这一步的难点在于如何设置pod-network-cidr，参数的作用。根据官方教程的说法，Pod网络与任何主机网络不得有重叠。但是目前我看到的很多教程都是在主机局域网络下构建的。比如说三台主机都在192.168.1.1/16子网，而pod网络也在同样的子网下。 这个参数的设置似乎与所使用的CNI有关系： flannel，要求的参数为--pod-network-cidr=10.244.0.0/16 calico，要求的参数为--pod-network-cidr=192.168.0.0/16 本文采用flannel，一个很重要的原因是因为服务器的子网与pod的子网部分重叠，可能存在风险，以及flannel似乎更容易部署一些。 产生的日志： stack@workflow-1:~/k8sTest$ sudo kubeadm init --apiserver-advertise-address=192.168.1.1 --pod-network-cidr=10.244.0.0/16 --token-ttl=0 W1012 19:18:16.455833 86405 configset.go:348] WARNING: kubeadm cannot validate component configs for API groups [kubelet.config.k8s.io kubeproxy.config.k8s.io] [init] Using Kubernetes version: v1.19.2 [preflight] Running pre-flight checks [preflight] Pulling images required for setting up a Kubernetes cluster [preflight] This might take a minute or two, depending on the speed of your internet connection [preflight] You can also perform this action in beforehand using 'kubeadm config images pull' [certs] Using certificateDir folder \"/etc/kubernetes/pki\" [certs] Generating \"ca\" certificate and key [certs] Generating \"apiserver\" certificate and key [certs] apiserver serving cert is signed for DNS names [kubernetes kubernetes.default kubernetes.default.svc kubernetes.default.svc.cluster.local workflow-1] and IPs [10.96.0.1 192.168.1.1] [certs] Generating \"apiserver-kubelet-client\" certificate and key [certs] Generating \"front-proxy-ca\" certificate and key [certs] Generating \"front-proxy-client\" certificate and key [certs] Generating \"etcd/ca\" certificate and key [certs] Generating \"etcd/server\" certificate and key [certs] etcd/server serving cert is signed for DNS names [localhost workflow-1] and IPs [192.168.1.1 127.0.0.1 ::1] [certs] Generating \"etcd/peer\" certificate and key [certs] etcd/peer serving cert is signed for DNS names [localhost workflow-1] and IPs [192.168.1.1 127.0.0.1 ::1] [certs] Generating \"etcd/healthcheck-client\" certificate and key [certs] Generating \"apiserver-etcd-client\" certificate and key [certs] Generating \"sa\" key and public key [kubeconfig] Using kubeconfig folder \"/etc/kubernetes\" [kubeconfig] Writing \"admin.conf\" kubeconfig file [kubeconfig] Writing \"kubelet.conf\" kubeconfig file [kubeconfig] Writing \"controller-manager.conf\" kubeconfig file [kubeconfig] Writing \"scheduler.conf\" kubeconfig file [kubelet-start] Writing kubelet environment file with flags to file \"/var/lib/kubelet/kubeadm-flags.env\" [kubelet-start] Writing kubelet configuration to file \"/var/lib/kubelet/config.yaml\" [kubelet-start] Starting the kubelet [control-plane] Using manifest folder \"/etc/kubernetes/manifests\" [control-plane] Creating static Pod manifest for \"kube-apiserver\" [control-plane] Creating static Pod manifest for \"kube-controller-manager\" [control-plane] Creating static Pod manifest for \"kube-scheduler\" [etcd] Creating static Pod manifest for local etcd in \"/etc/kubernetes/manifests\" [wait-control-plane] Waiting for the kubelet to boot up the control plane as static Pods from directory \"/etc/kubernetes/manifests\". This can take up to 4m0s [apiclient] All control plane components are healthy after 26.502830 seconds [upload-config] Storing the configuration used in ConfigMap \"kubeadm-config\" in the \"kube-system\" Namespace [kubel","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:3:1","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"安装flannel 参考flannel官方教程，对于1.7版本以上的kubernetes，可以直接用kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml。当然，国内网络，懂得都懂，我就基本上没有直连成功过。直接手动弄下来搞也可以。 日志记录 stack@workflow-1:~/k8sTest$ kubectl apply -f kube-flannel.yml podsecuritypolicy.policy/psp.flannel.unprivileged created Warning: rbac.authorization.k8s.io/v1beta1 ClusterRole is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRole clusterrole.rbac.authorization.k8s.io/flannel created Warning: rbac.authorization.k8s.io/v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRoleBinding clusterrolebinding.rbac.authorization.k8s.io/flannel created serviceaccount/flannel created configmap/kube-flannel-cfg created daemonset.apps/kube-flannel-ds created 可能出现的问题： flannel需要镜像quay.io/coreos/flannel:v0.13.0-rc2，之前的时候我的虚拟机是无法直接从quay.io下拉镜像，因此有可能需要曲线救国。 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:3:2","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"连接其他节点 将主节点装完之后就可以安装其他节点了（也可以在之前一起安装）。其他节点的前置条件需要像主节点一样，包括系统配置、软件安装等等。 比较麻烦的一点是从节点也需要安装那一些镜像，如果我没有理解错的话。这就需要很久了…… 命令就是之前弹出来的那个 sudo kubeadm join 192.168.1.1:6443 --token a8svth.m8zu4mdj60m6zjzd \\\r--discovery-token-ca-cert-hash sha256:a98361e5d879fe14734236285b8ad28d0a4d3d1470bd424194011bee41ee8c9e 可能出现的问题： 如果安装过比较多次的话，会发现一些奇怪的报错信息，比如端口被占用之类的。请记得执行kubeadm reset ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:3:3","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"安装istio 原本计划是用helm来安装istio，但是最新版本的官方文档弃用了helm。 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:4:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"下载 首先到官方给的发布页面下载（这个链接是1.7.3版本）。 然后使用tar -zxvf解压 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:4:1","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"安装 按照官方说明文档 把文件夹下的istioctl所在目录加入PATH变量之中。（我没有把istioctl丢到/usr/bin下，因为它这个安装过程有可能要用到其他目录中的文件） 执行istioctl manifest install --set profile=demo stack@workflow-1:~/k8sTest/istio-1.7.3/bin$ istioctl manifest install --set profile=demo\rDetected that your cluster does not support third party JWT authentication. Falling back to less secure first party JWT. See https://istio.io/docs/ops/best-practices/security/#configure-third-party-service-account-tokens for details.\r✔ Istio core installed ✔ Istiod installed ✔ Egress gateways installed ✔ Ingress gateways installed ✔ Installation complete 结果： stack@workflow-1:~/k8sTest/istio-1.7.3/bin$ kubectl get pods -n=istio-system\rNAME READY STATUS RESTARTS AGE\ristio-egressgateway-8556f8c8dc-rj922 1/1 Running 0 2m42s\ristio-ingressgateway-589d868684-pf7g4 1/1 Running 0 2m42s\ristiod-86d65b6959-lch8x 1/1 Running 0 3m54s\rstack@workflow-1:~/k8sTest/istio-1.7.3/bin$ kubectl get svc -n istio-system\rNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\ristio-egressgateway ClusterIP 10.108.56.199 \u003cnone\u003e 80/TCP,443/TCP,15443/TCP 3m7s\ristio-ingressgateway LoadBalancer 10.96.27.251 \u003cpending\u003e 15021:32083/TCP,80:31588/TCP,443:31926/TCP,31400:30951/TCP,15443:31996/TCP 3m7s\ristiod ClusterIP 10.111.3.121 \u003cnone\u003e 15010/TCP,15012/TCP,443/TCP,15014/TCP,853/TCP 4m20s 这个步骤真的是比我当时（0.2.x）要简单多了。我记得我试了好多次都没有成功，都有心理阴影了。才过了一年多就有了这么大的变化，软件行业真的是日新月异啊。 ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:4:2","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"部署prometheus和grafana 参考资料： 简书-k8s安装prometheus+grafana prometheus-github 掘金-k8s监控 安装prometheus promethues官方-配置文件规范 istio之前有一套prometheus的系统，因此我一开始并没有考虑安装。但是在最新版本1.7中它并没有自带了，只是在addon里面加上了一个prometheus的样本用于验证（不过似乎也够用？）。 istio/addon 可以直接使用kubectl apply -f samples/addons进行安装。当然如果之前是自定义安装istioctl的话那这一步就需要看一下官方文档怎么说了。 可能出现的问题： 在K8s 1.19版本情况下可能会出现如issues所示的情况，因为某些未知的原因k8s无法识别出在同一个文件内配置的配置项，因此必须要执行两次kubectl apply -f kiali.yaml ","date":"2020-10-13","objectID":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:5:0","tags":["kubernetes","istio","实验报告"],"title":"kubernetes虚拟机多级环境部署与Istio的安装","uri":"/posts/20201013_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"后续更新，我不一定会记得更新过来。 在k8s中上线gatling镜像并在内网发送流量 很多时候我们会面临一个问题，即外网的带宽是有限的，虽然未来有扩容的可能，但是短时间内也不能直接扩容，而测试本身是无限的。因此，如果不能够在内网下直接发包进行测试，那由于带宽限制打不到较大的压力，对于一些容器的测试很可能就达不到效果。 因此我们需要在内网有一个能够配置的压力测试容器，目前选定了gatling，因为其功能比较强大，而且安装很方便。 ","date":"2020-10-12","objectID":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:0:0","tags":["kubernetes","实验报告"],"title":"在k8s中上线gatling镜像并在内网发送流量","uri":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"镜像构造 ","date":"2020-10-12","objectID":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:0","tags":["kubernetes","实验报告"],"title":"在k8s中上线gatling镜像并在内网发送流量","uri":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"初始镜像构造 虽然之前已经做了ubuntu的镜像，并且可以使用apt-get install来安装gatling，但是这种方式安装后有些不太会用，似乎更多是作为一个插件存在而不是独立存在的软件。 我还是选择了自己最熟悉的方式，直接从官网上下载了开源版本的standalone gatling.zip，解压后将目录重命名为gatling，Dockerfile如下: FROMubuntu:18.04MAINTAINERwtysos11 \"wtysos11@gmail.com\"COPY sources.list ./ADD gatling ./gatlingRUN rm /etc/apt/sources.list\\ \u0026\u0026 mv sources.list /etc/apt/sources.list\\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y openjdk-8-jdk scala #\u0026\u0026 apt-get install -y gatlingCMD [\"/bin/bash\"]sources.list为清华的apt镜像，为了加速；gatling可以在java8下运行，必须要安装scala（其实我个人觉得只安装scala就够了，保险起见） 操作完之后执行docker build . -t ubuntu-wtynettest:0.0.2构造镜像，然后执行docker run --name test -d ubuntu-wtynettest:0.0.2 sleep infinity。再使用docker exec -it test bash 经过测试，gatling软件能够正常运行并且访问外界指定端口。如果我没有记错，k8s中的pod暴露端口主要是为了转发流量，那容器自己往外发流量应该是不用暴露端口的，因此直接上k8s是没有问题的。 ","date":"2020-10-12","objectID":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:1","tags":["kubernetes","实验报告"],"title":"在k8s中上线gatling镜像并在内网发送流量","uri":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"进阶流量压力测试镜像构造 下面的任务为： 在镜像文件中配置环境变量，该变量最好是能够在docker build的时候修改而不是要手动改写Docerfile，这样后续写bash脚本之类的会比较方便。（如果能够实时传入就更好了，不过这要将gatling作为插件实现，改写太多了，计划放在第三步） 删除原有系统中的脚本文件，并上传指定的脚本文件test.scala。这个脚本文件要能够读取环境变量来替换指定的值。 命令直接设为指定的发包命令。 环境变量配置 我看了一下，使用docker build加参数的方式似乎并不常见，而且其他方式也挺麻烦的。 因此我直接使用了ENV Key=value的形式（如果value中间有空格，两边要加上双引号） 脚本读取环境变量 scala脚本是可以读取到环境变量的，方法挺多的。目前选择的是直接使用sys.env[\"EnvVar\"]，此时需要环境中能够读取到$EnvVar，不需要引入任何库。 这个方法的缺点是如果环境中没有设置环境变量会报错，不过这也不是什么大问题，毕竟在docker内部。 接下来就很简单了，将这个值作为方法的参数进行传递，然后把脚本送到指定的位置。 命令配置 由于standalone版本的gatling是使用gatling.sh进行执行的，因此我预先写了一个输入文件进行重定向（其实就是一个只有1+回车的文件）。如此，容器的命令配置完毕。 最终的Dockerfile： FROMubuntu:18.04MAINTAINERwtysos11 \"wtysos11@gmail.com\"ENV Test=\"http://192.168.0.173:19001\"COPY sources.list ./COPY nettest.scala ./COPY command.txt ./ADD gatling ./gatlingRUN rm /etc/apt/sources.list\\ \u0026\u0026 mv sources.list /etc/apt/sources.list\\ \u0026\u0026 rm /gatling/user-files/simulations/computerdatabase/ -R \\ \u0026\u0026 mv nettest.scala /gatling/user-files/simulations/nettest.scala \\ \u0026\u0026 apt-get update \\ \u0026\u0026 apt-get install -y openjdk-8-jdk #\u0026\u0026 apt-get install gatlingCMD [\"/gatling/bin/gatling.sh \u003c command.txt\"]其中移除gatling内系统自带脚本的目的是为了让用户脚本一定排在第一位。由于版本不同，系统自带脚本可能有所区别，需要注意。 下面的文件： command.txt，内含1+空格，表示输入给gatling.sh的内容 nettest.scala，一个可以读取$Test作为目标地址的gatling脚本 gatling，解压官方包gatling.zip后的文件夹 执行测试部分命令： docker build . -t ubuntu-wtynettest:0.0.3 docker run --name test -d ubuntu-wtynettest:0.0.3 sleep infinity docker exec -it test bash 测试完毕之后就直接挂载在kubernetes上了，还是挺不错的。 有一个问题，我发现如果使用这个DockerFile的CMD命令会导致gatling报错，错误原因是输入了一个空值给description，也就是command.txt可能是有问题的……但我进去执行又是正常的。因为我赶时间，所以是选择使用sleep infinity代替了原来的镜像，手动进入这个容器内去执行代码，从而实现在k8s集群中发送流量的操作。之后看有没有时间继续完善。 ","date":"2020-10-12","objectID":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:2","tags":["kubernetes","实验报告"],"title":"在k8s中上线gatling镜像并在内网发送流量","uri":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["操作实践"],"content":"动态挂载 上面的实现方案还是有一个问题，即没有办法灵活控制gatling，只能够每次生成一个实例在挂载到k8s上，非常麻烦。而且如果不小心生成了两个实例，那就是双倍的流量，可能会造成一些问题。 我在思考有没有一种方式，能够将一个gatling程序传到k8s集群中，只需要通过网络端口向其上传配置文件、发送命令就可以调用指定的压力测试脚本。 我的实现思路需要用scala做一个简易的服务器，而网上的思路似乎有些不太一样。 gatling docker image是github上一个gatling的docker镜像，通过挂载配置文件能够在本地的docker上进行压力测试。 Distributed load testing with Gatling and Kubernetes这个是用gatling docker kubernetes关键词搜索出来的文章，似乎和我的思路比较类似。 不过有没有必要作出这个项目也是一个问题，毕竟gatling中仍然存在一些问题没有弄清楚，比如atOnceUser和constantUser等测试方式之间的选择等。 ","date":"2020-10-12","objectID":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/:1:3","tags":["kubernetes","实验报告"],"title":"在k8s中上线gatling镜像并在内网发送流量","uri":"/posts/20201012_kubernetes%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A4%9A%E7%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2%E4%B8%8Eistio%E7%9A%84%E5%AE%89%E8%A3%85/"},{"categories":["问题"],"content":"在学习的过程中遇到了这个问题，同时也看到了SO中有相同的问题。而keras-github中这个问题也挺有意思的，记录一下。 这个解释很不错，假如现在有这么两句话 Hope to see you soon Nice to see you again 在神经网络中，我们将这个作为输入，一般就会将每个单词用一个正整数代替，这样，上面的两句话在输入中是这样的 [0, 1, 2, 3, 4]\r[5, 1, 2, 3, 6] 在神经网络中，第一层是 Embedding(7, 2, input_length=5) 其中，第一个参数是input_dim，上面的值是7，代表的是单词表的长度；第二个参数是output_dim，上面的值是2，代表输出后向量长度为2；第三个参数是input_length，上面的值是5，代表输入序列的长度。 一旦神经网络被训练了，Embedding层就会被赋予一个权重，计算出来的结果如下： +------------+------------+\r| index | Embedding |\r+------------+------------+\r| 0 | [1.2, 3.1] |\r| 1 | [0.1, 4.2] |\r| 2 | [1.0, 3.1] |\r| 3 | [0.3, 2.1] |\r| 4 | [2.2, 1.4] |\r| 5 | [0.7, 1.7] |\r| 6 | [4.1, 2.0] |\r+------------+------------+ 根据这个权重，第二个输入计算出来的embedding vector就是下面这个： [[0.7, 1.7], [0.1, 4.2], [1.0, 3.1], [0.3, 2.1], [4.1, 2.0]] 原理上，从keras的那个issue可以看到，在执行过程中实际上是查表，将输入的整数作为index，去检索矩阵的对应行，并将值取出。至于这个embedding matrix是怎么维护的我还没有搞明白。 ","date":"2020-09-08","objectID":"/posts/20200908_keras%E4%B8%AD%E7%9A%84embedding%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/:0:0","tags":["问题延申","keras"],"title":"Keras中的Embedding层是如何工作的","uri":"/posts/20200908_keras%E4%B8%AD%E7%9A%84embedding%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84/"},{"categories":["计算机课程学习笔记"],"content":"地址：知乎 内容大纲 VS Code 的优势 VS 和 VS Code 到底有什么关系？ 微软从 VS 组里面抽了一拨人做 VS Code，是真的吗？ VS 支持 Java ？背后的真相到底是怎样的？ 你真的会用 VS Code 了吗？ VS Code Insiders 版本 常用的配置项 命令面板 面包屑导航/大纲/缩略图 主题 快捷键 集成终端 如何更好地学习 VS Code ？ 学会提问 学会搜索 学会学习 一起改进 VS Code，你也能成为 VS Code 的 Contributor VS Code 的核心组件 Electron Monaco Editor Language Server Protocol Debug Adapter Protocol VS Code 怎么做开源的？ 进阶 命令行 玩转 Git 打造自己的主题 快速创建属于你的 Code Snippet 玩转 Tasks，把重复的工作自动化 调试 远程开发 插件 插件管理 好用的插件推荐 你也可以开发一款属于你的插件 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:0:0","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"VS Code 从入门到进阶 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:0","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"第一章 VSCode的优势 特点：开源、跨平台、轻量级、内置git支持、丰富的插件 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:1","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"你真的会用VS Code吗 快捷键 VSCode shortcut for windows 常见命令： Ctrl+Shift+P或F1：调出命令面板，可以输出执行所有命令。 Ctrl+P：在不同的文件跳转 Ctrl+Shift+Tab：在所有打开的文件中进行跳转 Ctrl+Shift+O：跳转到文件中的Symbol Ctrl+T：搜索当前文件夹下的所有Symbol Ctrl+G：跳转到某一行 Alt+\u003c-/-\u003e：向后/向前跳转 可以修改Preference-\u003eKeyboard Shortcuts的设置来修改键位，也可以下载键盘映射插件。 菜单栏-配置项 通过File-Preference-Settings可以访问配置项，可以修改所有的配置，包括扩展与否 常用配置项如下： Editor: Format On Save，可以在保存时格式化文件 Files: Auto Save，控制已更新文件的自动保存 Files: Auto Save Delay，上面自动保存的间隔 Editor: Tab Size，规定一个制表符等于的空格数 Edirot: Insert Spaces，在按制表符的时候会自动插入空格 “file.exclude”：在打开VS code时有一些文件夹是默认不展示的，比如.git文件夹等。可以通过修改该配置项进行设置。 “search.exclude”：因为VS Code有内置的搜索功能，比如nodejs项目中，node module我就不希望搜索到，可以加入到这里面进行设置。 菜单-视图 最上方会有面包屑导航，可以方便的查看在工作区的位置。 左边会有大纲导航，方便查看变量级别。 右边有全文跳转，方便在全文中进行跳转。 主题 包括颜色主题或文件图标主题 集成终端/terminal Ctrl+`，打开终端 Ctrl+Shift+`，打开新的终端 Ctrl+Home，滚动到顶 Ctrl+End，滚动到底 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:2","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"如何更好地学习VS Code 学会搜索： 访问VSCode官网 访问VSCode的github Google Stack Overflow 学会提问：描述清楚问题，方便别人帮助 版本/环境/插件 问题的步骤（是否可复现/复习过程） 问题的期望行为与实际行为的比较 Code Sample，最好有error message Screenshot 寻求帮助前一定要有自己的思考（不然会提出很多弱智问题） 知其然，更要知其所以然 学会举一反三 贡献： 提问 issues PRs 插件 翻译 讨论： gitter chat room:https://gitter.im/Microsoft/vscode Slack: https://aka.ms/vscode-dev-community PRs：发PR前需要看一下PR指南：https://github.com/Microsoft/vscode/wiki/How-to-Contribute#pull-requests 一般标help-wanted或bug的标签是可以发PR的。 另外一个贡献的方式就是开发插件。 翻译：翻译指南https://aka.ms/vscodeloc ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:3","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"VSCode的核心组件 四个核心组件： Electron Monaco Editor Language Server Protocol Debug Adapter Protocol Electron 开发框架，基于Node.js和Chromium，使用HTML，CSS和JavaScript等前端技术来开发跨平台的桌面级应用程序 Monaco Editor 基于浏览器的代码编辑器：IntelliSense，代码验证，语法高亮等特性 Language Server Protocol IDE与语言服务器之间的协议，可以允许开发人员在最喜爱的工具中使用各种语言来写程序。 DAP 希望将编辑器与调试器解耦合，便于编辑器与其他Debugger的集成 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:4","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"VSCode是如何做开源的 开源的三个阶段：公开源代码-\u003eIssues\u0026PRs-\u003ePlanning\u0026Design 实时更新，管理Issues和PR来交互，并且有着开发和设计的计划。 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:5","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"进阶功能 命令行 code .：在当前目录下打开新的VSCode code -r .：在当前目录下覆盖打开VSCode code -n：创建新的窗口 code --local=es：改变语言 code --diff \u003cfile1\u003e \u003cfile2\u003e：打开diff工具对两个文件进行比较 code --goto package.sjon:10:5：打开指定文件，指定行列(file:line[:character]) code --help：查看帮助选项 code --disable-extensions：禁止所有的扩展 命令行高级功能： --status/-s：查看信息 extensions-dir \u003cdir\u003e：查看extension的根目录 打造自己的主题 https://code.visualstudio.com/api/references/theme-color TmThemeEditor：https://ththeme-editor.herokuapp.com/ 自己的代码片段 在当前工作目录的.vscode目录下 文件\u003e首选项\u003e用户代码片段即可，可以生成仅在当前工作区生效的VSCode代码片段。 Tasks，将重复工作自动化 在菜单中，选择终端\u003eConfigure Task来配置。 选择终端\u003eRun Task来运行重复工作。 这样可以不用在终端中反复输入重复的命令。 变量：https://code.visualstudio.com/docs/editor/variables-reference，列出了常用的变量 调试：launch.json 常规语言可以直接进行调试，复杂的项目要进行调试的时候需要对launch.json进行配置，通过修改当前目录下.vscode/launch.json中的对应内容，可以实现调试。 多目标调试，比如在开发Web应用的时候，可以同时调试前端和后端的应用。 远程开发 VSCode Remote，允许将容器/远程计算机/WSL作为完整的开发环境。相关插件包括： Remote - SSH Remote - Containers Remote - WSL 其中，Remote - SSH就很方便，可以通过SSH channel连接上远程计算机，访问远程文件夹进行开发。 插件推荐 GitLens：Git管理利器 REST Client：也许比Postman更好 Bracket Pair Colorizer：括号颜色高亮，我觉得可以 Browser Preview：把Chrome浏览器代入到VSCode中 LeetCode：Offer收割利器 Visual Studio Live Share：极大方便协作编程，可以实时实现代码编辑、跟踪光标、团队调试、分享本地服务器、共享终端 Visual Studio IntelliCode：AI赋能，根据上下文给出编程建议与智能提示 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:6","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["计算机课程学习笔记"],"content":"插件开发 设计 如何获取产品灵感：从日常生活、github issues中 参考其他浏览器/IDE的热门插件 确定目标用户 实现 VSCode插件开发：https://code.visualstudio.com/api VSCode插件样例：https://code.visualstudio.com/api/extension-guides/overview 推广 维护 ","date":"2020-05-24","objectID":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/:1:7","tags":["vscode","学习笔记"],"title":"知乎分享：vscode从入门到进阶","uri":"/posts/20200524_%E7%9F%A5%E4%B9%8E%E5%88%86%E4%BA%AB_vscode%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"},{"categories":["快速复习"],"content":"因为内容比较简单，就不做学习总结了，全部内容归类为快速复习。 参考： csdn-python logging，有例子，可以快速入门 cnblog - python日志处理模块，很详细，比较规范 ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["快速复习"],"content":"基础知识 ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["快速复习"],"content":"日志级别 CRITICAL \u003e ERROR \u003e WARNING \u003e INFO \u003e DEBUG \u003e NOTSET，如果将日志级别设置为INFO，则INFO以下的日志将不会输出。默认设置级别为WARNING。 ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["快速复习"],"content":"常用函数 logging.basicConfig() # 使用一系列key-value值规定日志的基本配置信息，level规定输出的log级别，format定义输出log的格式，datafmt为输出的时间格式，filename为log文件名，filemode为打开log文件的模式。 logging.debug/info/warning/error/critical(str) #输出错误信息 logging.log(logging.DEBUG/..., str) #另外一种输出错误信息的方式 #可以使用如下代码将log信息同时输出到console上 console = logging.StreamHandler() # 定义console handler console.setLevel(logging.INFO) # 定义该handler级别 formatter = logging.Formatter('%(asctime)s%(filename)s: %(levelname)s%(message)s') #定义该handler格式 console.setFormatter(formatter) # Create an instance logging.getLogger().addHandler(console) ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["快速复习"],"content":"例子 ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["快速复习"],"content":"例1：控制台与文件输出 设置输出格式，同时输出到控制台与文件 #coding:utf-8 # ======================================================================= # FuncName: console_out.py # Desc: output log to console and file # Date: 2016-02-19 17:32 # Author: johnny # ======================================================================= import logging def console_out(logFilename): ''' Output log to file and console ''' # Define a Handler and set a format which output to file logging.basicConfig( level = logging.DEBUG, # 定义输出到文件的log级别， format = '%(asctime)s%(filename)s: %(levelname)s%(message)s', # 定义输出log的格式 datefmt = '%Y-%m-%d%A %H:%M:%S', # 时间 filename = logFilename, # log文件名 filemode = 'w') # 写入模式“w”或“a” # Define a Handler and set a format which output to console console = logging.StreamHandler() # 定义console handler console.setLevel(logging.INFO) # 定义该handler级别 formatter = logging.Formatter('%(asctime)s%(filename)s: %(levelname)s%(message)s') #定义该handler格式 console.setFormatter(formatter) # Create an instance logging.getLogger().addHandler(console) # 实例化添加handler # Print information # 输出日志级别 logging.debug('logger debug message') logging.info('logger info message') logging.warning('logger warning message') logging.error('logger error message') logging.critical('logger critical message') if __name__ == \"__main__\": console_out('logging.log') 控制台 2016-03-06 14:38:49,714 console_out.py : INFO logger info message 2016-03-06 14:38:49,714 console_out.py : WARNING logger warning message 2016-03-06 14:38:49,714 console_out.py : ERROR logger error message 2016-03-06 14:38:49,714 console_out.py : CRITICAL logger critical message 文件logging.log 2016-03-06 Sunday 14:38:49 console_out.py : DEBUG logger debug message 2016-03-06 Sunday 14:38:49 console_out.py : INFO logger info message 2016-03-06 Sunday 14:38:49 console_out.py : WARNING logger warning message 2016-03-06 Sunday 14:38:49 console_out.py : ERROR logger error message 2016-03-06 Sunday 14:38:49 console_out.py : CRITICAL logger critical message ","date":"2020-05-05","objectID":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["python"],"title":"python日志模块logging学习与快速复习笔记","uri":"/posts/20200505_python%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97logging%E5%AD%A6%E4%B9%A0%E4%B8%8E%E5%BF%AB%E9%80%9F%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["资源整理"],"content":"原文地址 去年到现在一些关于时间序列预测的资料的整理。 kaggle文章： everything you can do with time series kaggle - web-traffic-time-series-forecasting - 1st solution。谷歌的这个比赛是针对流量预测作的，其中第一名的一些思路是很有意思的，比如引入seq2seq模型等。 微信公众号： 代码实践|LSTM预测股票数据该公众号的其他文章都挺有意思的。 知乎： 时间序列预测方法总结 关于时间序列预测的一些总结 LSTM与prophet预测实验 时间序列的七种方法，七种经典算法 使用ARIMA和趋势分解法预测 论文： 杜爽,徐展琦,马涛,杨帆.基于神经网络模型的网络流量预测综述[J].无线电通信技术,2020,46(02):216-222.从名字上就可以知道内容了。 王海宁,袁祥枫,杨明川.基于LSTM与传统神经网络的网络流量预测及应用[J].移动通信,2019,43(08):37-44.。提出了一个比较可行的LSTM架构。 TCN - An Empirical Evaluation of Generic Convolutional and Recurrent Networks for Sequence Modeling，据说很强大，没有使用过。 电子书： 澳大利亚莫纳什大学 - 在线预测教材 成品： TCN-github facebook -prophet ","date":"2020-05-04","objectID":"/posts/20200504_%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/:0:0","tags":["时间序列预测"],"title":"基于网站流量的时间序列预测资源整理","uri":"/posts/20200504_%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/"},{"categories":["资源整理"],"content":"kaggle资料整理 tag: time series tag: time series analysis 比赛： 10大时间序列竞赛比赛 房价预测 数据库： UCI - time series UCR数据库 斯坦福网络数据，似乎更多是网络结点的数据 CompEngine，时间序列，但是似乎不权威 google集群数据 维基百科pagecount数据 google比赛数据，维基百科两年的数据 wikipediatrend，包括了维基百科pageview数据，从07年到现在的日级别页面访问量数据。 ","date":"2020-05-04","objectID":"/posts/20200504_%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/:1:0","tags":["时间序列预测"],"title":"基于网站流量的时间序列预测资源整理","uri":"/posts/20200504_%E5%9F%BA%E4%BA%8E%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E9%A2%84%E6%B5%8B%E8%B5%84%E6%BA%90%E6%95%B4%E7%90%86/"},{"categories":["计算机论文阅读"],"content":"原文地址 看到的挺好的一篇文章 November 2018 DOI: 10.1109/NCA.2018.8548062 Conference: 2018 IEEE 17th International Symposium on Network Computing and Applications (NCA) ConferenceIEEE International Symposium on Network Computing and Applications 以排队论分析响应时间的一篇论文。 说实话，我一没看懂排队论的过程，二没看懂他的实验。 师兄的说法是排队论依据的假设太多了，比如要求请求以泊松分布到来之类的，现实世界根本做不到，以此建模误差太大了，就到此为止吧。 Response Time Characterization of Microservice-Based Systems 涉及到的词语与翻译： bottleneck，翻译为瓶颈、瓶颈层、瓶颈点 multi-server，我认为这里指的是多层服务，和multi-tier应该是同义的。 ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:0:0","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"摘要 背景：微服务架构较之传统的单体应用有着很多的优势，但是它也阻碍了系统的可视化(hinders system observability)。特别地，对于服务性能的监控和分析变得更加有挑战，特别是对于那些重要的生产系统，必须要迭代增长、连续操作且不能够进行线上的基准测试(benchmark)。这些系统一般非常的巨大且昂贵，因此成为了完全调度的较差选择。 为这样的服务和系统来创建一个模型来进行特征分析可以很好地缓解上述的问题。性能，特别是响应时间，是本工作关注的重点，我们注重于瓶颈点检测(bottleneck detection)和资源最优化调度（optimal rsource scheduling）。我们采用了一个方法来对生产应用建模，使用请求数据的排队系统。除此之外，我们提供了对响应时间进行分析和资源最优化调度的分析工具。我们的结果显示一个有着单个队列和数个同构(homogeneous)的服务器的简单的排队系统有着一个较小的参数空间，可以在生产中被估算出来。这个结果的模型可以被用来预测响应时间的分布和必要的实例数来维护期望的服务级别，在给定的流量下。 ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:1:0","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"1 introduction 对于生产环境来说，黑盒监控是非常轻量且高效的，然而这样的监控是无法去分辨和预测服务质量。除了已经收集到的指标、警示和配置项目之外，分析任务主要依赖于管理员。为此，我们设计了一个建模组件，比如同构多层服务队列，这使得可以从统计学上去分析一些性能指标，比如延迟或流量。而且由于队列可以组成网络，该方法可以用于微服务架构中的建模。为了更加准确地对独立的服务进行建模，我们需要对它们的性能进行更细致地分析。 在得到了额外的记录信息之后，我们就能够去为微服务系统来创建和更新一个动态的依赖模型。这允许我们去提取服务端点之间的依存关系，且更重要的是，可以对每一个微服务的表现进行建模。目标是简单但重要的：取得使每一个服务表现最佳的动作。这会导向不同的分支，比如明白什么时候应该进行调度、减少基础设施的消耗，以及保证SLA。额外地，可以在瓶颈出现前去解决它(the possibility of pinpointing bottlenecks in the system without stressing it)，这也是一个主要的优点。 在本文中，我们开发并部署了一个基于微服务架构的系统，对它的记录结果进行排序，来对multi-server queues进行建模(M/M/c)。该方法可以预测响应时间的分布范围以及服务的最佳动作区域，同时决定需要多少个实例数来维护指定流量下服务的理想服务质量。更重要的是，建立一个模型使得方法可以建立一个最大容量的定义，这是全系统性能最优化和瓶颈检测的第一步。我们的结果证明了尽管十分简单，我们的模型能够准确地预测微服务的动作，更精确地来说，预测响应时间分布，同时不需要更加复杂的模型或参数。从结果上来说，这样的模型对于线上的分析是足够的。 剩下的部分如此组成：S2描述了我们用来对微服务建模的基于队列的模型；S3描述了实验设置；S4展示了我们的实验结果；S5评价了实验结果；S6列出了相关工作；S7对该论文进行了总结。 ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:2:0","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"2 Performance Modeling 为了分析系统的性能并对其进行预测，我们需要一个合适的模型。对瓶颈点(bottleneck)的检测需要服务的容量上限（处理能力上限）的定义，作为一种在执行上对两个服务进行比较的方法，然后取预测服务在资源变动后响应时间的变化。在基于微服务的系统中，资源调度一般是实例级别的(instance level)，单位是虚拟机或容器。如果上述要求得到满足，就可以通过分析决定哪一个微服务不够有效（分配过多资源）或超出容量（超出处理能力上限）。 我们对于模型的要求是其能表示响应时间、流量和并行性，我们计划在在线建模中使用它。排队论系统(queueing system)是我们的理想方案，能够描述我们想要的方面和指标，且能够组成排队网络（queueing networks）。可以证明，如果有大量顾客独立地对一个服务发送请求，这个到达过程是马尔科夫的Markovian(论文：Enhancing Elasticity of SaaS Applications using Queuing Theory)。因此我们可以使用M/M/c队列对服务进行建模。 我们的参数空间比较小且符合直觉的，有lambda,miu和c三个参数组成。其中，lambda和miu代表着呈指数分布的请求到来时间和服务时间，c是同构的服务器的数量，代表着服务的并行性。(lambda and miu represent the rate parameters for the exponentially distributed inter-arrival and service times, and c the number of homogeneous servers, representing service parallelism.)需要注意的是，c并不是必须要表示实例的数量，在某些情况下，服务内部也会存在着并行性。 表1表示了本文所用的符号表，本文所构建的模型有两个直接的应用场景：1. 评估应用能处理的最大流量(estimate the maximum throughput capacity of an instance, bottleneck detection) 2.决定实例数量，来对于给定的流量到达速度达到一个理想的服务质量/响应时间分布。 给定M/M/c模型的参数miu’和c’，我们需要问三个问题： 这个服务能处理的最大流量是多少？ 对于给定的流量lambda，整个系统的时间分布是什么(what is the distribution of total system time T) 对于给定的流量lambda，使得请求的加权响应时间低于系统时间阈值所需的必要的实例数量是多少？ 对于第一个问题，对给定的M/M/c队列中获取最大容量C_miu是有一套比较简单的估算方式。另外两个问题可以使用累计分布函数CDF P(T\u003ct)在给定lambda、miu和c的时候决定，其中T是一个随机变量，代表整体系统时间。因为CDF于上述式子相关，我们有时候会使用这样的表示：CDF(lambda,mu,c,t) = P(T\u003ct)。由Adan的论文(I. Adan and J. Resing, “Queueing theory,” 2015)，T可以由W和S计算，这两个都是随机变量，W表示等待时间、S表示服务时间。见式(1) 在这里有一个自然的应用，是去计算一个期望的响应时间分位点(expected percentage of requests)，在total system time比given threshold r稍微大一点的时候，方式是通过1-P(T\u003cr)预测负载情况。 对于最后一个问题，我们希望能够决定最小的整体实例数I来确保给定的整体系统时间的分布，其中超出给定阈值的概率为p，即1-P(T\u003cr)\u003c=p ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:3:0","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"参数估计parameter estimation 为了对给定的微服务建模，我们需要去估计(estimate)两个参数，服务的速率miu’和它的并行性c’，从给定的一个请求的到达样本与离开时间中进行估计。 对于请求的到达速率lambda’可以通过moment or maximum-likelihood methods估计出来。对于服务速率miu’的估计，我们需要去确定请求的样本l被采样的时候队列要是空的这使得对于所有样本l中的请求，它们在队列中消耗的时间都是0。寻找一个充足的间隔可能开始会显得比较吓人，但一旦我们能估算出c’的值，我们就可以在间隔中寻找一个连续的样本集合S，在样本集合中there are at most c’ request in the system. 另外有一个启发式的方法，可以与c’独立，即运行一个滑动平均窗口，窗口的值为一个统计学重要的宽度，然后找到一个连续的子空间，其平均数最小。 …很多没有看懂。 只要我们能够有一个方法来估算服务的速率miu’，以及样本的请求时间，我们就可以计算出c’来最大化观测到的请求时间分布与预测的CDF之间的MSE。 ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:3:1","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"3 Experiment setup 我们会使用一个模拟仿真和一个真实的微服务来验证模型。 模拟仿真被用来验证参数确认方法，在该情况下最佳结果是已知的。第二个实验，在真实环境下进行，验证参数设置在真实环境中的效果。 ","date":"2020-04-23","objectID":"/posts/20200422_response-time-characterization-of-microservice-based-systems/:4:0","tags":["微服务调度"],"title":"Response Time Characterization of Microservice-Based Systems","uri":"/posts/20200422_response-time-characterization-of-microservice-based-systems/"},{"categories":["计算机论文阅读"],"content":"原文地址 主要还是针对微服务调度中bottleneck的定义入手 ","date":"2020-04-22","objectID":"/posts/20200422_bottleneck_detection/:0:0","tags":["微服务调度","论文总结"],"title":"bottleneck detection","uri":"/posts/20200422_bottleneck_detection/"},{"categories":["计算机论文阅读"],"content":"瓶颈点定义 从师兄的说法上，瓶颈点指的是响应时间上的瓶颈点，即在该实例下响应时间是异常的，可以通过增加瓶颈点的实例来减少整体的响应时间。 在多层应用(multi-tier applications)中，其中的bottleneck指的是资源层面的，即在某一层增加资源能够最大化的优化服务的性能。 ","date":"2020-04-22","objectID":"/posts/20200422_bottleneck_detection/:1:0","tags":["微服务调度","论文总结"],"title":"bottleneck detection","uri":"/posts/20200422_bottleneck_detection/"},{"categories":["计算机论文阅读"],"content":"多层服务中的bottleneck Agile Dynamic Provisioning of Multi-Tier Internet Applications Chapter 1 师兄推荐的论文。使用了排队论方法来明确每一层应该分配多少资源。 定义：每一层的处理能力是固定的 x req/s，如果说中间有一层处理能力最低，显然整个服务的处理速度都将受到影响。 需要注意的是，对瓶颈层的增加并不代表对整个服务的服务质量都会增加，可能需要在消除所有的瓶颈层之后整个服务的服务性能才能得到提升。 因为现在已经有很多的单层调度机制被使用了，要给很简单的想法就是给每一层都配置一个单层调度器。因此，我们的第一步就是在每一层的流量超过容纳上限的时候增加实例数量，这个可以通过监控队列长度、层间响应时间、或者丢包率来实现，这个方法称为independent per-tier provisioning. 想法1：多层模型，逐个找到bottleneck并增加。问题在于增加的速度可能很慢，最多可能需要遍历所有层才能完成实例扩缩，这对于变化较快的网络流量显然是不行的。 想法2：直接将多层模型作为一个黑箱进行考虑。问题在于需要增加多少个实例，以及在哪里增加。因为多层模型是一个黑箱，显然调度器无法获取内部的信息，即不知道究竟是哪一层出了问题。对于单层服务模型，可以建立一个应用模型来决定在响应时间范围内对于给定的流量需要多少个服务，从而进行对应的扩缩。但是将这个模型用于多层模型中并不一定可行，因为每一层的服务与应用性质都是不同的。以简单的电子商务应用为例，这意味着将HTTP服务器、Java服务器和数据库系统一起建模，这将是一个困难的工作。第三，不是所有的层都可以增加实例，比如数据库系统就很难实时增加实例。 综上，不能将多层应用作为黑箱进行调度。 特色： predictive and reactive provisioning:使用预测式调度来进行小时或天级别、使用响应式调度来进行更细致的调度。 使用了基于排队论的分析模型来同时对多层网络应用进行分析 快速的服务器切换，允许虚拟机来处理更快发生的网络波动。 能够处理基于session的流量。 这个调度方法可以被归类为自适应adaptive或半自动的semi-autonomous，它们是能够快速适应环境同时只需要人类有限的接触。 Chapter2 System Overview 2.1 Multi-tier Internet Applications 多层网络架构：整个网络架构由顺序连接的多个应用层组成，如同管道一样，中间的一层会收到前面预处理的数据，并将自己处理好的数据传输给下一层。 本文定义的SLA，使用平均响应时间(average response time)或一个合适的响应时间分位点（a suitable high percentile of the response time distribution） Chapter3 Provisioning Algorithm Overview 调度算法的目标：allocate sufficient capacity to the tiers of an application so that its SLA can be met even in the presence of the peak workload.（关键在于上界） 主要问题：how much and when 调度多少，什么时候调度 How much to provision:使用GG1排队论系统取分析。 When to provision：依据系统的流量。网络流量存在长期的变化，比如天或季节级别的影响，而短期的变化往往难以预测。我们的 How much to provision: modeling multi-tier applications 应用有K层，代表为T1,T2,…,Tk。让期望的end to end response time 为R，这个是SLA的规定值。可以预见，这个SLA将由每一层的响应时间组成，即R = d1+d2+…+dk。假设到来的session的访问率为lambda，因为调度是基于最坏(最小的)情况进行的，假定lambda是访问率的分布中的一个较高的分位点，是对peak session的一个估计值。 给定一个peak session rate和per-tier response time，目标是决定需要分配多少服务器，使得每个层的响应时间达到di的平均响应时间。 使用排队论模型，每个服务器都有一个队列，第一步是决定每一层能够处理的请求率和容量。给定服务器的容量，下一步是去计算需要多少台服务器才能够满足最大峰值的需要。使用G/G/1排队系统来进行建模，在G/G/1系统中，request到达服务器的间隔时间是服从一个已知的一个分布，每一个reuqest给服务器带来的工作量是相同的，队列允许长度为无限。一个G/G/1系统可以使用请求的平均响应时间和流量来代表inter-arrival和service time distribution。 Bottleneck Detection and Solution Recommendation for Cloud-Based Multi-Tier Application 对多层应用来说，检测瓶颈点（bottleneck points）是很重要且有挑战性的问题。因此，需要有一个机制来监视应用的表现变化，同时联系系统资源的使用情况来进行系统层面的分析。 然而，自动标记和联系bottlenecked resources并不是容易完成的事情。我们需要注意到的是，多个潜在的bottleneck可以同时存在，相互影响 Bottleneck Detection Using Knee Point Detection The bottleneck pattern of the application throughput can be described as a knee point of throughput curve, while the workload to the application increases. 瓶颈点指随着流量的增加，处理能力将达到一个上限，在这个上限之后单位时间内系统处理的请求数不会增加，这样会导致请求排队、响应时间增加。 因此在knee point之后，throughput不能再增加，因为资源已经到达bottleneck了。同时，一层中相同的bottleneck会最终扩散到其他层中，因为相同的bottleneck模式会触发其他层的bottleneck模式（可以见前文的例子）。 首先在观察之后，很重要的一点是需要捕捉到knee point，即明确一层所能处理的请求的上界。然后，我们需要确定造成bottleneck的原因，在系统资源的情况下，通过分析不同层和资源的bottleneck pattern之间的时间关系来找出原因。 2.1 Individual Knee Point Detection 应用的流量在到达knee point前可以持续增加，然而因为系统的bottleneck出现，它就不能够继续增加了。 使用数学方法，通过分析曲线来计算出拐点的位置。 2.2 Performance Profiling for Identifying the System bottlenecks 在本方法中，使用资源使用率的变化曲线和流量的变化曲线来识别bottleneck。 原理：在流量到达knee point前资源使用率的变化速率可以去代表每一种资源在面对流量变化时的使用情况与性能表现的变化，从而识别出bottleneck的位置。 ","date":"2020-04-22","objectID":"/posts/20200422_bottleneck_detection/:1:1","tags":["微服务调度","论文总结"],"title":"bottleneck detection","uri":"/posts/20200422_bottleneck_detection/"},{"categories":["计算机论文阅读"],"content":"其他想法 想法二：陈鹏飞老师学生所做的Microscaler: Automatic Scaling for Microservices with an Online Learning Approach这篇文章中提到了一个现象，即对于固定访问的流量，其分布是近似固定的。在服务异常的时候，这种响应时间分布是否会发生改变？是否能以此作为异常？ ","date":"2020-04-22","objectID":"/posts/20200422_bottleneck_detection/:1:2","tags":["微服务调度","论文总结"],"title":"bottleneck detection","uri":"/posts/20200422_bottleneck_detection/"},{"categories":["计算机论文阅读"],"content":"总结 瓶颈点指的是什么：bottleneck，更多的是从资源层面上定义的。以第二篇文章为例，这里的bottleneck指的是资源到达瓶颈。其理论是同一层使用的处理能力是有上界的(knee point)，在资源使用率到达knee point之后就称这个资源到达了bottleneck，此时无论如何增加流量，都不能够使得服务处理更多的请求。（如果没有熔断器，反而可能会影响到服务的正常使用） 如何识别瓶颈点： multi-tier应用可以使用排队论建模 ","date":"2020-04-22","objectID":"/posts/20200422_bottleneck_detection/:2:0","tags":["微服务调度","论文总结"],"title":"bottleneck detection","uri":"/posts/20200422_bottleneck_detection/"},{"categories":["无关随笔"],"content":"原文地址 参考资料： Learning Difficult Concepts with the ADEPT Method 缘起-强化学习 困难的概念往往让人疯狂，仅仅看一遍几乎没有任何效果，实际操作又过于繁琐。使用5个步骤来科学学习： Analogy：tell me what it’s like. Diagram：help me visualize it Example：allow me to experience it Plain English：Describe it with everyday works. Technical Definition：Discuss the formal details（这里最好能够自行推导一下公式、算法正确性之类的，会比较深刻） ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:0","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["无关随笔"],"content":"Analogy：What Else is it like 许多新的概念本身就是已有概念的改进、扩展和延伸，所以可以通过根据旧概念来学习新的概念。 以虚数为例，简单的介绍可以是负数的平方根。以下为一些更好的解释： 负数在1700之前都没有被认可，为什么会有比没有还小的东西。 数字是在数轴上，沿着数轴向0前进和后退 为什么不能向上或向下移动，数轴不一定是一维的。二维的轴就是虚数轴。 这样通过曲折的绕行，使用现实/过往例子来进行双向印证，能够帮助人更好地理解、记忆一些概念。 ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:1","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["无关随笔"],"content":"Diagram：Engage that half of your brain 画个图总是好的，无论是思维导图、概念图还是干脆就是随手涂鸦。画图能够在最短时间内将心中所想具现出来，而且往往很容易让人理解。 ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:2","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["无关随笔"],"content":"Example：Let Me Experience The Idea 很多时候，讲再久不如上手做一下，动作的信息量要高于语言。 不一定非要付诸于实际，可以选择去看别人的视频，看别人如何做实验。即使是数学这样抽象的学科，也有3Blue1Brown这样用动画来表现数学概念的人。 例子：Khan Academy或一些经典问题（最好带上答案甚至解析） ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:3","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["无关随笔"],"content":"Plain-Engliish Description: Use your own words 你懂了不一定代表你真的懂了。使用自己的话重新转述一下你的理解，最好找到别人来对应一下，看看是否有问题。 例子：讨论组、相互讨论 ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:4","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["无关随笔"],"content":"Technical Description: Learn the formalities 最困难的终究还是要面对的，用书面语言、课本的形式来巩固你之前的认识。就经验而言，一旦能够在形式上理解某个事物，那么从定义出发也不会很困难。因为定义最复杂的地方是精确定位这个事物，就像是在关了灯的房间里告诉你如何去拿一件东西，如果你之前在开过灯的房间里看过一眼，那显然你的效率会比没有就看过的人更高。 例子：维基百科、教科书 如果有可能的话，下面是更好的一种方案。 ","date":"2020-04-14","objectID":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/:0:5","tags":["学习方法"],"title":"使用ADEPT方法学习困难概念","uri":"/posts/20200414_%E4%BD%BF%E7%94%A8adept%E6%96%B9%E6%B3%95%E5%AD%A6%E4%B9%A0%E5%9B%B0%E9%9A%BE%E6%A6%82%E5%BF%B5/"},{"categories":["计算机论文阅读"],"content":"原始地址 阅读和微服务相关的论文 【论文名称】 调度类型，调度方法，调度对象，索引 综述文献： A Review of Auto-scaling Techniques for Elastic Applications in Cloud Environments，2014年的综述文献。 Elasticity in Cloud Computing : State of the Art and Research Challenges，弹性调度的综述文献，对调度的不同方法、使用虚拟机还是docker进行调度等方向进行了分类。 Auto-Scaling Web Applications in Clouds: A Taxonomy and Survey，另外一篇综述文献 A Survey and Taxonomy of Self-Aware and Self-Adaptive Cloud Autoscaling Systems 高价值文献： A reliable and cost-efficient auto-scaling system for web applications using heterogeneous spot instances Renewable-aware geographical load balancing of web applications for sustainable data centers Autonomic Resource Provisioning for Cloud-Based Software，开创性 A Comparison of Reinforcement Learning Techniques for Fuzzy Cloud Auto-Scaling Pattern Matching Based Forecast of Non-periodic Repetitive Behavior for Cloud Clients Integrated and Autonomic Cloud Resource Scaling Optimal Cloud Resource Auto-Scaling for Web Applications A cost-aware auto-scaling approach using the workload prediction in service clouds Autoflex: Service Agnostic Auto-scaling Framework for IaaS Deployment Models Towards an Autonomic Auto-Scaling Prediction System for Cloud Resource Provisioning Dependable Horizontal Scaling Based on Probabilistic Model Checking，使用KMeans进行聚类复用。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:0:0","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"机器学习方法 Auto-Scaling VNFs Using Machine Learning to Improve QoS and Reduce Cost，使用机器学习方法，对VNF设备的访问数据。重点在于两个，一个是特征提取的方式，因为文章使用的是机器学习分类器，所以数据处理还是很有意思的；一个是它将启动时间等虚拟化参数引入其中。 Online Machine Learning for Cloud Resource Provisioning of Microservice Backend Systems，使用了多元线性回归，使用了cross-validation的方式选择最佳的预测器来进行预测。 没看过（标题） Efficient resource provisioning for elastic Cloud services based on machine learning techniques ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:0:1","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"ARMA类方法 DoCloud: An elastic cloud platform for Web applications based on Docker，#12，使用了响应式调度与预测式调度相结合的方法，其中响应式调度使用了阈值法，预测式调度使用了ARMA。同时使用了慢减少的思想。 Auto-scaling web applications in hybrid cloud based on docker，使用了响应式调度与又粗恶时调度相结合的方法。其中响应式调度使用了阈值法，预测式调度使用了MA方法。同时使用了慢减少的思想。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:0:2","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"其他方法 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:1:0","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"混合方法 Study on proactive auto scaling for instance through the prediction of network traffic on the container environment，使用响应式调度与预测式调度相结合的方法。响应式调度使用基于静态阈值法的基于规则的调度，预测式调度使用时间序列分析、控制论、强化学习和排队论，具体来说是使用MA方法预测CPU利用率，但有其他的优化 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:1:1","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"马尔科夫 TIRAMOLA: Elastic nosql provisioning through a cloud management platform，对NoSQL集群调用马尔科夫过程指导调度。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:1:2","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"缓存 以下为2019年以来的文章 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:0","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Auto-Scaling Provision Basing on Workload Prediction in the Virtualized Data Center 摘要： With the development in the Cloud datacenters, the purpose of the efficient resource allocation is to meet the demand of the users instantly with the minimum rent cost. Thus, the elastic resource allocation strategy is usually combined with the prediction technology. This article proposes a novel predict method combination forecast technique, including both exponential smoothing (ES) and auto-regressive and polynomial fitting (PF) model. The aim of combination prediction is to achieve an efficient forecast technique according to the periodic and random feature of the workload and meet the application service level agreement (SLA) with the minimum cost. Moreover, the ES prediction with PSO algorithm gives a fine-grained scaling up and down the resources combining the heuristic algorithm in the future. APWP would solve the periodical or hybrid fluctuation of the workload in the cloud data centers. Finally, experiments improve that the combined prediction model meets the SLA with the better precision accuracy with the minimum renting cost. 预测式策略，使用功能了exponential smoothing and auto-regressive and polynomical fitting model，组合预测模型的目的是满足不同流量的需要同时满足服务SLA的要求使用PSO算法来进行一个细粒度的调度。用更低的租用成本实现更高的预测精度。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:1","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Dynamic Provisioning of Cloud Resources Based on Workload Prediction 摘要： Most of the businesses nowadays have started using cloud platforms to host their software applications. A cloud platform is a shared resource that provides various services like software as a service (SAAS), infrastructure as a service (IAAS) or anything as a service (XAAS) that is required to develop and deploy any business application. These cloud services are provided as virtual machines (VM) that can handle the end-user’s requirements. The cloud providers have to ensure efficient resource handling mechanisms for different time intervals to avoid wastage of resources. Auto-scaling mechanisms would take care of using these resources appropriately along with providing an excellent quality of service. The researchers have used various approaches to perform auto-scaling. In this paper, a framework based on dynamic provisioning of cloud resources using workload prediction is discussed. 使用了预测式算法指导调度，但是并没有提及用了什么样的方法。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:2","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Stream Data Load Prediction for Resource Scaling Using Online Support Vector Regression 摘要： A distributed data stream processing system handles real-time, changeable and sudden streaming data load. Its elastic resource allocation has become a fundamental and challenging problem with a fixed strategy that will result in waste of resources or a reduction in QoS (quality of service). Spark Streaming as an emerging system has been developed to process real time stream data analytics by using micro-batch approach. In this paper, first, we propose an improved SVR (support vector regression) based stream data load prediction scheme. Then, we design a spark-based maximum sustainable throughput of time window (MSTW) performance model to find the optimized number of virtual machines. Finally, we present a resource scaling algorithm TWRES (time window resource elasticity scaling algorithm) with MSTW constraint and streaming data load prediction. The evaluation results show that TWRES could improve resource utilization and mitigate SLA (service level agreement) violation. 使用了SVR方法对流量数据进行预测，然后使用了spark-based maximum sustainable throughput of time window(MSTW)性能模型来找到最合适的VM数，然后使用TWRES(time window resource elasticity scaling algorithm)来进行调度。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:3","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"TASM: technocrat ARIMA and SVR model for workload prediction of web applications in cloud 摘要： Workload patterns of cloud applications are changing regularly. The workload prediction model is key for auto-scaling of resources in a cloud environment. It is helping with cost reduction and efficient resource utilization. The workload for the web applications is usually mixed for different application at different time span. The single prediction model is not able to predict different kinds of workload pattern of cloud applications. In this paper, an adaptive prediction model has been proposed using linear regression, ARIMA, and support vector regression for web applications. Workload classifier has been proposed to select the model as per workload features. Further the model parameters are selected through a heuristic approach. We have used real trace files to evaluate the proposed model with existing state-of-the-art models. The experiment results describe the significant improvement in root-mean-squared error and mean absolute percentage error metrics, and improve the quality of service of web applications in a cloud environment. 单一的预测模型不能够预测多种不同的流量，使用线性回归、ARIMA和SVR方法一起预测，使用RMSE来作为衡量指标。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:4","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"An ensemble multiscale wavelet-GARCH hybrid SVR algorithm for mobile cloud computing workload prediction 摘要： Dynamic resource allocation and auto scalability are important aspects in mobile cloud computing environment. Predicting the cloud workload is a crucial task for dynamic resource allocation and auto scaling. Accuracy of workload prediction algorithm has significant impact on cloud quality of service and total cost of provided service. Since, existing prediction algorithms have competition for better accuracy and faster run time, in this paper we proposed a hybrid prediction algorithm to address both of these concerns. First we apply three level wavelet transform to decompose the workload time series into different resolution of time–frequency scales. An approximate and three details components. Second, we use support vector regression (SVR) for prediction of approximate and two low frequency detail components. The SVR parameters are tuned by a novel chaotic particle swarm optimization algorithm. Since the last detail component of time series has high frequency and is more likely to noise, we used generalized autoregressive conditional heteroskedasticity (GARCH) model to predict it. Finally, an ensemble method is applied to recompose these predicted samples from four multi scale predictions to achieve workload prediction for the next time step. The proposed method named wavelet decomposed 3 PSO optimized SVR plus GARCH (W3PSG). We evaluate the proposed W3PSG method with three different real cloud workload traces. Based on the results, the proposed method has relatively better prediction accuracy in comparison with competitive methods. According to mean absolute percentage error metric, in best case W3PSG method achieves 29.93%, 29.91%, and 24.53% of improvement in accuracy over three rival methods: GARCH, artificial neural network, and SVR respectively. 预测性模型，使用了三层的小波变换来分解时间序列到不同的尺度，然后使用SVR方法，SVR方法的参数使用chaotic particle swarm optimization方法调参。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:5","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Adaptive Prediction Models for Data Center Resources Utilization Estimation 摘要： Accurate estimation of data center resource utilization is a challenging task due to multi-tenant co-hosted applications having dynamic and time-varying workloads. Accurate estimation of future resources utilization helps in better job scheduling, workload placement, capacity planning, proactive auto-scaling, and load balancing. The inaccurate estimation leads to either under or over-provisioning of data center resources. Most existing estimation methods are based on a single model that often does not appropriately estimate different workload scenarios. To address these problems, we propose a novel method to adaptively and automatically identify the most appropriate model to accurately estimate data center resources utilization. The proposed approach trains a classifier based on statistical features of historical resources usage to decide the appropriate prediction model to use for given resource utilization observations collected during a specific time interval. We evaluated our approach on real datasets and compared the results with multiple baseline methods. The experimental evaluation shows that the proposed approach outperforms the state-of-the-art approaches and delivers 6% to 27% improved resource utilization estimation accuracy compared to baseline methods. 预测式方法，针对的是资源使用率。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:6","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"T-DCORAL: A Threshold-Based Dynamic Controller Resource Allocation for Elastic Control Plane in Software-Defined Data Center Networks 摘要： The existing elastic control planes (ECPs) suffer from the immediacy and the computing overhead issues in software-defined data center networks (SD-DCNs). In this letter, we propose T-DCORAL which is a new ECP to mitigate both issues in SD-DCNs. T-DCORAL accelerates/decelerates the control plane by allocating a virtual CPU to controllers in runtime, whereas the existing ECPs resize the controller pool. As a result, T-DCORAL maximally reduces the latency to adjust the control plane from 46 s to 38 ms, the average CPU load by 22%, and the average rule installation time by 64.28%. 阈值法 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:7","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"ALVEC: Auto-scaling by Lotka Volterra elastic cloud: A QoS aware non linear dynamical allocation model 摘要： Measurement of the dynamic elasticity of resource allocation in cloud computing continues to be a relevant problem in the related literature. Yet, there is scant evidence on determining the dynamic scaling quotient in such operations. Elasticity is defined as the ability to adapt to the changing workloads by provisioning and de-provisioning of Cloud resources and scaling is essential for maintaining elasticity in resource allocation. We propose ALVEC, as a model of resource allocation in Cloud data centers (Sarkar et al. , 2016) [7], [16], to address dynamic allocation by auto-tuning the model parameters. The proposed model, governed by a coupled differential equation known as Lotka Volterra (LV), fares better for management of Service Level Agreement (SLA) and Quality of Services (QoS). We show evidence of true elasticity both in theoretical and numerical applications. Additionally, we show that ALVEC as an example of unsupervised resource allocation, is able to predict the future load and allocate virtual machines efficiently. ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:8","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Chameleon: A Hybrid, Proactive Auto-Scaling Mechanism on a Level-Playing Field 摘要： Auto-scalers for clouds promise stable service quality at low costs when facing changing workload intensity. The major public cloud providers provide trigger-based auto-scalers based on thresholds. However, trigger-based auto-scaling has reaction times in the order of minutes. Novel auto-scalers from literature try to overcome the limitations of reactive mechanisms by employing proactive prediction methods. However, the adoption of proactive auto-scalers in production is still very low due to the high risk of relying on a single proactive method. This paper tackles the challenge of reducing this risk by proposing a new hybrid auto-scaling mechanism, called Chameleon, combining multiple different proactive methods coupled with a reactive fallback mechanism. Chameleon employs on-demand, automated time series-based forecasting methods to predict the arriving load intensity in combination with run-time service demand estimation to calculate the required resource consumption per work unit without the need for application instrumentation. We benchmark Chameleon against five different state-of-the-art proactive and reactive auto-scalers one in three different private and public cloud environments. We generate five different representative workloads each taken from different real-world system traces. Overall, Chameleon achieves the best scaling behavior based on user and elasticity performance metrics, analyzing the results from 400 hours aggregated experiment time. 含预测式模型的混合模型。 ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:9","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"RLPAS: Reinforcement Learning-based Proactive Auto-Scaler for Resource Provisioning in Cloud Environment ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:10","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"PASCAL: An architecture for proactive auto-scaling of distributed services ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:11","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Dynamic workload patterns prediction for proactive auto-scaling of web applications ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:12","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Supporting Programmable Autoscaling Rules for Containers and Virtual Machines on Clouds ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:13","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"A Fuzzy-based Autoscaling Approach for Process Centered Cloud Systems ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:14","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"TOSCA-Based and Federation-Aware Cloud Orchestration for Kubernetes Container Platform ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:15","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Serverless computing for container-based architectures ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:16","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"Dynamic SAR for Efficient Container Auto-Scaling based on Network Traffic Prediction ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:17","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机论文阅读"],"content":"K8-Scalar: a workbench to compare autoscalers for container-orchestrated database clusters ","date":"2020-04-11","objectID":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/:2:18","tags":["微服务调度","论文总结"],"title":"【总结性】微服务调度相关论文","uri":"/posts/20200411_%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"},{"categories":["计算机基础"],"content":"原文地址 内容上主要是复习了B树和红黑树，其他的因为太简单所以就只是过了一下，没记录下来 数据结构与算法复习 不包括全部内容 基础部分包括大O记号和小o记号的意义，P问题和NP问题和NP hard问题 B树和B+树 AVL平衡树和红黑树 KMP 资料： B站-内功心法，红黑树、平衡树、B树和B+树 清华大学邓俊辉-数据结构与算法，我计划把这篇与它的计算几何做两个观后笔记。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:0:0","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"B树和B+树 资料来源： MIT6.046 博客 M阶B树的特征： 非叶子结点最多只有M个分支 除根节点以外的非叶子结点分支数为上取整(M/2)到M。 关键字个数=分支数-1 所有叶子结点位于同一层 区别： B树的关键字集合分布在整棵树中，而B+树的实际数据只在叶子节点中。因此B树的搜索有可能在非叶子结点结束。 因为B+树的所有数据都在叶子节点中，所以B+树的叶子节点会依据关键字的大小自小而大的顺序链接，可以进行顺序遍历。非叶子结点可以看作是索引，结点中仅含有子树中的最大或最小关键字。同一个数字会在不同结点中重复出现。 B+树的查询优势： B+树的中间结点不保存数据，所以磁盘也能够容纳更多结点元素 B+树的查询必须查找到叶子节点，B树不必，因此B+树查找更加稳定，但并不慢 对于范围查找来说，B+树只需要遍历叶子节点链表（因为是顺序链接的），而B树需要重复进行中序遍历。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:1:0","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"红黑树 参考资料2：简书-30张图了解红黑树 参考资料3：清华大学邓俊辉-红黑树演示 参考资料4：使用2-4树看待红黑树 AVL树：平衡二叉树，每个节点平衡因子的绝对值不超过1，即左右子树高度差不超过1。 最大的作用是使得二叉查找树更平衡，本质上是特殊的二叉查找树。 红黑树的性质： 每个结点不是红色就是黑色 不可能有连在一起的红色节点。 根节点一定是黑色root 每个红色节点的两个子节点都是黑色。叶子节点都是黑色。 为了满足性质，有三种变化： 红变黑，黑变红，保证根节点是黑色 左旋 右旋 所有插入的点默认为红色。（PS：叶子节点为黑色）为什么这么规定：因为红黑树中所有的点都是黑色，也是满足要求的，这样可能会造成问题。 变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子节点也是红色（叔叔结点）。 把父结点设为黑色 把叔叔也设为黑色 把祖父结点，也就是父节点的父节点设为红色 把指针定义到祖父结点设为当前要操作的分析的点变换的规则 左旋：当前父结点是红色，叔叔结点是黑色，且当前结点是右子树。左旋以父节点为左旋。 右旋：当前父结点是红色，叔叔结点是黑色，且当前的结点是左子树。右旋 把父节点变为黑色 把祖父节点变为红色 以租父节点旋转 重要例子： ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:2:0","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"红黑树 根据邓俊辉老师的思路来，之前那个人很多没有讲 3+4重构，AVL保持平衡的方式，因为涉及到3个结点和4个子树，被称为3+4重构。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:3:0","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"基础定义 红黑树是一种persistent data structure，操作不会就地更新，而是会生成一个新的数据结构。 定义： 树根必定为黑色 外部节点均为黑色 其余节点：如果为红色，只能有黑色的孩子 外部节点到根：途中黑节点数目相等。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:3:1","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"提升变换 红黑树的提升变换：红黑树本质上是2-4树，即4路平衡树。进行提升变化后可以变为原来的4阶B树。 提升变化操作：将黑节点与其红孩子（可以迭代）视为B树的超级节点即可得到红黑树。4阶B树拆分，超级结点如果超过1个，则红黑相间且黑色占多数，则可以拆分成红黑树。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:3:2","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"双红缺陷与修正 双红缺陷：有两个红结点相邻，表现在B树上是有两个红结点在B树中相邻。调整上可以使用局部3+4重构，重新染色。 已知本结点与父结点为红色 RR-1：叔叔结点u-\u003ecolor=B，此时重新染色即可。 RR-2：叔叔结点u-\u003ecolor=R，此时合并为有4个关键码的超级结点，有3个红色。此时有5个分支，在4阶B树中是非法的，会发生上溢。B树中修复上溢，需要在问题结点中找到居中的关键码并进行分裂。 调整完成后，g作为新的调整基准点与上层进行调整。如果为根节点，则直接转为黑色并进行颜色变换处理。 双红修正算法复杂度： 因此会更加关心重构操作，因为这对于一个持久化结构而言更加重要。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:3:3","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"删除 按照BST的常规算法，删除操作会将检索到的数据点移除，并用某一个后代来替代。但红黑树的性质不一定会继续加以维持。有可能违反3、4的性质。 情况0：被删除结点有一个红孩子。因为黑结点与其红孩子之间存在一条虚边，将红孩子上移并染色本质上相等于删除这条虚边，这样外部节点的黑距离是不变的，性质3也不会受到影响。 问题： 双黑缺陷，此时外部节点的黑高度是不同的。从B 树角度，所属结点发生了下溢。需要考察两个结点，一个是原树中的父亲，一个是原树中的兄弟。 BB-1：下只是可能下的一种情况，其余情况与其对称或相似，不失一般性。下有三个结点，四棵子树，对此情况进行一次3+4重构 从第二幅图可以看出，双黑操作对应的是下溢，此时可以用B树操作进行处理。（PS，我个人觉得从2-4树的角度，第二幅图的结点颜色应该为黑色，不然很不对劲），对应的是3+4重构。 s为黑，且两个孩子均为黑。根据父结点为红或黑分为两种子情况。 BB-2R：此时s所在的超级结点不够数量借出，因此直接合并。上层结点失去了一个关键码p，但不会继续发生下溢。因为p是红色的，因此超级结点中至少有一个黑色的父亲。 BB-2B：下层下溢会引发上层下溢，从而向上延伸 BB-3：兄弟结点S为红色，其余孩子均为黑。 将BB-3转换为之前的情况 问题没有解决：黑高度的异常依然存在。但无形中r已经有了黑色的兄弟s’，由于p已经转为红色，之后只可能为BB-1或BB-2R。于是再经过一轮修复，红黑树的性质必然可以恢复。 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:3:4","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"红黑树具体实现 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:4:0","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"红黑树的插入 插入后需要进行的操作：检索插入位置并执行插入，插入后如果改变红黑树性质则进行平衡。 注意，插入的结点一定为红色。 如果插入的结点的父节点为黑色，直接插入 如果插入结点的父节点为红色，则如上文的双红问题，以叔叔结点是否存在或颜色为判断标准. 设父结点为P，叔叔结点为S，祖父结点为PP ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:4:1","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"红黑树的删除 ","date":"2020-04-07","objectID":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/:4:2","tags":["考研","数据结构与算法","算法_B树","算法_红黑树"],"title":"数据结构与算法复习","uri":"/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"原文地址 软件测试复习 对大三下学期的软件测试课程进行复习 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:0:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"第一章 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:1:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"计算机软件体系结构 软件体系结构是软件系统的结构、行为和属性的高级抽象，给出系统的组织结构和拓扑结构，规定系统需求和构成系统的元素之间的对应关系。 Layered Architecture：n层模型，比如TCP\\IP使用的那种。例子：Presentation Layer-\u003eBusiness Layer-\u003e Persistent Layer-\u003e Database Layer。核心思想是组件间的分离与功能上的聚合。 Event-Driven Architecture：常用于异步通信架构，由高度解耦合且单一目的的事件处理组件所构成。 MicroKernal Architecture：用于实现基于产品的应用的自然表示，即将大量第三方库插入进核心代码中。Core system提供了核心功能，plug-in module则可以是第三方库等能够轻松调换的代码。通过分离可以实现应用特性和具体实现的分离。 Microservices Architecture：微服务架构，面向服务的架构。按照单元分解，采用分布式架构，一般具有统一的用户交互层。 Space-Based Architecture：特定于解决扩展与并发问题。应用数据统一存储于内存中，同时通过扩展处理单元的方式实现应用处理能力的增加。 软件=程序+数据+文档+服务、 是能够完成预定性能和功能的、可执行的计算机指令。 软件需要有描述程序的操作和使用的文档。 1976: Algorithm+Data Structure = Programs 生产软件产品的基本步骤：软件规格说明、设计与实现、确认、演进。 软件开发方法： 面向数据流的结构化程序开发方法。指导思想是自顶向下，逐步求精；基本原则是功能的分解与抽象。很适合数据处理领域的问题。 面向数据结构的开发方法(Jackson方法)：描述问题的输入、输出数据结构，分析其对应性，设计相应的程序结构，从而给出问题的软件过程描述。以数据结构为驱动。 基于模型的方法，支持程序开发的形式化方法，把软件系统当作模型来给予描述，把软件的输入、输出看作模型对象，把这些对象在计算机内的状态看作该模型在对象上的操作。 面向对象的开发方法：指导思想是尽量按照人类认识世界的方法和思维方式来分析和解决问题。 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:1:1","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"第一章 1.2 软件工程生命周期 软件生命周期的6个阶段： 可行性分析与计划阶段：确认软件开发的总体目标、估计可利用的开发资源，最后提交可行性分析报告。 需求分析阶段：分析用户提出的要求 设计阶段：概要设计/逻辑设计（把各项软件需求转换成软件的体系结构）、详细设计/物理设计（按照概要设计分解的每个模块所要完成的工作进行具体的描述）、提交概要结构设计说明书等文档 实现阶段：完成源程序的编码、编译和运行调试、编写进度日报周报、测试计划、提交用户手册等 测试阶段：全面测试目标软件系统，并检查审阅已编制的文档。 运行与维护阶段：软件提交给用户后，在运行使用中得到持续的维护；改正性维护、适应性维护和完善性维护。 前五个阶段合称开发阶段。 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:2:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"软件生命周期模型 包括瀑布模型、VW模型、快速应用开发模型、原型模型、迭代模型、螺旋模型、喷泉模型、基于构建的开发模型、Rational统一过程模型、敏捷开发模型与极限编程。 瀑布模型 特征： 本阶段活动的工作对象来自于上一项活动的输出。输出一般代表本阶段活动结束的里程碑文档。 根据本阶段的活动规程执行相应的任务 本阶段活动产出的相关的软件工件，作为下一阶段活动的输入。 对本阶段活动执行情况进行评审。 优点： 降低软件开发的复杂程度 推迟软件实现，强调在软件实现前必须分析和设计工作 以项目的阶段评审和文档控制为手段，有效对整个开发过程进行指导，保证阶段之间的正确衔接。 缺点： 过于强调活动的线性顺序。 缺乏灵活性，无法解决软件需求不明确或不准确地问题。 风险控制能力较弱 瀑布模型中的软件活动是文档驱动的，当阶段之间规定过多的文档时，会极大地增加系统的工作量。 管理人员仅以文档的完成情况来评估项目完成进度，容易产生误判。 V模型 主要贡献：以测试为中心，明确标明了测试过程中存在的不同级别，并清楚地描述了这些测试级别与软件生命周期各阶段的对应关系。 局限性： 把测试作为编码之后的最后一个活动，会导致需求分析等前期阶段产生的错误直到后期的验收测试才能被发现，无法体现”尽早地和不断地进行软件测试“的原则。这会大幅地提高修补需求缺陷的成本。 W模型 W模型是V模型的演进，在开发中是一个V，在测试中是另外一个并行的V。基于”尽早地和不断地进行软件测试“的原则。 W模型强调测试是伴随着整个软件开发周期，而且测试的对象不仅仅是程序，同样也需要测试需求、功能和设计。 局限性： 将软件的开发视为需求、设计、编码等一系列按时间顺序串行的活动。无法支持迭代、自发性以及需求功能的变更调整。 快速应用开发模型 Rapid Application Development，能够使得开发小组在很短时间内创建出一个功能完善的系统。 优点： 开发速度快，同时质量有一定保证。 对管理信息系统的开发特别有效。 缺点： 应用局限性：主要用于管理信息系统开发 开发者和用户都需要在短时间内去完成一系列的需求分析，任何一方配合不当都会导致RAD项目失败。 对模块化要求较高，如果存在不能被模块化的功能，那么构件会存在问题。 技术风险很高的情况下，不能够使用RAD模型。 原型模型 线性顺序方法的局限：如果前一个阶段的工作无法完成，则后一个阶段的任务无法开始。而很多时候，开发者难以获得完成的系统需求规格说明。 原型方法：在获得一组基本需求后，通过快速分析构建出一个小型的软件系统原型，满足用户的基本要求。 这样，用户通过使用原型系统提出修改意见，从而减少用户与开发人员关于系统需求的误解，使需求尽可能的准确。 优点：符合人们认知事物的一般规律 缺点：大型系统难以使用。而且容易忽略文档工作，带来资源浪费、项目规划和管理困难等问题。 演化模型 两次开发。第一次试验开发，得到试验性的原型产品，目标在于探索可行性，确定软件需求。第二次产品开发，在原型产品的基础上获得最终软件产品。 迭代和增量模型 迭代开发是事前确定好要开发什么，然后一步步将其完成。 增量开发是事前并不确定开发出的制成品，一步步实现后补齐。 优点：降低失败风险、提高系统可靠性 缺点：建立初始模型的时候，需要确定基本业务服务。而且增量粒度难以确定。 螺旋模型 计划-\u003e风险分析-\u003e实现与测试-\u003e评估，如此反复。 主要针对大型软件项目的开发。 四个象限： 确定目标：确定软件项目目标；明确对软件开发过程和软件产品的约束；制定详细的项目管理计划；根据当前的需求和风险因素制定实施方案，并进行可行性分析，选定一个实施方案，并对其进行规划。 识别和解决风险：明确每一个项目风险，估计风险发生的可能性、频率、损害程度，并指定风险管理措施来规避这些风险。 工程实现：针对每一个阶段的任务要求执行开发和测试活动。 准备下一轮迭代：客户使用原型，反馈修改意见；根据客户的反馈，对产品及其开发过程进行评审，决定是否进入螺旋线的下一个回路。 优点：螺旋模型是风险驱动的迭代过程，结合了瀑布模型和快速原型方法，将项目的风险降低。同时每一次迭代只包含了瀑布模型中的某一个或两个阶段。 但是有一定的限制条件： 强调风险分析，但是外部客户并不一定接受风险，所以一般用于内部大型项目 风险分析需要额外的成本 失误的风险分析可能问题更加严重。 喷泉模型 喷泉模型是一个迭代模型。软件开发的各个极端是相互重叠和多次反复的，就像喷泉一样，水喷上去又可以落下去，既可以落在中间，又可以落到底部。 优点是可以提高开发效率、缩短开发周期 缺点是管理有一定的难度 构建组装模型 利用模块化思想讲整个系统模块化，并在一定构建模型的支持下复用构建库中的一个或多个软件构件，并通过组装过程高效率、高质量地构造软件系统。 优点是允许软件复用从而提高软件开发效率，同时允许多个项目同时开发，降低费用、提高可维护性，可实现分布提交软件产品。 缺点：缺乏通用的构建组装结构标准，带来较大的开发风险。构建可重用性和系统高效性之间不易协调；由于过分依赖构件，构件的质量影响着最终产品的质量。 RUP统一过程模型 Rational Unified Process，是一种基于UML的、以构架为中心、用例驱动与风险驱动相结合的迭代增量过程。 基本结构： 传统的瀑布模型是一个单维的时间顺序模型，开发工作被划分为多个连续的阶段。在一个时间段内，只能实施某一个阶段的工作比如分析、设计或实现。 RUP是一个二维空间。时间维度从组织管理的角度描述整个软件开发生命周期，是RUP的动态组成部分，它可以进一步描述为周期cycle、阶段phase和迭代iteration 核心工作流程维度是从技术角度描述RUP的静态组成部分，它可以进一步描述为工作流workflow、角色worker、行为activities和产品/工件artifact。 时间维度： RUP中的软件生命周期在时间维度上被分解为四个顺序的阶段：初始阶段Inception、精化阶段Elaboration、构建阶段Construction和产品交付阶段Transition。每个阶段结束于一个主要的里程碑，并在阶段结尾执行一次评估以确定这个阶段的目标是否已经满足。 初始阶段：目标是为系统建立业务案例并确定项目的边界。确定项目边界需要识别所有与系统交互的外部实体，并在较高层次上定义外部实体与系统交互的特性，主要包括识别外部角色、识别所有用例并详细描述一些用例。 精细阶段：分析问题领域，建立健全的体系结构基础，编制项目计划，完成项目中高风险需求部分的开发。 构建阶段：完成所有剩余的技术构件和稳定业务需求功能的开发，并集成为产品，详细测试所有的功能。只是一个过程，重点放在管理资源以及控制开发过程以优化成本、进度和质量 产品化阶段/移交阶段：确保软件对最终用户是可用的。产品化阶段可以跨越几次迭代，包括为发布做准备的产品测试，基于用户反馈的少量调整。 核心工作流程维度结构： 业务建模 需求 分析与设计 实施 测试 部署 RUP的迭代增量开发思想 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:2:1","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"软件复杂度分析 规模：通常由总共指令数，或源程序行数表示。例如line count复杂度。基本的思想是统计一个程序模块的源代码行数。 难度：通常由程序中出现的操作数的数据所决定的量表示。例如Halstead复杂度，使用操作符和操作数的量来衡量。设n1表示程序中不同的操作符个数，n2表示程序中不同的操作数个数，N1表示程序中操作符总数，N2表示程序中的操作数总数。可以计算出各种参数。 结构：通常由与程序结构有关的度量表示。例如McCabe复杂度，包括环路复杂度、基本复杂度等。McCabe环路复杂度，数量上可以表现为程序控制流图，V(G)=m-n+2p，m是G的边数，n个G的点数，p是G的连通分支数。 智能度：算法的难易程度。 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:3:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"白盒测试 定义：白盒测试按照程序内部逻辑结构和编码结构来设计测试数据并完成测试，是一种动态测试方法。 逻辑覆盖：以程序内部的逻辑结构为基础的一种白盒测试方法，建立在测试人员对程序的逻辑结构清晰了解的基础上，是一大类测试过程的总称。包括语句覆盖、判定覆盖、条件覆盖、判定-条件覆盖、条件组合覆盖、路径覆盖等。 DD-路径测试：Decision-to-Decision path，要求测试所有的路径。 路径测试：设计出足够多的测试用例，覆盖被测试对象中所有可能执行路径。 基本路径测试：在实际的应用中，即使是不大的应用，想要测试所有路径也是不现实的。在不能做到覆盖程序所有路径的情况下，如果能够对程序的每一个独立路径进行测试，那么可以认为程序中的每个语句都已经检验过或覆盖到。 基本路径测试在程序控制流图的基础上，通过分析McCabe环路复杂性，导出基本可执行路径集合，据此设计测试用例，保证在测试中程序的每一个可执行语句至少执行一次。 独立路径：至少沿一条新的边移动的路径。 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:4:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"黑盒测试 黑盒测试不考虑测试程序内部结构和处理过程，仅仅依据程序功能的需求规格设计测试用例，并推断测试结果的正确性。 黑河测试要求被测程序的特性或功能必须被一个测试用例或一个被认可的异常所覆盖，既要考察”程序是否做了应该做的“，也要考察”程序是否没有做不应该做的“。 方法： 一是等价类划分：完全不考虑被测程序的内部结构，只依据程序的规格说明来设计测试用例。会将所有可能的输入数据划分成若干部分，然后从每一部分中选取少数具有代表性的数据作为测试用例。 输入等价类即程序输入域的某个子集，该子集中，各个输入数据对揭露程序中的错误是等效的。 两种情况： 有效等价类：对于程序规格说明来说是合理的、有意义的输入数据组成的集合。 无效等价类：对于程序规格说明来说是不合理饿、无意义的输入数据组成的集合。 二是边界值分析法。先确定边界值情况，然后在正好等于、刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。 三是错误推测法，依靠测试人员的经验和直觉对被测程序中可能存在的各种错误进行推测，从而有针对性地编写测试用例。 四是随机测试法，即从被测程序中所有可能输入值中随机选取，基本的黑盒测试方法。 五是判定表法，要使得各个条件都能充分满足。 六是因果图法，考虑被测程序输入条件之间的联系和组合关系。 灰盒测试 结合黑盒测试、白盒测试、回归测试和变异测试，是一种软件全生命周期测试方法。 ","date":"2020-04-06","objectID":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/:5:0","tags":["考研","软件测试"],"title":"软件测试复习","uri":"/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"中山大学考研复试内容复习 原文地址 复试复习以基本概念为主，重点概念为主，偏题怪题一律不考虑。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:0:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"计算机网络 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"网络基础 OSI七层模型 OSI七层模型 OSI七层模型，从下到上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。 其中底下三层称为通信子网，是为了联网而附加上去的通信设备，完成数据传输功能。顶三层称为资源子网，相当于计算机系统，完成数据的处理等功能。 物理层：传输单位比特，功能是在物理媒体上为数据端设备透明的传输原始比特流。主要定义数据终端设备DTE和数据通信设备DCE的物理和逻辑连接方法。 物理层主要研究以下内容： 通信链路与通信结点之间的连接需要的电路接口的参数（机械形状、尺寸、交换电路的数量与排列） 通信链路上传输的信号的意义和电气特征，比如高低电平的规定，信号的规定等。 PS：传输信息所利用的一些物理媒体，比如双绞线、光缆、无线信道等，并不在物理层协议之内。 数据链路层：传输单位是帧，任务是将网络层传下来的IP数据组装成帧。功能为：成帧、差错控制、流量控制和传输管理。 差错控制：检测物理层发生的差错，并丢弃收到的错误信息。 流量控制：协调相邻物理结点之间的速度。 数据链路层协议：SDLC、HDLC、PPP、STP和帧中继 网络层：传输单位是数据报（分组、包），主要任务是把网络层协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 差错控制：同上 拥塞控制：如果拥塞状态使得网络层中的两个结点无法正常通信，则采用一些措施缓解拥塞。 网络层协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF 传输层：传输单位是报文段TCP或用户数据包UDP(报文)，任务是负责主机中两个进程之间的通信，功能为端到端提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 传输层协议：TCP、UDP 会话层：允许不同主机上各进程之间的绘画，利用传输层提供的端到端服务，管理主机之间的会话进程，包括建立、管理以及终止进程间的绘画。 表示层：主要用于处理在两个通信系统中交换信息的表示方式。比如不同机器会采用不同的编码和表示方式，以及数据结构。 应用层：最高层，包括FTP、SMTP、HTTP等协议。 TCP模型 网络接口层：对应于OSI的物理层和数据链路层，表示与物理网络的接口 网际层：（主机-主机），即OSI的网络层，将分组发往任何网络并独立选择合适的路由。 传输层：与OSI的传输层类似，使发送端和目的端的主机上的对等实体可以进行会话，主要使用TCP和UDP。 应用层：用户-用户，包含所有高层协议，对应于OSI的应用层呢个、表示层和会话层。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"介质访问控制相关 CSMA相关模型 3.5.1 信道划分介质访问控制 使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。 多路复用技术：传输介质的带宽超过了传输单个信号所需的带宽时，在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率。即将多个输入通道的信息整合到一个复用通道，然后在接收端把收到的信息分离出来传送到对应的输出通道中。 信道划分的实质是通过分时、分频、分码等方法，把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道。 频分多路复用FDM：将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号的多路复用技术。即将物理信道的总带宽分割成若干格传输单个信号带宽相同（略宽）的子信道 时分多路复用TDM：将一条物理信道按时间分成若干个时间片，轮流地分配给多个信号使用。每一个时间片复用的一个信号占用。利用每个信号在时间上的交叉，在一条物理信道上传输多个信号。改进：STDM，统计时分多路复用，可以动态地分配时隙，提高线路的利用率。 波分多路复用WDM：光的频分多路复用，在一根光纤中传输多种不同波长的光信号，最后用波长分解复用器将各路波长分解出来。 码分多路复用CDM：靠不同的编码来区分各路原始信号，既共享信道的频率、又共享时间。码分多址CDMA是码分复用的一种方式。（要求各个站点的芯片序列是相互正交的）优点：抗干扰能力强、保密性强、语音质量好，主要用于无线通信特别是移动通信领域。 3.5.2 随机访问介质访问控制 随机访问协议中，如果有两个或多个用户同时发送信息，就会造成冲突，产生帧的碰撞，导致所有冲突用户的发送均以失败告终。 算法思想：胜利者通过争用获得信道，从而获得信息的发送权。又称为争用型协议，实质上是将广播信道转化为点对点通信的行为。 纯ALOHA协议：任何一个站点需要发送数据时，可以不进行任何检测就发送数据。如果一段时间内没有收到确认，该站点就认为传输过程中发生了冲突。发送站点需要等待一段时间后再发送数据，直至发送成功。（等待的时间随机）缺点是吞吐量很低。 时隙ALOHA协议：在时间上把所有站点同步起来，并将时间划分为一段段等长的时隙，规定只能够在每个时隙开始的时候才能发送一个帧，以避免用户发送数据的随意性。这样，每个帧正好在一个时隙内发送完毕，碰撞重传的机制是一样的。吞吐量S与网络负载G的关系是S=Ge^(-G)，当G=1时S=0.368，达到最大值。 1-坚持CSMA协议：当一个结点要发送数据时，首先侦听信道，如果信道空闲立即发送数据；如果信道忙则等待，同时继续侦听直至信道空闲。如果发生冲突，则随机等待一段时间，再重新侦听信道。（1的意思是侦听到信道空闲后，发送帧的概率为1）。受传播延迟的影响较大 非坚持CSMA：当一个结点要发送数据时，首先侦听信道；如果信道空闲就立即发送数据；如果信道忙就放弃侦听，等待一个随机的时间后再重复上述过程。降低了冲突的概率，但是使得数据在网络中的平均延迟增加了。 p-坚持CSMA：用于时分信道，基本思想是当一个结点要发送数据时，首先侦听信道，如果信道忙，则等待下一个时隙再侦听；如果信道空闲，便以概率p发送数据，依次类推。这个过程一直持续到数据发送成功或者其他结点发送数据而检测到信道忙为止。若是后者，则等待一个随机时间后再重新开始侦听。 CSMA/CD协议，载波侦听多路访问/碰撞检测，是CSMA的改进方案（特点是边听边发，CSMA的侦听和发送不是同时的），适用于总线型网络或半双工网络环境。即每一个站在发送数据之前先检测一下总线上是否有其他站点在发送数据。如果有，则暂时不要发送数据，要等待信道变为空闲再发送。碰撞检测就是边发送边侦听。概括为先听后发，边听边发，冲突停发，随机重发。 显然，CSMA/CD不可能进行全双工通信，只能进行半双工通信。 争用期：把以太网端到端往返时间称为争用期，又称为冲突窗口或碰撞窗口。每一个站在自己发送数据之后的一小段时间内，存在着遭遇冲突的可能性，只有经过争用期这段时间还没有检测到冲突，才能确定这次发送不会发生冲突。 为了确保发送站在发送数据的同时能检测到可能存在的冲突，需要在发送完帧之前就能收到自己发送出去的数据，也就是说帧的传输时延至少要两倍于信号在总线中的传播时延。CSMA/CD总线网的所有数据帧必须要大于一个最小帧长，最小帧长=总线传播时延*数据传输速率*2 比如对于以太网，规定51.2微秒的争用期，则对于10Mb/s的以太网，争用期内可发送512bit，如果前64B未发送冲突，则后面也不会发生冲突。因此规定最短帧长为64B。 CSMA/CD的重点在于二进制指数退避算法，以此来从冲突中恢复。 确定基本退避时间，一般取两倍的总线端到端传播时延。（即争用期） 定义参数k=重传次数，且不超过10 从离散整数集合{0,1,2,…,2^k-1}中选择一个数，重传所需要的退避时间就是r倍的基本退避时间。（全取） 重传达16次仍不能成功，说明网络太拥挤，抛弃此帧并向高层报告出错。 CSMA/CA协议。CSMA/CD成功用于有线连接的局域网，而CSMA/CA则是在无线局域网环境运行的。CA即为碰撞避免。碰撞避免的实现： 二进制指数退避算法 预约信道。发送方在发送数据的同时通知其他站点自己传输数据所需要的长度。 ACK帧，站点在正确收到发给自己的数据帧后，都需要发回一个ACK帧 RTS/CTS帧，可选的碰撞避免机制，主要用于解决无线网中的隐蔽站问题。 与CSMA/CD的区别： 吞吐量计算 网络负载（T0时间内所有站点发送的成功和未成功而重传的帧数）G 网络吞吐量（T0时间内成功发送的平均帧数）S 算法名称 计算公式 ALOHA S=Ge^(-2G) 时隙ALOHA S=Ge^(-G) 3.5.3 轮询访问介质访问控制：令牌传递协议 用户不能随机地发送信息，而是通过一个集中控制的监控站，以循环的方式轮询每一个结点，再决定信道的分配。当某结点使用信道时，其他结点都不能使用信道。 令牌传递协议：一个令牌再各结点之间以某个固定次序交换，令牌是一组特殊的比特组合而成的帧。环上的一个站希望传送帧时，必须等待令牌，一旦收到令牌，站点便可启动发送帧。帧在环上发送的时候，所有站点一律进行转发，直到到达始发站，并由始发站撤销该帧。 物理拓扑不必成环，但是为了把对访问介质的许可从一个设备传递到另一个设备，令牌在设备间的传递通路在逻辑上必须是一个环。 非常适合负载很高的广播信道 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:2","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"通信基础 如何保证可靠传输。拥塞控制与流量控制。 在通信子网中，由于过量的分组而引起的网络性能下降称为拥塞。 判断网络是否进入拥塞状态的方法：观察网络的吞吐量与网络负载的关系。 如果随着网络负载的增加，网络的吞吐量明显小于正常的吞吐量，那么网络就可能进入“轻度拥塞”状态；如果网络的吞吐量随着网络负载的增大反而下降，网络就可能进入拥塞状态；如果网络的负载继续增大，而网络的吞吐量下降到零，网络就可能进入到死锁状态。 拥塞控制主要解决的问题：如何获取网络中发生拥塞的信息，从而利用这些信息进行控制，以避免由于拥塞出现分组的丢失以及严重拥塞而产生网络死锁的现象。目标是确保子网能够承受所达到的流量。 流量控制：发送端到接收端点对点通信量的控制，局部问题。 拥塞控制：确保通信子网能够传送待传送的数据，全局问题。 方法： 开环控制：静态预防方法，在设计网路的时候将有关发生拥塞的因素考虑周到，力求网络在工作时不产生拥塞。控制手段：确定何时接收新流量、何时可丢弃分组以及哪些分组，确定何种调度决策等。共性：在做决定时不考虑当前网络的状态。 闭环控制：事先不考虑有关发生拥塞的各种因素，采用监控网络系统去监视，及时检测到哪里发生拥塞，然后将拥塞信息传到合适的地方，以便调整网络系统的运行，并解决出现的问题。动态的方法。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:3","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"TCP相关 TCP连接的三个阶段：连接建立、数据传送和连接释放 TCP连接的建立：三次握手。 第一步，客户端向服务端发送SYN=1,seq=x且不含应用层数据的特殊报文段。 第二步，服务器为TCP连接分配TCP缓存和变量，在确认报文段中，SYN和ACK位置1，确认字号ack=x+1,seq=y 第三步，客户端也给该连接分配缓存和变量。ACK=1,seq=x+1,ack=y+1 TCP连接的释放，四次挥手。 第一步：客户机打算关闭连接，FIN=1,seq=u。发送FIN的一端不能再发送数据 第二步：服务器收到，ack=u+1,seq=v,ACK=1，TCP连接半关闭。 第三步：若服务器没有要向客户机发送的数据，就通知TCP释放连接，FIN=1，ACK=1,seq=w,ack=u+1 第四步：客户机确认释放报文段，ACK=1,ack=w+1,seq=u+1 总结序号变化：回复的ack=seq+1，seq=ack 5.3.4 TCP可靠传输 TCP校验和与UDP校验和一样 序号：TCP首部的序号字段(seq)用来保证数据能够有序提高给应用层。 确认：TCP首部的确认号是期望收到对方的下一个报文段的数据的第一个字节的序号。TCP使用累计确认，只确认数据流中至第一个丢失字节为止的字节。 重传：在超时或有冗余ACK的时候会重传。 冗余确认：TCP规定每当比期望序号大的失序报文到达时，发送一个冗余ACK，致命下一个期待字节的序号。 快速重传：同时TCP规定发送方收到对同一个报文段的3个冗余ACK时，就可以认为跟在这个被确认报文段之后的报文段已经丢失。 5.3.5 TCP流量控制 TCP流量控制是一个速度匹配服务，为了消除发送方发送速度过快使接收方缓存区溢出的可能性。TCP的流量控制是基于窗口实现的。 接收窗口rwnd:接收方根据自己接收缓存的大小，动态地调整发送方的发送窗口大小。 拥塞窗口cwnd：发送方那个根据当前对网络拥塞程序的估计而确定的值。 TCP通过报文的窗口字段将rwnd通知给发送方，表示接收方允许连续接收的最大能力，单位是字节。发送方根据收到的最新的rwnd来限制自己发送窗口的大小，将未确认的数据量控制在rwnd之内。实际上发送窗口的大小是取rwnd和cwnd的最小值。 5.3.6 TCP拥塞控制 拥塞控制的目的时为了防止过多的数据注入网中，使网络中的路由器或者链路不过载。 接收窗口rwnd:接收方根据自己接收缓存的大小所许诺的最新的窗口值，反应了接收方的容量，由接收方根据其放在TCP报文的首部的窗口字段通知发送方。 拥塞窗口cwnd：发送方那个根据自己估算的网络拥塞程度而设置的窗口值，反应了网络的当前容量。 发送窗口上限取rwnd和cwnd较小的一个。 维护拥塞窗口 慢开始算法：在TCP刚连接好时，发送方设置拥塞窗口cwnd=1，即一个最大报文长度MSS，然后在每收到一个对新的报文段的确认后，将cwnd加1。这样，每个RTT后，cwnd加倍。直到超过阈值ssthresh。 拥塞避免算法：cwnd每经过一个MSS就加一而不是加倍。当出现一次超时，ssthresh等于当前cwnd的一半。 网络拥塞的处理：遇到网络拥塞，将ssthresh=cwnd/2，并将cwnd=1，执行慢开始算法。 快重传和快恢复 快速重传：当发送方连续收到三个重复的ACK报文时，直接重传对方尚未收到的报文段。 快恢复：当发送端收到连续三个ACK时，ssthresh=cwnd/2，但是cwnd=cwnd/2（即此时的阈值） 重传时间间隔 相关资料：B站视频 对应的标准为RFC6298 TCP需要设置一个重传的时间间隔，太短会导致过多的重传，太长会影响算法性能。因此使用了Jacobson算法来进行参数的设置。 需要维护以下几个变量： RTT，往返时间估计量，测量TCP本次的往返时间M，RTT = aRTT + (1-a)M，a为平滑因子，典型值为7/8 D，平滑的平均偏差。D = aD + (1-a)|RTT-M|，此处的a为3/4 重传的定时值=RTT+4D Jacobson 算法只用于处理正常的情况，但是当发生重传后，如果收到一个确认，这时候就不用这个算法来调整 RTO 值了。因为你无法判断这个确认是针对第一次传输，还是后来的重传。在这种情况下，采用 Karn 算法来调整 RTO 的值 。 Karn 算法很简单： 1）、 对于发生重传的数据段，在收到确认后，不更新 RTT 2）、在重传的时候，RTO 是倍增的，直到达到最大值的限制。如果重传超过一定的次数，TCP 连接会断开 3）、在重传并收到确认后，如果下一次的数据段没有发生重传（即一次性收到确认），则又恢复 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:4","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"QoS QoS提供以下三种服务模型： l Best-Effort service（尽力而为服务模型）是一个单一的服务模型，也是最简单的服务模型。对Best-Effort服务模型，网络尽最大的可能性来发送报文。但对时延、可靠性等性能不提供任何保证。是网络的缺省服务模型，通过FIFO队列来实现。它适用于绝大多数网络应用，如FTP、E-Mail、IP传输等。 l Integrated service（综合服务模型，简称Int-Serv）Int-Serv服务模型Int-Serv是一个综合服务模型，它可以满足多种QoS需求。该模型使用资源预留协议（RSVP），RSVP运行在从源端到目的端的每个设备上，可以监视每个流，以防止其消耗资源过多。这种体系能够明确区分并保证每一个业务流的服务质量，为网络提供最细粒度化的服务质量区分。Inter-Serv模型对设备的要求很高，当网络中的数据流数量很大时，设备的存储和处理能力会遇到很大的压力。Inter-Serv模型可扩展性很差，难以在Internet核心网络实施。 l Differentiated service（区分服务模型，简称Diff-Serv）Diff-Serv服务模型Diff-Serv是一个多服务模型，它可以满足不同的QoS需求。与Int-Serv不同，它不需要通知网络为每个业务预留资源。区分服务实现简单，扩展性较好。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:1:5","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"操作系统 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"进程与线程 线程的生命周期 同步，信号量等 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"死锁 死锁的四要素 死锁的解决方案 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:2","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"内存 内存页面分配 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:3","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"文件 文件实现 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:4","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"IO 四种IO的特点 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:2:5","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"计算机组成 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"架构 CPU、缓存、内存三层体系架构 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"内存与缓存 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:2","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"指令寻址方式 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:3","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"流水线 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:4","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"中断与异常 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:3:5","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"数据结构与算法 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"大O表示法的意思 时间复杂度指的是程序语句的执行次数，空间复杂度指的是一个算法在运行过程中临时占用存储空间的大小。 大O表示法即时间复杂度的上界，是描述函数渐进行为的数学符号，因此称为渐进上界。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"算法的特征 有穷性：必须能够在有限个步骤后终止。 有输入：允许0个输入，表示算法给定了初始条件。 有输出：没有输出的算法是没有意义的。 确定性：算法的每一个步骤必须有确切的定义。 可行性：算法的每一个步骤都可以被分解成基本的可执行步，每一个可执行步可以在有限的时间内完成。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:2","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"基础结构 数组与链表的区别，逻辑结构和数据结构 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:3","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"排序算法 二分排序、快速排序等 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:4","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"树和图 B树和B+树 B树的特点： 所有叶子节点均在同一层。 一般索引结点存在磁盘中，数据存在内存中，用以实现索引。 M阶B树，每个子结点最多有M-1个关键字，最少有ceil(M/2)-1个关键字 B+树与B树的区别，在于数据全部在叶子节点内，所以可以顺序索引。 B+树能够容纳更多的索引结点，显得更加矮胖 B+树必须查找到叶子节点，所以B+树的查找更稳定。 对于范围查找来说，B+树只需要遍历叶子链表，而B树需要反复进行中序遍历。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:5","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"高级算法 扩展，KMP、红黑树 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:4:6","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"数据库 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:5:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"概念模型 实体(entity)：客观存在并相互区别的事物称为实体 属性(attribute)：实体的某一特定属性称为属性 码(key)：唯一标识实体的属性集 ER模型：实体-联系方法 常用的数据模型：层次模型、网状模型、关系模型、面向对象数据模型、对象关系数据模型、半结构化数据模型。 关系运算：选择、投影、连接、除运算 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:5:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"存取方法 存取方法是快速存取数据库中数据的技术。常用的有索引方法和聚簇方法 B+树索引和哈希索引是最经典的两种方式。 B+树索引 索引 B树和B+树，插入、删除、维护、查询 哈希的原理，区间查询 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:5:2","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"数学 高等数学 中值定理 拉格朗日乘数法 线性代数： 什么时候方程有解、有一解、有多解 矩阵相关知识：矩阵的迹 线性代数的相关性 离散数学： 等价 集合：有穷集和无穷集 函数与关系 概率论： 贝叶斯和全概率公式 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:6:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"软件工程 软件测试和需求分析和系统分析与设计 软件测试方法： 等价类划分… 软件工程管理： 核心路径管理 系统分析与设计： UML图： 用例视图： 用例图：显示系统的外观可视行为 静态视图： 类图：显示类的定义和关系 对象图：某种状态或时间段内，系统中活跃的对象及其关系 包图：显示设计的层次结构 行为视图： 顺序图：显示对象随着时间的交互 状态图：显示响应时间的状态改变 活动图：显示系统行为的描述 实现视图： 组件图：显示系统的体系结构 部署图：显示系统的物理体系结构 分析过程 设计模式：工厂模式，等等 软件生命周期 CMM，提出者，级别 软件工程需求分析所用的模型。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:7:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"计算机视觉 基础知识为主，要知道一些算法是干什么的，怎么用。 重点集中在我所做的实验上。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:8:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"边缘检测 canny边缘检测 代码：https://blog.csdn.net/xiajun07061225/article/details/6926108 首先进行高斯滤波，然后进行梯度计算，对梯度进行非最大值抑制来瘦边，然后利用双阈值法来确定阈值，小于下阈值设为0，大于上阈值设为1。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:8:1","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"机器学习和人工智能 围绕那两本课本完成。 可以参考算法工程师的面试题，比如正则化的意义之类的。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:9:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"神经网络 同上，以基础知识为主 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:10:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"云计算 本行，要准备一下自己的项目经历，毕业设计相关，等等。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:11:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["计算机基础"],"content":"时间序列预测 同上，好好组织语言。 ","date":"2020-04-04","objectID":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/:12:0","tags":["考研"],"title":"中山大学考研复试内容复习","uri":"/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/"},{"categories":["英语学习"],"content":"原文地址 复试英语翻译练习 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:0:0","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"计划 计划对A类会议的部分论文的概述进行实时翻译（录音），并再写一份答案作为巩固。 会议参考：https://blog.csdn.net/qq_36556893/article/details/94431877 计算机系统与高性能计算 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:1:0","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"ASPLOS 2019 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:2:0","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"Buffets: An Efficient and Composable Storage Idiom for Explicit Decoupled Data Orchestration 英文： Accelerators spend significant area and effort on custom on-chip buffering. Unfortunately, these solutions are strongly tied to particular designs, hampering re-usability across other accelerators or domains. We present buffets, an efficient and composable storage idiom for the needs of accelerators that is independent of any particular design. Buffets have several distinguishing characteristics, including efficient decoupled fills and accesses with fine-grained synchronization, hierarchical composition, and efficient multi-casting. We implement buffets in RTL and show that they only add 2% control overhead over an 8KB RAM. When compared with DMA-managed double-buffered scratchpads and caches across a range of workloads, buffets improve energy-delay-product by 1.53x and 5.39x, respectively. 翻译： 硬件加速器方向在传统的on-chip缓存领域探索了很多的方向、花费了很多的精力。不幸的是，这些解决方案都与特定的架构/设计紧密地结合，这组织了在其他加速器或领域的再使用。我们提出了自助餐架构，一个高效且可组合的存储习惯来满足加速器要独立于特定设计的需要。自助餐有着众多与众不同的特性，包括高效的解耦填充和对细粒度存储单元的同步访问，层次组合和高效的多播。我们在RTL中使用了自助餐架构，显示它们在8KBRAM上的工作只增加了2%的控制超载时间。当与DMA管理的双缓存便签和缓存在相同的一段工作负载的测试下，自助餐架构对能量延迟乘数的提升分别为1.53倍和5.39倍。 composable: composable system provides components that can be selected and assembled in various combinations to satisfy specific user requirements. idiom ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:2:1","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"Software-Defined Far Memory in Warehouse-Scale Computers 英文 Increasing memory demand and slowdown in technology scaling pose important challenges to total cost of ownership (TCO) of warehouse-scale computers (WSCs). One promising idea to reduce the memory TCO is to add a cheaper, but slower, “far memory” tier and use it to store infrequently accessed (or cold) data. However, introducing a far memory tier brings new challenges around dynamically responding to workload diversity and churn, minimizing stranding of capacity, and addressing brownfield (legacy) deployments. We present a novel software-defined approach to far memory that proactively compresses cold memory pages to effectively create a far memory tier in software. Our end-to-end system design encompasses new methods to define performance service-level objectives (SLOs), a mechanism to identify cold memory pages while meeting the SLO, and our implementation in the OS kernel and node agent. Additionally, we design learning-based autotuning to periodically adapt our design to fleet-wide changes without a human in the loop. Our system has been successfully deployed across Google’s WSC since 2016, serving thousands of production services. Our software-defined far memory is significantly cheaper (67% or higher memory cost reduction) at relatively good access speeds (6us) and allows us to store a significant fraction of infrequently accessed data (on average, 20%), translating to significant TCO savings at warehouse scale. 翻译： 内存需要的增加和技术扩展速度的降低对仓库级计算机的总拥有成本提出了更高的挑战。减少内存的总拥有成本的一个有前途的想法是增加一个更便宜但更慢的”远内存层“，并用它存储不经常访问的（或冷的）数据。然而，引入远距离内存层带来了新的挑战，包括动态对多样工作负载和搅动的响应，最小化内存搁浅，并解决棕地部署问题。我们提出了一种新颖的软件定义的远内存存储方式，可以主动压缩冷内存页来高效地在软件层面上创建一个远内存层。我们的端到端系统设计围绕新的方法定义了性能上的服务级别对象(SLO)，这是一个在遇到SLO的时候识别冷内存页的机制，我们的实现是基于系统内核和节点代理的。除此之外，我们设计了基于学习的自动参数调节系统来周期性地将我们的架构设计与更广泛的变化相适应，在这个循环中不用人介入。我们的系统已经成功地自2016年起Google的仓库级计算机上被部署，为上千个生产级服务来服务。我们的基于软件的远内存方法相较而言显著便宜于其他方法，并且能够达到一个相对较好的访问速度，并允许我们取存放不常用数据的一个重要的部分，从而实现在仓库级对总拥有成本的节省。 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:2:2","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"uops.info: Characterizing Latency, Throughput, and Port Usage of Instructions on Intel Microarchitectures 英文： Modern microarchitectures are some of the world’s most complex man-made systems. As a consequence, it is increasingly difficult to predict, explain, let alone optimize the performance of software running on such microarchitectures. As a basis for performance predictions and optimizations, we would need faithful models of their behavior, which are, unfortunately, seldom available. In this paper, we present the design and implementation of a tool to construct faithful models of the latency, throughput, and port usage of x86 instructions. To this end, we first discuss common notions of instruction throughput and port usage, and introduce a more precise definition of latency that, in contrast to previous definitions, considers dependencies between different pairs of input and output operands. We then develop novel algorithms to infer the latency, throughput, and port usage based on automatically-generated microbenchmarks that are more accurate and precise than existing work. To facilitate the rapid construction of optimizing compilers and tools for performance prediction, the output of our tool is provided in a machine-readable format. We provide experimental results for processors of all generations of Intel’s Core architecture, i.e., from Nehalem to Coffee Lake, and discuss various cases where the output of our tool differs considerably from prior work. 翻译： 现代的微服务架构是世界上最复杂的人造系统。作为结果，微服务架构越来越难以取预测，解释，更不用说最大化软件在这样的微服务架构上工作的性能。作为性能预测和优化的基础，我们需要关于它们行为的可靠的模型，然而不幸的是这很少有效。 在本文中，我们提出并实现了一个工具来构建关于x86架构下延迟、流量和端口使用的的有效的模型。为此，我们首先讨论了指令流量和端口使用了常用概念，并介绍了关于延迟的更精确的定义，这个定义与之前的定义相对，考虑了不同组合的输入输出之间的依赖关系。然后我们开发了一个新的算法来推导延迟、流量和端口使用的关系，基于自动生成的微服务基准测试系统，该算法与现有工作相比更加准确。 为了实现性能预测上最优化编译器和工具的快速部署，我们的工具的输出是机器可读的格式。我们提供了Intel所有时代处理器的实验结果，并讨论了一些我们的工具与之前工作不同的样例。 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:3:0","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["英语学习"],"content":"Keynote: Developing our Quantum Future 英文 In 1981, Richard Feynman proposed a device called a ‘quantum computer’ to take advantage of the laws of quantum physics to achieve computational speed-ups over classical methods. Quantum computing promises to revolutionize how and what we compute. Over the course of three decades, quantum algorithms have been developed that offer fast solutions to problems in a variety of fields including number theory, optimization, chemistry, physics, and materials science. Quantum devices have also significantly advanced such that components of a scalable quantum computer have been demonstrated; the promise of implementing quantum algorithms is in our near future. I will attempt to explain some of the mysteries of this disruptive, revolutionary computational paradigm and how it will transform our digital age. 翻译 在1981年，理查德弗莱曼提出了一个名为量子计算机的设备，利用量子物理学定律来实现比传统方法更快的计算速度。量子计算有望彻底改变我们的计算方式和计算对象。在过去三十年的研究中，已经开发出的量子算法可以为数论、优化、化学、物理和材料科学等各个领域的问题提供快速解决方案。量子设备也取得了显著的进步，从而证明了可扩展量子计算机的组件的性能。实现量子算法的希望就在我们不久的将来。我将尝试解释这种颠覆性、革命性的计算范例的一些奥秘，以及它如何改变我们的数字时代。 ","date":"2020-04-03","objectID":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/:4:0","tags":["考研"],"title":"复试英语翻译练习","uri":"/posts/20200403_%E5%A4%8D%E8%AF%95%E8%8B%B1%E8%AF%AD%E7%BF%BB%E8%AF%91%E7%BB%83%E4%B9%A0/"},{"categories":["无关随笔"],"content":"在综合了价格等因素后，我选择了华为MatepadPro，这样在不用电脑模拟器的情况下我还可以使用平板进行阅读和书写记录，从综合价格上来说是最划算的，使用寿命预期是5-7年，预期是工作三年之后再换最新的手机。（虽然今年年初亏的一波已经够买一台新手机了，mmp） 在实际使用的时候，我发现安卓平板下的笔记应用并没有苹果下那么丰富，苹果最著名的notability和goodnote组合似乎无法替代。因此我需要花费一些时间寻找比较适合的应用，同时记录下它们的应用场景来供自己进行选择。 会使用如下表格来进行分析： 总体： 背景是否可变 外部是否有标签 手写： 是否支持手写： 是否有框选 存储是矢量还是像素 延迟 快捷操作是否便捷 手写页面是下拉还是无限 手写笔迹、颜色 插入图片： 调节位置 调节大小 是否支持pdf 插入语音： 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出： 是否支持pdf 是否同步 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:0:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"备忘录 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:1:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"页面 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:1:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 备忘录是华为官方应用，可以同时支持文本编辑、图片插入、语音输入（不超过5分钟，会自动识别，不能同时存储多条语音）、手写输入。 我比较喜欢的一点是它的背景是黑色的，缺点是手写时没有框选（虚线框，可以移动和删除内容），而且没有快捷手势来删除，极为不便。手写部分存入的是矢量图，删除的时候一删就是一条线，写的时候需要注意一下。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:1:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：不可变，如上图一样，是黑色。 外部是否有标签：有标签，可以在左上角详情栏中点标签进行分类，可以根据标题进行搜索。 手写： 是否支持手写：支持手写，可以选择只使用主动笔 是否有框选：没有框选，不能移动 存储是矢量还是像素：矢量 延迟：极低，且字不会变形 快捷操作是否便捷：没有手势快捷操作，且删除很不便，必须要点一下橡皮擦进入擦除模式，而且很容易点错。 手写页面是下拉还是无限：下拉，而且不能放大缩小 手写笔迹、颜色：支持铅笔、钢笔、中性笔、划线笔，颜色只能使用预设的七种颜色。 插入图片： 调节位置：长按图片可以移动位置，文字内容不能与图片重复，但手写内容可以覆盖（且只能覆盖） 调节大小：单击可以进行图片编辑，可以修图（亮度、饱和度、裁剪、旋转），但是不能缩放。 是否支持pdf：不能导入pdf文件，哪怕只有一张（可以考虑截图） 插入语音： 时间：5分钟 条数，是否重叠：只能一条，自动接上。 是否会自动翻译，允许保存原音：会自动翻译，同时会保留一条原音。 导出： 是否支持pdf：可以选择打印界面保存为pdf. 是否同步：单机软件，不能同步。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:1:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 紧急情况记录绝对够用，日常书写也还行，但是如果经常需要删改的话会很不舒服，已经提了建议，也不知道会不会改。 总体而言，对手写的支持非常好，书写基本没有延迟，偶尔可能手写笔有问题，会出现过于敏感导致有墨点的情况。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:1:4","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"Nebo for Huawei ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:2:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"页面 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:2:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 Nebo，特色是能够将手写转换为文字，速度还行，准确度不错。（对楷书而言能到95%以上，数字和字母有困难，对行书基本没用，推测是用RNN之类的做的，输入顺序有影响） 这种转换是可以对每一段手写文字进行。 特色是能够进行手写数学计算与图表插入，图表插入只对于插入的内容自动填充颜色，没什么大用处。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:2:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：不可变，白色 外部是否有标签：没有标签，但有笔记集合，可以拖拽来移动。有标题，可以进行搜索 手写： 是否支持手写：支持 是否有框选：没有框选，可以直接转换 存储是矢量还是像素：矢量，按识别的字存储。素描模式是像素，但范围较有限（高二分之三个屏幕） 延迟：没感觉 快捷操作是否便捷：手写部分可以直接涂抹来删除，还可以；有快速换行和切分来代替框选，一般。 手写页面是下拉还是无限：下拉，不能放大。 手写笔迹、颜色：笔迹有五种粗细可选；颜色有默认的九色，可以从调色盘自定义。 插入图片： 调节位置：可以调节位置 调节大小：可以调节大小 是否支持pdf：不支持 插入语音：不支持语音插入 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出： 是否支持pdf：不支持pdf。但是能够导入word、HTML和文本 是否同步：可以同步 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:2:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 能够仔细书写的场景，对保存的信息有要求，需要文字信息时可以使用。 其他时候不推荐，毕竟识别准确率还是不够高，可以切分起来很麻烦。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:2:4","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"Squid 有高级版，但因为需要谷歌应用商店，虽然有vpn，但在中国也太麻烦了，就没几次成功上去过的。普通版也够用，但高级版能插入pdf以及使用其他好东西，所以还是挺不错的。只能使用破解版了。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:3:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 个人之前最喜欢的手写应用，其页面组织很有意思，每一个笔记内有多个页面，每个页面是无限延伸的，可以使用双指按压移动。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:3:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：可变，但只能在格子纸中选择，背景都是白色的，很难受。(官网18年有人提了这个建议，并且有大量跟帖，但在现在它好像也没有做这个功能) 外部是否有标签：可以移动笔记到不同文件夹中，有星标系统 手写： 是否支持手写：支持 是否有框选：有 存储是矢量还是像素：可以进行像素擦除，但要会员。 延迟：很低 快捷操作是否便捷：可以使用单指按压设置功能，我设置了橡皮擦。很便捷，还可以自行调整。 手写页面是下拉还是无限：无限，双指按压可以得到无限页面，页面本身可以对大小进行设置。 手写笔迹、颜色：笔记为4096压感，可以使用预设；颜色有调色盘 插入图片：需要使用框选工具完整框选图片才能进行 调节位置：可以 调节大小：可以 是否支持pdf：高级版能够直接在pdf上做笔记。 插入语音：不能 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出：支持pdf与图片，能够选择导出完成笔记或当前页面 是否支持pdf：支持 是否同步：需要高级版 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:3:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 日常情况绝对够用，可惜高级版国内不能直接购买。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:3:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"OneNote 微软旗下的OneNote，全平台软件，但同步的话因为速度问题，在手写状态下我就没有同步成功过，可能需要vpn。总体来说是非常完美的一款笔记应用。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:4:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 所有你能想到的内容和排版，它都有 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:4:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：可以更改颜色，设置基准线和辅助线，但是颜色只能是预设的，且没有黑色（但绿色已经比白色好很多了） 外部是否有标签：有笔记本界面，可以进行搜索 手写： 是否支持手写：支持，可以无需主动笔 是否有框选：有框选 存储是矢量还是像素：矢量 延迟：有一定延迟，而且写上去的字会略微变形 快捷操作是否便捷：没摸索出快捷操作 手写页面是下拉还是无限：无限 手写笔迹、颜色：笔迹可调，没有压感（应该），颜色预设 插入图片：可以插入各种办公用标签 调节位置：可以 调节大小：可以 是否支持pdf：不支持 插入语音：可以 时间：3分钟单次 条数，是否重叠：可以重叠，准确来说是不能叠加 是否会自动翻译，允许保存原音：不会自动翻译，能保留原音 导出：不能导出 是否支持pdf 是否同步：全平台同步，但是带笔迹文件的同步很慢，我没成功过，不知道是哪方面的网络问题 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:4:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 日常绝对够用，文字场景下的神，手写也还可以。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:4:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"随手写 挺好用的国产笔记应用，各方面功能都有。（推荐使用） ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:5:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 手写很有特色，每次手写可以选择只写一个字，也可以选择涂鸦模式，也可以在键盘部分选择写一行，自由度很高。页面布局上有squid的感觉，可以添加页面。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:5:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：可变，可添加颜色或者插入图片 外部是否有标签：有标签，可以根据标签搜索。可以查看各个页面的修改历史 手写： 是否支持手写：支持。手写有三种实现，手写功能如上图，每次全屏写一个字，自动将其放缩；或者使用涂鸦功能；或者在键盘功能切换到手写部分。 是否有框选：有框选功能，可以选择、移动、复制、放缩等。 存储是矢量还是像素：是以图片形式存在，不能对已有图片进行编辑 延迟：较低 快捷操作是否便捷：使用的是虚拟按键来实现大多数功能，在平板上还好，但是不够便捷，容易按错。另外支持自定义手势，不过我没有尝试。 手写页面是下拉还是无限：下拉式，但可以放缩 手写笔迹、颜色：笔迹可以调整，颜色可以自由选择，但需要设置中文和字母文字分别进行。 插入图片：长按可以进行变动 调节位置：可以调节 调节大小：可以修改 是否支持pdf：不支持 插入语音：左下角可以插入语音 时间：不清楚，需要一直按住录音。 条数，是否重叠：不会重复，条数最大未知 是否会自动翻译，允许保存原音：不会自动翻译，允许保存原音。 导出：可以输出图片、笔记网页等 是否支持pdf：可以使用打印输出pdf 是否同步：似乎不同步 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:5:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 绝大部分情况，非常优秀的国产笔记软件，只是学习成本有点高，需要一定的时间来适应。而且特殊的手写输入有时候也不见得是好事，修改起来比较麻烦，更像是手写输入软件而不是笔记软件。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:5:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"Bamboo Paper 作为一个便签纸来用是很合格的 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:6:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"简介 很好用的草稿纸，开启迅速，功能方便，还有格子 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:6:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变：可以选格子，不能变颜色 外部是否有标签：没有 手写： 是否支持手写：支持，允许被动笔 是否有框选：没有 存储是矢量还是像素：像素级别 延迟：几乎没有 快捷操作是否便捷：长按可以调出调色盘。 手写页面是下拉还是无限：固定，连放大都做不到。 手写笔迹、颜色：只有两种笔能选，每种笔三个笔迹，其他需要购买，而国内买不了。调色板可以自定义。 插入图片：可以插入图片 调节位置：可以 调节大小：可以 是否支持pdf：不行 插入语音：不能插入语音 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出：无法导出，云同步需要google账号 是否支持pdf 是否同步 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:6:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 需要草稿纸或者快速记笔记的时候，因为轻量，速度快，还是很好用的。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:6:3","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"Xodo pdf阅读器，能够做笔记，可以方便地进行pdf上的标注与编辑。 其他无 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:7:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"wps阅读器 同样可以进行标记，会员可以解锁一些高级功能。 功能很全面。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:8:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"有道云笔记 普通的笔记本，支持语音速记，支持markdown格式。 同类型的有印象笔记、石墨文档等，说实话没什么大用处。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:9:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"XMind思维导图 思维导图软件，同类型的还有幕布 挺有用的，适合总结的时候使用。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:10:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"MetaMoji Note Lite 有Pro版的，但是要三十多，没买。 可以做笔记，可以导入pdf，非常方便。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:11:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变： 可以，而且可以从相册中选择 外部是否有标签：没有标签，但是有文件夹 手写： 是否支持手写：支持手写，但是只有五种笔，而且不能更改颜色 是否有框选：有框选，但不是很好用 存储是矢量还是像素：矢量 延迟：还好 快捷操作是否便捷：一般，没发现什么特别的快捷操作 手写页面是下拉还是无限：单页纸，可以调节大小 手写笔迹、颜色：五个笔迹，不能改颜色 插入图片： 调节位置：可以 调节大小：可以 是否支持pdf：支持以页面级别插入pdf 插入语音：不行 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出：可以，但只能以图片形式保存到相册 是否支持pdf：否。 是否同步：可以，但是要钱。只能够云端导入。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:11:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 pdf上的阅读器 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:11:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"Noteshelf Notability的公司做的笔记文件，非常好用。看到的up主推荐视频 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:12:0","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"总结 总体： 背景是否可变： 可以，而且可以从相册中选择 外部是否有标签：没有标签，但是有文件夹 手写： 是否支持手写：支持手写 是否有框选：有框选， 存储是矢量还是像素：矢量 延迟：挺棒 快捷操作是否便捷：一般，没发现什么特别的快捷操作 手写页面是下拉还是无限：单页纸，不能调节大小，但是可以使用模版 手写笔迹、颜色：支持压感，三种笔，八种笔迹+自动划线+两种荧光笔，颜色全部可以调整。 插入图片： 调节位置：可以 调节大小：可以 是否支持pdf：*总体 背景是否可变： 可以，允许从模版库中下载，而且可以从相册中选择 外部是否有标签：没有标签，但是有文件夹 手写： 是否支持手写：支持手写，但是只有五种笔，而且不能更改颜色 是否有框选：有框选，但不是很好用 存储是矢量还是像素：矢量 延迟：还好 快捷操作是否便捷：一般，没发现什么特别的快捷操作 手写页面是下拉还是无限：单页纸，可以放大，但不能调节大小 手写笔迹、颜色：任意修改 插入图片： 调节位置：可以 调节大小：可以 插入语音：可以 时间：任意 条数，是否重叠： 任意 是否会自动翻译，允许保存原音：保存原音 导出：可以，但只能以图片形式保存到相册 是否支持pdf：否。 是否同步：可以，但是要钱。只能够云端导入。 插入语音：不行 时间： 条数，是否重叠： 是否会自动翻译，允许保存原音 导出：可以导出pdf或者图片 是否支持pdf：是 是否同步：可以使用evernote功能，但没用过 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:12:1","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"},{"categories":["无关随笔"],"content":"场景 需要39.9港币，美区打折5美刀。目前用过的最舒服的笔记应用，功能不是最全的，但是足够简洁、方便。更全的话应该是加满插件后的随手写了，但是我个人不喜欢随手写的手写方式。 ","date":"2020-03-31","objectID":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/:12:2","tags":["测评","安卓软件"],"title":"安卓环境下笔记软件总结","uri":"/posts/20200331_%E5%AE%89%E5%8D%93%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6%E6%80%BB%E7%BB%93/"}]