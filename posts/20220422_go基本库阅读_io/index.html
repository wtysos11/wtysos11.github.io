<!DOCTYPE html>
<html lang="zh">

<head>
  <title>
  Go基本库阅读：io库 · 实践出真知
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Timothy Wu">
<meta name="description" content="io相关库 Link to heading 阅读标准库是我大一学haskell时养成的习惯，通过阅读标准库能够更好地掌握语言设计者认为这个语言应该如何使用，从而少走一些弯路。
io相关的操作我一直没怎么弄明白，特别是后面看到HTTP框架里面使用ioutil读取的时候。虽然C&#43;&#43;的底子告诉我这样可以，但是我还是觉得应该一探究竟。
Golang的IO库那么多，我该怎么选?这篇文章比较概要地介绍了go中涉及到io的库：io库、os库、ioutil库、bufio库、bytes库、string库，其实net部分也有涉及，我看看之后能不能写到这个地方
可以进一步阅读的地方或资料：
bytes的buffer，很基本的操作，常见但是涉及到很多inline相关的优化 1.1 io — 基本的 IO 接口 这一章对于io库的叙述比较详尽，可以参考 io的常见用途 Link to heading 我个人学习东西的习惯是比较习惯从应用出发，自己什么时候用到这个东西，这个东西会在哪里被用到，怎么被用到。
说起IO，一般就是以下几种情况
标准输入输出：fmt.Printf，fmt.Scanf 读取文件 package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;io&#34; &#34;os&#34; ) func main() { inputFile, inputError := os.Open(&#34;input.dat&#34;) if inputError != nil { fmt.Printf(&#34;An error occurred on opening the inputfile\n&#34; &#43; &#34;Does the file exist?\n&#34; &#43; &#34;Have you got acces to it?\n&#34;) return // exit the function on error } defer inputFile.">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Go基本库阅读：io库"/>
<meta name="twitter:description" content="io相关库 Link to heading 阅读标准库是我大一学haskell时养成的习惯，通过阅读标准库能够更好地掌握语言设计者认为这个语言应该如何使用，从而少走一些弯路。
io相关的操作我一直没怎么弄明白，特别是后面看到HTTP框架里面使用ioutil读取的时候。虽然C&#43;&#43;的底子告诉我这样可以，但是我还是觉得应该一探究竟。
Golang的IO库那么多，我该怎么选?这篇文章比较概要地介绍了go中涉及到io的库：io库、os库、ioutil库、bufio库、bytes库、string库，其实net部分也有涉及，我看看之后能不能写到这个地方
可以进一步阅读的地方或资料：
bytes的buffer，很基本的操作，常见但是涉及到很多inline相关的优化 1.1 io — 基本的 IO 接口 这一章对于io库的叙述比较详尽，可以参考 io的常见用途 Link to heading 我个人学习东西的习惯是比较习惯从应用出发，自己什么时候用到这个东西，这个东西会在哪里被用到，怎么被用到。
说起IO，一般就是以下几种情况
标准输入输出：fmt.Printf，fmt.Scanf 读取文件 package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;io&#34; &#34;os&#34; ) func main() { inputFile, inputError := os.Open(&#34;input.dat&#34;) if inputError != nil { fmt.Printf(&#34;An error occurred on opening the inputfile\n&#34; &#43; &#34;Does the file exist?\n&#34; &#43; &#34;Have you got acces to it?\n&#34;) return // exit the function on error } defer inputFile."/>

<meta property="og:title" content="Go基本库阅读：io库" />
<meta property="og:description" content="io相关库 Link to heading 阅读标准库是我大一学haskell时养成的习惯，通过阅读标准库能够更好地掌握语言设计者认为这个语言应该如何使用，从而少走一些弯路。
io相关的操作我一直没怎么弄明白，特别是后面看到HTTP框架里面使用ioutil读取的时候。虽然C&#43;&#43;的底子告诉我这样可以，但是我还是觉得应该一探究竟。
Golang的IO库那么多，我该怎么选?这篇文章比较概要地介绍了go中涉及到io的库：io库、os库、ioutil库、bufio库、bytes库、string库，其实net部分也有涉及，我看看之后能不能写到这个地方
可以进一步阅读的地方或资料：
bytes的buffer，很基本的操作，常见但是涉及到很多inline相关的优化 1.1 io — 基本的 IO 接口 这一章对于io库的叙述比较详尽，可以参考 io的常见用途 Link to heading 我个人学习东西的习惯是比较习惯从应用出发，自己什么时候用到这个东西，这个东西会在哪里被用到，怎么被用到。
说起IO，一般就是以下几种情况
标准输入输出：fmt.Printf，fmt.Scanf 读取文件 package main import ( &#34;bufio&#34; &#34;fmt&#34; &#34;io&#34; &#34;os&#34; ) func main() { inputFile, inputError := os.Open(&#34;input.dat&#34;) if inputError != nil { fmt.Printf(&#34;An error occurred on opening the inputfile\n&#34; &#43; &#34;Does the file exist?\n&#34; &#43; &#34;Have you got acces to it?\n&#34;) return // exit the function on error } defer inputFile." />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_io/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-22T12:50:02+08:00" />
<meta property="article:modified_time" content="2022-04-22T12:50:02+08:00" />





<link rel="canonical" href="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_io/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css" integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      实践出真知
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/series/">series</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_io/">
              Go基本库阅读：io库
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-04-22T12:50:02&#43;08:00">
                四月 22, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">Go基础学习</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/go/">计算机/go</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="io相关库">
  io相关库
  <a class="heading-link" href="#io%e7%9b%b8%e5%85%b3%e5%ba%93">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>阅读标准库是我大一学haskell时养成的习惯，通过阅读标准库能够更好地掌握语言设计者认为这个语言应该如何使用，从而少走一些弯路。</p>
<p>io相关的操作我一直没怎么弄明白，特别是后面看到HTTP框架里面使用ioutil读取的时候。虽然C++的底子告诉我这样可以，但是我还是觉得应该一探究竟。</p>
<p><a href="https://juejin.cn/post/6976841033795502093"  class="external-link" target="_blank" rel="noopener">Golang的IO库那么多，我该怎么选?</a>这篇文章比较概要地介绍了go中涉及到io的库：io库、os库、ioutil库、bufio库、bytes库、string库，其实net部分也有涉及，我看看之后能不能写到这个地方</p>
<p>可以进一步阅读的地方或资料：</p>
<ul>
<li>bytes的buffer，很基本的操作，常见但是涉及到很多inline相关的优化</li>
<li><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.1.html"  class="external-link" target="_blank" rel="noopener">1.1 io — 基本的 IO 接口</a>
<ul>
<li>这一章对于io库的叙述比较详尽，可以参考</li>
</ul>
</li>
</ul>
<h1 id="io的常见用途">
  io的常见用途
  <a class="heading-link" href="#io%e7%9a%84%e5%b8%b8%e8%a7%81%e7%94%a8%e9%80%94">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>我个人学习东西的习惯是比较习惯从应用出发，自己什么时候用到这个东西，这个东西会在哪里被用到，怎么被用到。</p>
<p>说起IO，一般就是以下几种情况</p>
<ul>
<li>标准输入输出：fmt.Printf，fmt.Scanf</li>
<li>读取文件</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;bufio&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	inputFile, inputError <span style="color:#ff7b72;font-weight:bold">:=</span> os.<span style="color:#d2a8ff;font-weight:bold">Open</span>(<span style="color:#a5d6ff">&#34;input.dat&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> inputError <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#d2a8ff;font-weight:bold">Printf</span>(<span style="color:#a5d6ff">&#34;An error occurred on opening the inputfile\n&#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a5d6ff">&#34;Does the file exist?\n&#34;</span> <span style="color:#ff7b72;font-weight:bold">+</span>
</span></span><span style="display:flex;"><span>			<span style="color:#a5d6ff">&#34;Have you got acces to it?\n&#34;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#8b949e;font-style:italic">// exit the function on error
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">defer</span> inputFile.<span style="color:#d2a8ff;font-weight:bold">Close</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	inputReader <span style="color:#ff7b72;font-weight:bold">:=</span> bufio.<span style="color:#d2a8ff;font-weight:bold">NewReader</span>(inputFile)
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span>		inputString, readerError <span style="color:#ff7b72;font-weight:bold">:=</span> inputReader.<span style="color:#d2a8ff;font-weight:bold">ReadString</span>(<span style="color:#a5d6ff">&#39;\n&#39;</span>)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> readerError <span style="color:#ff7b72;font-weight:bold">==</span> io.EOF {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#d2a8ff;font-weight:bold">Printf</span>(<span style="color:#a5d6ff">&#34;The input was: %s&#34;</span>, inputString)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>读取网络中body的信息（这个也是我做标准库阅读的初衷）</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//import package
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">import</span> <span style="color:#a5d6ff">&#34;io/ioutil&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//code snippet
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    bodyBytes, err <span style="color:#ff7b72;font-weight:bold">:=</span> ioutil.<span style="color:#d2a8ff;font-weight:bold">ReadAll</span>(resp.Body)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span> <span style="color:#8b949e;font-style:italic">//---------- optioninal ---------------------
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#8b949e;font-style:italic">//handling Errors
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    <span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>        log.<span style="color:#d2a8ff;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#8b949e;font-style:italic">//print result
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>    bodyString <span style="color:#ff7b72;font-weight:bold">:=</span> string(bodyBytes)
</span></span><span style="display:flex;"><span>    log.<span style="color:#d2a8ff;font-weight:bold">Info</span>(bodyString)
</span></span></code></pre></div><h1 id="io库">
  io库
  <a class="heading-link" href="#io%e5%ba%93">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>万变不离其宗，io库就是所有IO读写的核心。</p>
<p>IO中的核心概念是读和写，以此衍生出的概念是EOF（终止）、Seek（游走）、流或管道。基本所有的操作都是为了实现这些概念而做出来的。</p>
<h2 id="基本结构体">
  基本结构体
  <a class="heading-link" href="#%e5%9f%ba%e6%9c%ac%e7%bb%93%e6%9e%84%e4%bd%93">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>最基本的结构体自然是Reader和Writer，基本方法为Read(bytes)和Write(bytes)。下面会详细介绍，但是与一般的想法不太一样，Read是将外部的数据写入到bytes数组中，而Write是将bytes中的数据写入到外部数据源。因此，应该将bytes理解成缓冲区，而数据源则为Reader或Writer自己带的。</p>
<p>与之相对的，WriteTo(Writer)和ReadFrom(Reader)则是相反的，ReadFrom会一直从Reader中读取数据，而WriteTo则会一直向Writer写入数据。</p>
<h3 id="read相关">
  Read相关
  <a class="heading-link" href="#read%e7%9b%b8%e5%85%b3">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Read代表了对数据的读取等操作</p>
<h4 id="reader">
  Reader
  <a class="heading-link" href="#reader">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>其中，Reader实现了Read方法：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">方法从数组p中读取最多len(p)个bytes，返回实际读取的bytes数量n和返回的错误err。Reader不会阻塞去进行等待，如果数据没有准备好（实际数据与len(p)不匹配），它会直接返回
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">实现细节：
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">1. Read方法读取到最后一个bytes是返回n,EOF/nil，之后再调用则应该返回0,EOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">2. 不鼓励在读取到0个bytes后返回nil，除非len(p)==0。一般情况下0和nil不能同时返回，而且它绝不能暗示EOF。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">3. 该方法的实现绝对不能保留数组p
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">调用者：
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">* 调用者应该先处理读到的bytes后，再考虑err的问题，从而将正常的错误与EOF同等对待。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Reader <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d2a8ff;font-weight:bold">Read</span>(p []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Read方法的实现例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// net包中conn有对应的实现，conn的Read依赖于netfd的Read，而后者依赖于bufferedPipe的Read
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 位置：src/net/net_fake.go:186
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (p <span style="color:#ff7b72;font-weight:bold">*</span>bufferedPipe) <span style="color:#d2a8ff;font-weight:bold">Read</span>(b []<span style="color:#ff7b72">byte</span>) (<span style="color:#ff7b72">int</span>, <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	p.mu.<span style="color:#d2a8ff;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">defer</span> p.mu.<span style="color:#d2a8ff;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>  <span style="color:#8b949e;font-style:italic">// 加锁后直接循环
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>  <span style="color:#8b949e;font-style:italic">// 与官方实现说的有点不太一样，Read实际上是可以实现等待的，只是需要自行设置DDL
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">for</span> { 
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> p.closed <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> len(p.buf) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, io.EOF <span style="color:#8b949e;font-style:italic">// 管道关闭，或者缓冲为0时返回。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> !p.rDeadline.<span style="color:#d2a8ff;font-weight:bold">IsZero</span>() { <span style="color:#8b949e;font-style:italic">// 如果存在DDL，则执行对应的逻辑
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			d <span style="color:#ff7b72;font-weight:bold">:=</span> time.<span style="color:#d2a8ff;font-weight:bold">Until</span>(p.rDeadline)
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> d <span style="color:#ff7b72;font-weight:bold">&lt;=</span> <span style="color:#a5d6ff">0</span> { <span style="color:#8b949e;font-style:italic">// DDL到了，则返回对应的信号
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>				<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, syscall.EAGAIN
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			time.<span style="color:#d2a8ff;font-weight:bold">AfterFunc</span>(d, p.rCond.Broadcast) <span style="color:#8b949e;font-style:italic">// 到时间后，BroadCast会唤醒p.rCond中的所有协程
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> len(p.buf) &gt; <span style="color:#a5d6ff">0</span> { <span style="color:#8b949e;font-style:italic">// 缓存区中有数据，则直接弹出
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		p.rCond.<span style="color:#d2a8ff;font-weight:bold">Wait</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	n <span style="color:#ff7b72;font-weight:bold">:=</span> copy(b, p.buf) <span style="color:#8b949e;font-style:italic">// 直接将一个slice的元素拷贝给另外一个slice，n表示实际复制成功的slice元素个数
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	p.buf = p.buf[n:] <span style="color:#8b949e;font-style:italic">// 进行截断，避免重复
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	p.wCond.<span style="color:#d2a8ff;font-weight:bold">Broadcast</span>() <span style="color:#8b949e;font-style:italic">// 唤醒所有的wCond
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">return</span> n, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>PS：如果要进一步了解IO的细节，可以阅读<a href="https://jixiuf.github.io/blog/go_epoll.html/"  class="external-link" target="_blank" rel="noopener">go_epoll</a></p>
<p>IO库的Reader与底层关系太近，bytes中的可能要稍微好一些</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Read的位置为src/bytes/reader.go:39
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// A Reader implements the io.Reader, io.ReaderAt, io.WriterTo, io.Seeker,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// io.ByteScanner, and io.RuneScanner interfaces by reading from
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// a byte slice.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Unlike a Buffer, a Reader is read-only and supports seeking.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// The zero value for Reader operates like a Reader of an empty slice.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">type</span> Reader <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>	s        []<span style="color:#ff7b72">byte</span>
</span></span><span style="display:flex;"><span>	i        <span style="color:#ff7b72">int64</span> <span style="color:#8b949e;font-style:italic">// current reading index
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	prevRune <span style="color:#ff7b72">int</span>   <span style="color:#8b949e;font-style:italic">// index of previous rune; or &lt; 0
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Read implements the io.Reader interface.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (r <span style="color:#ff7b72;font-weight:bold">*</span>Reader) <span style="color:#d2a8ff;font-weight:bold">Read</span>(b []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> r.i <span style="color:#ff7b72;font-weight:bold">&gt;=</span> int64(len(r.s)) { <span style="color:#8b949e;font-style:italic">// 如果当前的index大于所读取的数据数组s，则EOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, io.EOF <span style="color:#8b949e;font-style:italic">// 这里与之前的文档一致，0和nil不同时出现，0应该跟着EOF，除非len(p)==0
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>	r.prevRune = <span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span> <span style="color:#8b949e;font-style:italic">// 这里应该是单纯的用不上
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 简单的使用copy
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	n = copy(b, r.s[r.i:])
</span></span><span style="display:flex;"><span>	r.i <span style="color:#ff7b72;font-weight:bold">+=</span> int64(n)
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="其他reader相关的基本操作">
  其他Reader相关的基本操作
  <a class="heading-link" href="#%e5%85%b6%e4%bb%96reader%e7%9b%b8%e5%85%b3%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>ReadAt和ReadFrom</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">与Read相比，ReadAt会在输入源的index==off的位置开始读取
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">如果n&lt;len(p)，ReadAt必须返回错误来告知为什么没有读取完整。如果数据源可用但长度非len(p)，ReadAt会一直Block到出结果或者err
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">PS: 从前面的网络包实现中可以发现，实际实现中并没有严格遵循这一点
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">与Read不同的另外一点在于，ReadAt的Client要能够同时对同一个输入源进行操作。与之相对，尽管没有明说，但是Read的网络包实现中是加了锁的
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> ReaderAt <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d2a8ff;font-weight:bold">ReadAt</span>(p []<span style="color:#ff7b72">byte</span>, off <span style="color:#ff7b72">int64</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/bytes/reader.go中同样实现了ReadAt的方法
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// ReadAt implements the io.ReaderAt interface.（原注释，我对此的理解是因为要支持并发操作，因此如果对状态进行修改将会产生问题）
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (r <span style="color:#ff7b72;font-weight:bold">*</span>Reader) <span style="color:#d2a8ff;font-weight:bold">ReadAt</span>(b []<span style="color:#ff7b72">byte</span>, off <span style="color:#ff7b72">int64</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// cannot modify state - see io.ReaderAt
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// legal check
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">if</span> off &lt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, errors.<span style="color:#d2a8ff;font-weight:bold">New</span>(<span style="color:#a5d6ff">&#34;bytes.Reader.ReadAt: negative offset&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> off <span style="color:#ff7b72;font-weight:bold">&gt;=</span> int64(len(r.s)) {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, io.EOF
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	n = copy(b, r.s[off:])
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> n &lt; len(b) {
</span></span><span style="display:flex;"><span>		err = io.EOF <span style="color:#8b949e;font-style:italic">// 比Read多的地方，如果n&lt;len(b)时会额外增加这个错误
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">ReadFrom的目标是从Reader中一直读取数据直到读到其他错误或者EOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> ReaderFrom <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d2a8ff;font-weight:bold">ReadFrom</span>(r Reader) (n <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/bytes/buffer.go:197中实现了这一方法，会一直从某个reader中读取数据直到读完为止
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// ReadFrom reads data from r until EOF and appends it to the buffer, growing
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the buffer as needed. The return value n is the number of bytes read. Any
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// error except io.EOF encountered during the read is also returned. If the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (b <span style="color:#ff7b72;font-weight:bold">*</span>Buffer) <span style="color:#d2a8ff;font-weight:bold">ReadFrom</span>(r io.Reader) (n <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	b.lastRead = opInvalid
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span>		i <span style="color:#ff7b72;font-weight:bold">:=</span> b.<span style="color:#d2a8ff;font-weight:bold">grow</span>(MinRead) <span style="color:#8b949e;font-style:italic">// MinRead=512，是单个Read调用的最小的slice size。而grow则会扩展slice从而保证额外的MinRead大小的数据能够被写入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		b.buf = b.buf[:i] <span style="color:#8b949e;font-style:italic">// 确保len正确，从切片中新建切片不会改变cap
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		m, e <span style="color:#ff7b72;font-weight:bold">:=</span> r.<span style="color:#d2a8ff;font-weight:bold">Read</span>(b.buf[i:cap(b.buf)])
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> m &lt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>			panic(errNegativeRead)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// 读到了m个数据。这里体现了一个特点，即Read的err的处理逻辑是先处理数据再处理错误
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		b.buf = b.buf[:i<span style="color:#ff7b72;font-weight:bold">+</span>m]
</span></span><span style="display:flex;"><span>		n <span style="color:#ff7b72;font-weight:bold">+=</span> int64(m)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">==</span> io.EOF {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> n, <span style="color:#79c0ff">nil</span> <span style="color:#8b949e;font-style:italic">// e is EOF, so return nil explicitly
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> n, e
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="延伸reader">
  延伸Reader
  <a class="heading-link" href="#%e5%bb%b6%e4%bc%b8reader">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>主要是SectionReader</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">SectionReawder可以指定读取某一个范围的数据，该范围为从off之后n个点的数据，在读完n个点之后返回EOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> SectionReader <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>	r     ReaderAt
</span></span><span style="display:flex;"><span>	base  <span style="color:#ff7b72">int64</span>
</span></span><span style="display:flex;"><span>	off   <span style="color:#ff7b72">int64</span>
</span></span><span style="display:flex;"><span>	limit <span style="color:#ff7b72">int64</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">NewSectionReader</span>(r ReaderAt, off <span style="color:#ff7b72">int64</span>, n <span style="color:#ff7b72">int64</span>) <span style="color:#ff7b72;font-weight:bold">*</span>SectionReader
</span></span></code></pre></div><p>官方给的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;io&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;log&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	r <span style="color:#ff7b72;font-weight:bold">:=</span> strings.<span style="color:#d2a8ff;font-weight:bold">NewReader</span>(<span style="color:#a5d6ff">&#34;some io.Reader stream to be read\n&#34;</span>)
</span></span><span style="display:flex;"><span>	s <span style="color:#ff7b72;font-weight:bold">:=</span> io.<span style="color:#d2a8ff;font-weight:bold">NewSectionReader</span>(r, <span style="color:#a5d6ff">5</span>, <span style="color:#a5d6ff">17</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	buf <span style="color:#ff7b72;font-weight:bold">:=</span> make([]<span style="color:#ff7b72">byte</span>, <span style="color:#a5d6ff">9</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> _, err <span style="color:#ff7b72;font-weight:bold">:=</span> s.<span style="color:#d2a8ff;font-weight:bold">Read</span>(buf); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>		log.<span style="color:#d2a8ff;font-weight:bold">Fatal</span>(err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#d2a8ff;font-weight:bold">Printf</span>(<span style="color:#a5d6ff">&#34;%s\n&#34;</span>, buf)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="writer">
  Writer
  <a class="heading-link" href="#writer">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="write">
  write
  <a class="heading-link" href="#write">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>Writer则需要实现Write方法</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">与Read方法相对，write方法会从数组p中读取至多len(p)的数据写入到基本数据流中。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">其中实现并不一定要包含p，比如Discard就没有使用到p数组。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">问题：基本数据流该怎么调用？它是结构体的成员之一吗
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Writer <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d2a8ff;font-weight:bold">Write</span>(p []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/bytes/buffer.go
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Write appends the contents of p to the buffer, growing the buffer as
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// needed. The return value n is the length of p; err is always nil. If the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// buffer becomes too large, Write will panic with ErrTooLarge.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (b <span style="color:#ff7b72;font-weight:bold">*</span>Buffer) <span style="color:#d2a8ff;font-weight:bold">Write</span>(p []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	b.lastRead = opInvalid
</span></span><span style="display:flex;"><span>	m, ok <span style="color:#ff7b72;font-weight:bold">:=</span> b.<span style="color:#d2a8ff;font-weight:bold">tryGrowByReslice</span>(len(p))
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> !ok {
</span></span><span style="display:flex;"><span>		m = b.<span style="color:#d2a8ff;font-weight:bold">grow</span>(len(p))
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 直接通过拷贝来实现写入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">return</span> copy(b.buf[m:], p), <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="其他writer相关的基本操作">
  其他Writer相关的基本操作
  <a class="heading-link" href="#%e5%85%b6%e4%bb%96writer%e7%9b%b8%e5%85%b3%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%93%8d%e4%bd%9c">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>主要是WriteAt和WriteTo</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/bytes/buffer.go:249
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// WriteTo writes data to w until the buffer is drained or an error occurs.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// The return value n is the number of bytes written; it always fits into an
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// int, but it is int64 to match the io.WriterTo interface. Any error
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// encountered during the write is also returned.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (b <span style="color:#ff7b72;font-weight:bold">*</span>Buffer) <span style="color:#d2a8ff;font-weight:bold">WriteTo</span>(w io.Writer) (n <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 函数将b.buf的数据写入到w中
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	b.lastRead = opInvalid
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> nBytes <span style="color:#ff7b72;font-weight:bold">:=</span> b.<span style="color:#d2a8ff;font-weight:bold">Len</span>(); nBytes &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		m, e <span style="color:#ff7b72;font-weight:bold">:=</span> w.<span style="color:#d2a8ff;font-weight:bold">Write</span>(b.buf[b.off:]) <span style="color:#8b949e;font-style:italic">// 尝试向w中写入
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> m &gt; nBytes { <span style="color:#8b949e;font-style:italic">// 写入异常
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			panic(<span style="color:#a5d6ff">&#34;bytes.Buffer.WriteTo: invalid Write count&#34;</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		b.off <span style="color:#ff7b72;font-weight:bold">+=</span> m
</span></span><span style="display:flex;"><span>		n = int64(m)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> n, e
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// all bytes should have been written, by definition of
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// Write method in io.Writer
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> m <span style="color:#ff7b72;font-weight:bold">!=</span> nBytes {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> n, io.ErrShortWrite
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// Buffer is now empty; reset.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	b.<span style="color:#d2a8ff;font-weight:bold">Reset</span>()
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 由于采用了if，所以这里使用的是直接对n进行赋值的方法，而不是如ReadFrom一样的循环累加
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">return</span> n, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/os/file.go:200
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// WriteAt writes len(b) bytes to the File starting at byte offset off.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// It returns the number of bytes written and an error, if any.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// WriteAt returns a non-nil error when n != len(b).
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// If file was opened with the O_APPEND flag, WriteAt returns an error.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (f <span style="color:#ff7b72;font-weight:bold">*</span>File) <span style="color:#d2a8ff;font-weight:bold">WriteAt</span>(b []<span style="color:#ff7b72">byte</span>, off <span style="color:#ff7b72">int64</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> f.<span style="color:#d2a8ff;font-weight:bold">checkValid</span>(<span style="color:#a5d6ff">&#34;write&#34;</span>); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, err
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> f.appendMode {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, errWriteAtInAppendMode
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> off &lt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, <span style="color:#ff7b72;font-weight:bold">&amp;</span>PathError{Op: <span style="color:#a5d6ff">&#34;writeat&#34;</span>, Path: f.name, Err: errors.<span style="color:#d2a8ff;font-weight:bold">New</span>(<span style="color:#a5d6ff">&#34;negative offset&#34;</span>)}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> len(b) &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		m, e <span style="color:#ff7b72;font-weight:bold">:=</span> f.<span style="color:#d2a8ff;font-weight:bold">pwrite</span>(b, off)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			err = f.<span style="color:#d2a8ff;font-weight:bold">wrapErr</span>(<span style="color:#a5d6ff">&#34;write&#34;</span>, e)
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		n <span style="color:#ff7b72;font-weight:bold">+=</span> m
</span></span><span style="display:flex;"><span>		b = b[m:]
</span></span><span style="display:flex;"><span>		off <span style="color:#ff7b72;font-weight:bold">+=</span> int64(m)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="seeker">
  Seeker
  <a class="heading-link" href="#seeker">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">Seek方法将下一个Read或者Write的index设置为offset，而这个offset的解释则根据whence进行。
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">SeekStart与开始相关，SeekCurrent与当前相关，SeekEnd与结尾相关
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">Seek返回处理后得到的新的offset以及对应的错误
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Seeker <span style="color:#ff7b72">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#d2a8ff;font-weight:bold">Seek</span>(offset <span style="color:#ff7b72">int64</span>, whence <span style="color:#ff7b72">int</span>) (<span style="color:#ff7b72">int64</span>, <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 实现示范，src/io/io.go
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (s <span style="color:#ff7b72;font-weight:bold">*</span>SectionReader) <span style="color:#d2a8ff;font-weight:bold">Seek</span>(offset <span style="color:#ff7b72">int64</span>, whence <span style="color:#ff7b72">int</span>) (<span style="color:#ff7b72">int64</span>, <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">switch</span> whence {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, errWhence
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> SeekStart:
</span></span><span style="display:flex;"><span>		offset <span style="color:#ff7b72;font-weight:bold">+=</span> s.base
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> SeekCurrent:
</span></span><span style="display:flex;"><span>		offset <span style="color:#ff7b72;font-weight:bold">+=</span> s.off
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> SeekEnd:
</span></span><span style="display:flex;"><span>		offset <span style="color:#ff7b72;font-weight:bold">+=</span> s.limit
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> offset &lt; s.base {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, errOffset
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	s.off = offset
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> offset <span style="color:#ff7b72;font-weight:bold">-</span> s.base, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="管道以及常见函数">
  管道以及常见函数
  <a class="heading-link" href="#%e7%ae%a1%e9%81%93%e4%bb%a5%e5%8f%8a%e5%b8%b8%e8%a7%81%e5%87%bd%e6%95%b0">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>没什么特别的地方，不赘述。详见：<a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.1.html"  class="external-link" target="_blank" rel="noopener">1.1 io — 基本的 IO 接口</a></p>
<p>其中，管道的实现代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/io/pipe.go:199
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">Pipe</span>() (<span style="color:#ff7b72;font-weight:bold">*</span>PipeReader, <span style="color:#ff7b72;font-weight:bold">*</span>PipeWriter) {
</span></span><span style="display:flex;"><span>	p <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72;font-weight:bold">&amp;</span>pipe{
</span></span><span style="display:flex;"><span>		wrCh: make(<span style="color:#ff7b72">chan</span> []<span style="color:#ff7b72">byte</span>), <span style="color:#8b949e;font-style:italic">// write channel
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		rdCh: make(<span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">int</span>), <span style="color:#8b949e;font-style:italic">// read channel
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		done: make(<span style="color:#ff7b72">chan</span> <span style="color:#ff7b72">struct</span>{}), <span style="color:#8b949e;font-style:italic">// done channel
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> <span style="color:#ff7b72;font-weight:bold">&amp;</span>PipeReader{p}, <span style="color:#ff7b72;font-weight:bold">&amp;</span>PipeWriter{p}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (p <span style="color:#ff7b72;font-weight:bold">*</span>pipe) <span style="color:#d2a8ff;font-weight:bold">read</span>(b []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// 从管道中读取到b
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.done: <span style="color:#8b949e;font-style:italic">// 如果完成，则关闭
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, p.<span style="color:#d2a8ff;font-weight:bold">readCloseError</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">default</span>:
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> bw <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.wrCh: <span style="color:#8b949e;font-style:italic">// 从writechannel中读数据
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		nr <span style="color:#ff7b72;font-weight:bold">:=</span> copy(b, bw)
</span></span><span style="display:flex;"><span>		p.rdCh <span style="color:#ff7b72;font-weight:bold">&lt;-</span> nr
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> nr, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.done:
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, p.<span style="color:#d2a8ff;font-weight:bold">readCloseError</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> (p <span style="color:#ff7b72;font-weight:bold">*</span>pipe) <span style="color:#d2a8ff;font-weight:bold">write</span>(b []<span style="color:#ff7b72">byte</span>) (n <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#8b949e;font-style:italic">// 从b中写入到管道
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">select</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.done:
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, p.<span style="color:#d2a8ff;font-weight:bold">writeCloseError</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">default</span>:
</span></span><span style="display:flex;"><span>		p.wrMu.<span style="color:#d2a8ff;font-weight:bold">Lock</span>()
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">defer</span> p.wrMu.<span style="color:#d2a8ff;font-weight:bold">Unlock</span>()
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> once <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#79c0ff">true</span>; once <span style="color:#ff7b72;font-weight:bold">||</span> len(b) &gt; <span style="color:#a5d6ff">0</span>; once = <span style="color:#79c0ff">false</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">select</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">case</span> p.wrCh <span style="color:#ff7b72;font-weight:bold">&lt;-</span> b:
</span></span><span style="display:flex;"><span>			nw <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.rdCh
</span></span><span style="display:flex;"><span>			b = b[nw:]
</span></span><span style="display:flex;"><span>			n <span style="color:#ff7b72;font-weight:bold">+=</span> nw
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">case</span> <span style="color:#ff7b72;font-weight:bold">&lt;-</span>p.done:
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> n, p.<span style="color:#d2a8ff;font-weight:bold">writeCloseError</span>()
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> n, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Copy的实现代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Copy copies from src to dst until either EOF is reached
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// on src or an error occurs. It returns the number of bytes
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// copied and the first error encountered while copying, if any.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// A successful Copy returns err == nil, not err == EOF.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Because Copy is defined to read from src until EOF, it does
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// not treat an EOF from Read as an error to be reported.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// If src implements the WriterTo interface,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the copy is implemented by calling src.WriteTo(dst).
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Otherwise, if dst implements the ReaderFrom interface,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the copy is implemented by calling dst.ReadFrom(src).
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">Copy</span>(dst Writer, src Reader) (written <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> <span style="color:#d2a8ff;font-weight:bold">copyBuffer</span>(dst, src, <span style="color:#79c0ff">nil</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// CopyBuffer is identical to Copy except that it stages through the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// provided buffer (if one is required) rather than allocating a
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// temporary one. If buf is nil, one is allocated; otherwise if it has
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// zero length, CopyBuffer panics.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// If either src implements WriterTo or dst implements ReaderFrom,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// buf will not be used to perform the copy.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">CopyBuffer</span>(dst Writer, src Reader, buf []<span style="color:#ff7b72">byte</span>) (written <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> buf <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> len(buf) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#a5d6ff">&#34;empty buffer in CopyBuffer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> <span style="color:#d2a8ff;font-weight:bold">copyBuffer</span>(dst, src, buf)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// copyBuffer is the actual implementation of Copy and CopyBuffer.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// if buf is nil, one is allocated.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">copyBuffer</span>(dst Writer, src Reader, buf []<span style="color:#ff7b72">byte</span>) (written <span style="color:#ff7b72">int64</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// If the reader has a WriteTo method, use it to do the copy.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#8b949e;font-style:italic">// Avoids an allocation and a copy.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">if</span> wt, ok <span style="color:#ff7b72;font-weight:bold">:=</span> src.(WriterTo); ok {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> wt.<span style="color:#d2a8ff;font-weight:bold">WriteTo</span>(dst)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// Similarly, if the writer has a ReadFrom method, use it to do the copy.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">if</span> rt, ok <span style="color:#ff7b72;font-weight:bold">:=</span> dst.(ReaderFrom); ok {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> rt.<span style="color:#d2a8ff;font-weight:bold">ReadFrom</span>(src)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> buf <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>		size <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">32</span> <span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#a5d6ff">1024</span>
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> l, ok <span style="color:#ff7b72;font-weight:bold">:=</span> src.(<span style="color:#ff7b72;font-weight:bold">*</span>LimitedReader); ok <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> int64(size) &gt; l.N {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> l.N &lt; <span style="color:#a5d6ff">1</span> {
</span></span><span style="display:flex;"><span>				size = <span style="color:#a5d6ff">1</span>
</span></span><span style="display:flex;"><span>			} <span style="color:#ff7b72">else</span> {
</span></span><span style="display:flex;"><span>				size = int(l.N)
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		buf = make([]<span style="color:#ff7b72">byte</span>, size)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span>		nr, er <span style="color:#ff7b72;font-weight:bold">:=</span> src.<span style="color:#d2a8ff;font-weight:bold">Read</span>(buf)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> nr &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>			nw, ew <span style="color:#ff7b72;font-weight:bold">:=</span> dst.<span style="color:#d2a8ff;font-weight:bold">Write</span>(buf[<span style="color:#a5d6ff">0</span>:nr])
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> nw &lt; <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:bold">||</span> nr &lt; nw {
</span></span><span style="display:flex;"><span>				nw = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">if</span> ew <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>					ew = errInvalidWrite
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			written <span style="color:#ff7b72;font-weight:bold">+=</span> int64(nw)
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> ew <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>				err = ew
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> nr <span style="color:#ff7b72;font-weight:bold">!=</span> nw {
</span></span><span style="display:flex;"><span>				err = ErrShortWrite
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> er <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> er <span style="color:#ff7b72;font-weight:bold">!=</span> EOF {
</span></span><span style="display:flex;"><span>				err = er
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> written, err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h1 id="ioutil库">
  ioutil库
  <a class="heading-link" href="#ioutil%e5%ba%93">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.2.html"  class="external-link" target="_blank" rel="noopener">ioutil-gitbook</a></p>
<p>而在Go1.16中，对应的函数被io或os库的函数实现，不应该调用ioutil</p>
<p>比较重要的几个函数</p>
<h2 id="realall">
  RealAll
  <a class="heading-link" href="#realall">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><a href="https://juejin.cn/post/6977640348679929886"  class="external-link" target="_blank" rel="noopener">golang中的ioutil.ReadAll vs io.Copy</a></p>

      </div>


      <footer>
        


        
        
        
        
        

        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2020 -
    
    2024
     Timothy Wu 
    ·
    
     <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
