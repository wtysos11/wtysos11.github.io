<!DOCTYPE html>
<html lang="zh">

<head>
  <title>
  Go基本库阅读：bufio库 · 实践出真知
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Timothy Wu">
<meta name="description" content="bufio Link to heading 这个库是io库的实现，如果需要自行实现io库可以看一下这个库中Read和Write相关函数的实现。
本质上相当于io加上缓冲区。
参考：
1.4 bufio库 常见的表述，包括函数功能解释参考此文，本文不再赘述 源代码 代码 Reader Link to heading bufio的Reader本质上是io.Reader的wrap，只是多了一个缓冲区并进行了一些对应的实现
type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions 其中r代表着缓冲区的开头，w代表着缓冲区的末尾 err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid } 初始化函数，下列函数可以初始化并得到一个新的Reader">
<meta name="keywords" content="blog,developer,personal">

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="Go基本库阅读：bufio库"/>
<meta name="twitter:description" content="bufio Link to heading 这个库是io库的实现，如果需要自行实现io库可以看一下这个库中Read和Write相关函数的实现。
本质上相当于io加上缓冲区。
参考：
1.4 bufio库 常见的表述，包括函数功能解释参考此文，本文不再赘述 源代码 代码 Reader Link to heading bufio的Reader本质上是io.Reader的wrap，只是多了一个缓冲区并进行了一些对应的实现
type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions 其中r代表着缓冲区的开头，w代表着缓冲区的末尾 err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid } 初始化函数，下列函数可以初始化并得到一个新的Reader"/>

<meta property="og:title" content="Go基本库阅读：bufio库" />
<meta property="og:description" content="bufio Link to heading 这个库是io库的实现，如果需要自行实现io库可以看一下这个库中Read和Write相关函数的实现。
本质上相当于io加上缓冲区。
参考：
1.4 bufio库 常见的表述，包括函数功能解释参考此文，本文不再赘述 源代码 代码 Reader Link to heading bufio的Reader本质上是io.Reader的wrap，只是多了一个缓冲区并进行了一些对应的实现
type Reader struct { buf []byte rd io.Reader // reader provided by the client r, w int // buf read and write positions 其中r代表着缓冲区的开头，w代表着缓冲区的末尾 err error lastByte int // last byte read for UnreadByte; -1 means invalid lastRuneSize int // size of last rune read for UnreadRune; -1 means invalid } 初始化函数，下列函数可以初始化并得到一个新的Reader" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_bufio/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-22T12:50:02+08:00" />
<meta property="article:modified_time" content="2022-04-22T12:50:02+08:00" />





<link rel="canonical" href="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_bufio/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.min.577e3c5ead537873430da16f0964b754a120fd87c4e2203a00686e7c75b51378.css" integrity="sha256-V348Xq1TeHNDDaFvCWS3VKEg/YfE4iA6AGhufHW1E3g=" crossorigin="anonymous" media="screen" />






  
    
    
    <link rel="stylesheet" href="/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css" integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin="anonymous" media="screen" />
  



 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">









</head>






<body class="preload-transitions colorscheme-auto">
  
<div class="float-container">
    <a id="dark-mode-toggle" class="colorscheme-toggle">
        <i class="fa-solid fa-adjust fa-fw" aria-hidden="true"></i>
    </a>
</div>


  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="/">
      实践出真知
    </a>
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/posts/">Blog</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/tags/">Tags</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/categories/">Categories</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/series/">series</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://wtysos11.github.io/posts/20220422_go%E5%9F%BA%E6%9C%AC%E5%BA%93%E9%98%85%E8%AF%BB_bufio/">
              Go基本库阅读：bufio库
            </a>
          </h1>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2022-04-22T12:50:02&#43;08:00">
                四月 22, 2022
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              
            </span>
          </div>
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">Go基础学习</a></div>

          <div class="tags">
  <i class="fa-solid fa-tag" aria-hidden="true"></i>
    <span class="tag">
      <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/go/">计算机/go</a>
    </span></div>

        </div>
      </header>

      <div class="post-content">
        
        <h1 id="bufio">
  bufio
  <a class="heading-link" href="#bufio">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h1>
<p>这个库是io库的实现，如果需要自行实现io库可以看一下这个库中Read和Write相关函数的实现。</p>
<p>本质上相当于io加上缓冲区。</p>
<p>参考：</p>
<ul>
<li><a href="https://books.studygolang.com/The-Golang-Standard-Library-by-Example/chapter01/01.4.html"  class="external-link" target="_blank" rel="noopener">1.4 bufio库</a>
<ul>
<li>常见的表述，包括函数功能解释参考此文，本文不再赘述</li>
</ul>
</li>
<li><a href="https://cs.opensource.google/go/go/&#43;/refs/tags/go1.18.1:src/bufio/bufio.go;l=207"  class="external-link" target="_blank" rel="noopener">源代码</a>
<ul>
<li>代码</li>
</ul>
</li>
</ul>
<h2 id="reader">
  Reader
  <a class="heading-link" href="#reader">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>bufio的Reader本质上是io.Reader的wrap，只是多了一个缓冲区并进行了一些对应的实现</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">type</span> Reader <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>	buf          []<span style="color:#ff7b72">byte</span>
</span></span><span style="display:flex;"><span>	rd           io.Reader <span style="color:#8b949e;font-style:italic">// reader provided by the client
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	r, w         <span style="color:#ff7b72">int</span>       <span style="color:#8b949e;font-style:italic">// buf read and write positions 其中r代表着缓冲区的开头，w代表着缓冲区的末尾
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	err          <span style="color:#ff7b72">error</span>
</span></span><span style="display:flex;"><span>	lastByte     <span style="color:#ff7b72">int</span> <span style="color:#8b949e;font-style:italic">// last byte read for UnreadByte; -1 means invalid
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	lastRuneSize <span style="color:#ff7b72">int</span> <span style="color:#8b949e;font-style:italic">// size of last rune read for UnreadRune; -1 means invalid
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><p>初始化函数，下列函数可以初始化并得到一个新的Reader</p>
<ul>
<li>NewReaderSize：根据给定的ReaderSize申请缓冲区</li>
<li>NewReader：根据默认的ReaderSize申请缓冲区</li>
<li>Reset：重置各项参数，如果本身是nil则用默认值申请缓冲区</li>
</ul>
<p>常用到的工具函数：</p>
<ul>
<li>fill，从rd中读取chunk，填充缓冲区。总是会尝试写满缓冲区，并且每次调用前会先整理缓冲区。</li>
</ul>
<p>读取系列</p>
<ul>
<li>Read，如果缓冲区无数据则直接调用io.Reader.Read；如果缓冲区有数据，则将缓冲区数据写入到数组中。</li>
<li>Peek，读取n个字节而不让缓冲区前进（表现在代码中则是b.r不变）。会反复调用fill直到缓冲区满或者缓冲区中的有效元素达到指定的大小，很有bufio特色的函数，只有在有缓冲的情况下才能实现的功能。</li>
<li>ReadSlice，读取到delimiter为止</li>
<li>ReadByte，读取下一个字节的数据</li>
<li>ReadLine，本质上是ReadSlice(’\n’)</li>
</ul>
<p>ReadBytes和ReadSlice的区别：</p>
<ul>
<li>ReadSlice返回的对象是Reader中的buffer，因此可能会在下一次读的时候失效；在代码中可以比较清楚的看到返回值line直接就是b.buf。</li>
<li>ReadBytes则进行了复制，对返回得到的full和frag进行了对应的复制，拷贝到新的数组上
<ul>
<li>但是ReadBytes本质上是调用了ReadSlice进行的，核心代码如下：</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// collectFragments reads until the first occurrence of delim in the input. It
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// returns (slice of full buffers, remaining bytes before delim, total number
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// of bytes in the combined first two elements, error).
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// The complete result is equal to
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// `bytes.Join(append(fullBuffers, finalFragment), nil)`, which has a
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// length of `totalLen`. The result is structured in this way to allow callers
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// to minimize allocations and copies.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (b <span style="color:#ff7b72;font-weight:bold">*</span>Reader) <span style="color:#d2a8ff;font-weight:bold">collectFragments</span>(delim <span style="color:#ff7b72">byte</span>) (fullBuffers [][]<span style="color:#ff7b72">byte</span>, finalFragment []<span style="color:#ff7b72">byte</span>, totalLen <span style="color:#ff7b72">int</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">var</span> frag []<span style="color:#ff7b72">byte</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// Use ReadSlice to look for delim, accumulating full buffers.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">var</span> e <span style="color:#ff7b72">error</span>
</span></span><span style="display:flex;"><span>		frag, e = b.<span style="color:#d2a8ff;font-weight:bold">ReadSlice</span>(delim)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">nil</span> { <span style="color:#8b949e;font-style:italic">// got final fragment
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">if</span> e <span style="color:#ff7b72;font-weight:bold">!=</span> ErrBufferFull { <span style="color:#8b949e;font-style:italic">// unexpected error
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			err = e
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// Make a copy of the buffer.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		buf <span style="color:#ff7b72;font-weight:bold">:=</span> make([]<span style="color:#ff7b72">byte</span>, len(frag))
</span></span><span style="display:flex;"><span>		copy(buf, frag)
</span></span><span style="display:flex;"><span>		fullBuffers = append(fullBuffers, buf)
</span></span><span style="display:flex;"><span>		totalLen <span style="color:#ff7b72;font-weight:bold">+=</span> len(buf)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	totalLen <span style="color:#ff7b72;font-weight:bold">+=</span> len(frag)
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> fullBuffers, frag, totalLen, err
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="writer">
  Writer
  <a class="heading-link" href="#writer">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>类似，费事写了</p>
<h2 id="scanner">
  Scanner
  <a class="heading-link" href="#scanner">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p><a href="https://zhuanlan.zhihu.com/p/37673679"  class="external-link" target="_blank" rel="noopener">Scanner-知乎</a></p>
<p>Scanner专门使用了一个文件src/bufio/scan.go来实现，结构体定义如下。简单来说，Scan是为了分词功能而设计的，可以将流式的输入切分成多个token。对于非流式的输入，使用strings或bytes中的Split会更简单一些。</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scanner provides a convenient interface for reading data such as
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// a file of newline-delimited lines of text. Successive calls to
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the Scan method will step through the &#39;tokens&#39; of a file, skipping
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the bytes between the tokens. The specification of a token is
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// defined by a split function of type SplitFunc; the default split
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// function breaks the input into lines with line termination stripped. Split
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// functions are defined in this package for scanning a file into
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// lines, bytes, UTF-8-encoded runes, and space-delimited words. The
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// client may instead provide a custom split function.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scanning stops unrecoverably at EOF, the first I/O error, or a token too
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// large to fit in the buffer. When a scan stops, the reader may have
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// advanced arbitrarily far past the last token. Programs that need more
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// control over error handling or large tokens, or must run sequential scans
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// on a reader, should use bufio.Reader instead.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">type</span> Scanner <span style="color:#ff7b72">struct</span> {
</span></span><span style="display:flex;"><span>	r            io.Reader <span style="color:#8b949e;font-style:italic">// The reader provided by the client.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	split        SplitFunc <span style="color:#8b949e;font-style:italic">// The function to split the tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	maxTokenSize <span style="color:#ff7b72">int</span>       <span style="color:#8b949e;font-style:italic">// Maximum size of a token; modified by tests.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	token        []<span style="color:#ff7b72">byte</span>    <span style="color:#8b949e;font-style:italic">// Last token returned by split. 得到的token，Text或Bytes方法实际上返回的就是这个值
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	buf          []<span style="color:#ff7b72">byte</span>    <span style="color:#8b949e;font-style:italic">// Buffer used as argument to split.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	start        <span style="color:#ff7b72">int</span>       <span style="color:#8b949e;font-style:italic">// First non-processed byte in buf.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	end          <span style="color:#ff7b72">int</span>       <span style="color:#8b949e;font-style:italic">// End of data in buf.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	err          <span style="color:#ff7b72">error</span>     <span style="color:#8b949e;font-style:italic">// Sticky error.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	empties      <span style="color:#ff7b72">int</span>       <span style="color:#8b949e;font-style:italic">// Count of successive empty tokens.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	scanCalled   <span style="color:#ff7b72">bool</span>      <span style="color:#8b949e;font-style:italic">// Scan has been called; buffer is in use.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	done         <span style="color:#ff7b72">bool</span>      <span style="color:#8b949e;font-style:italic">// Scan has finished.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>}
</span></span></code></pre></div><p>其中比较关键的几个成员是split、maxTokenSize、token、buf等</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// SplitFunc is the signature of the split function used to tokenize the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// input. The arguments are an initial substring of the remaining unprocessed
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// data and a flag, atEOF, that reports whether the Reader has no more data
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// to give. The return values are the number of bytes to advance the input
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// and the next token to return to the user, if any, plus an error, if any.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scanning stops if the function returns an error, in which case some of
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the input may be discarded. If that error is ErrFinalToken, scanning
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// stops with no error.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Otherwise, the Scanner advances the input. If the token is not nil,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// the Scanner returns it to the user. If the token is nil, the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scanner reads more data and continues scanning; if there is no more
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// data--if atEOF was true--the Scanner returns. If the data does not
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// yet hold a complete token, for instance if it has no newline while
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// scanning lines, a SplitFunc can return (0, nil, nil) to signal the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scanner to read more data into the slice and try again with a
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// longer slice starting at the same point in the input.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">//
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// The function is never called with an empty data slice unless atEOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// is true. If atEOF is true, however, data may be non-empty and,
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// as always, holds unprocessed text.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">type</span> SplitFunc <span style="color:#ff7b72">func</span>(data []<span style="color:#ff7b72">byte</span>, atEOF <span style="color:#ff7b72">bool</span>) (advance <span style="color:#ff7b72">int</span>, token []<span style="color:#ff7b72">byte</span>, err <span style="color:#ff7b72">error</span>)
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 翻译一下，data是需要分词的数据源，atEOF表明后面是否还有数据（当前是否为EOF）
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 输出的advance为读取的数据总量，token为得到的分词，err为错误系信息
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 默认使用的SplitFunc是SplitLines
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// ScanLines is a split function for a Scanner that returns each line of
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// text, stripped of any trailing end-of-line marker. The returned line may
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// be empty. The end-of-line marker is one optional carriage return followed
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// by one mandatory newline. In regular expression notation, it is `\r?\n`.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// The last non-empty line of input will be returned even if it has no
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// newline.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">ScanLines</span>(data []<span style="color:#ff7b72">byte</span>, atEOF <span style="color:#ff7b72">bool</span>) (advance <span style="color:#ff7b72">int</span>, token []<span style="color:#ff7b72">byte</span>, err <span style="color:#ff7b72">error</span>) {
</span></span><span style="display:flex;"><span>  <span style="color:#8b949e;font-style:italic">// 如果达到了EOF而且没有需要读写的数据，则直接返回0
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">if</span> atEOF <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> len(data) <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, <span style="color:#79c0ff">nil</span>, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> i <span style="color:#ff7b72;font-weight:bold">:=</span> bytes.<span style="color:#d2a8ff;font-weight:bold">IndexByte</span>(data, <span style="color:#a5d6ff">&#39;\n&#39;</span>); i <span style="color:#ff7b72;font-weight:bold">&gt;=</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// We have a full newline-terminated line.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">return</span> i <span style="color:#ff7b72;font-weight:bold">+</span> <span style="color:#a5d6ff">1</span>, <span style="color:#d2a8ff;font-weight:bold">dropCR</span>(data[<span style="color:#a5d6ff">0</span>:i]), <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// If we&#39;re at EOF, we have a final, non-terminated line. Return it.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">if</span> atEOF {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> len(data), <span style="color:#d2a8ff;font-weight:bold">dropCR</span>(data), <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// Request more data.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">return</span> <span style="color:#a5d6ff">0</span>, <span style="color:#79c0ff">nil</span>, <span style="color:#79c0ff">nil</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// dropCR drops a terminal \r from the data.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">dropCR</span>(data []<span style="color:#ff7b72">byte</span>) []<span style="color:#ff7b72">byte</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> len(data) &gt; <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> data[len(data)<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>] <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">&#39;\r&#39;</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> data[<span style="color:#a5d6ff">0</span> : len(data)<span style="color:#ff7b72;font-weight:bold">-</span><span style="color:#a5d6ff">1</span>]
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> data
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="使用">
  使用
  <a class="heading-link" href="#%e4%bd%bf%e7%94%a8">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<p>简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#ff7b72">package</span> main
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">import</span> (
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;bufio&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;os&#34;</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a5d6ff">&#34;strings&#34;</span>
</span></span><span style="display:flex;"><span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff7b72">func</span> <span style="color:#d2a8ff;font-weight:bold">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">const</span> input = <span style="color:#a5d6ff">&#34;This is The Golang Standard Library.\nWelcome you!&#34;</span>
</span></span><span style="display:flex;"><span>	scanner <span style="color:#ff7b72;font-weight:bold">:=</span> bufio.<span style="color:#d2a8ff;font-weight:bold">NewScanner</span>(strings.<span style="color:#d2a8ff;font-weight:bold">NewReader</span>(input))
</span></span><span style="display:flex;"><span>	scanner.<span style="color:#d2a8ff;font-weight:bold">Split</span>(bufio.ScanWords)
</span></span><span style="display:flex;"><span>	count <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">for</span> scanner.<span style="color:#d2a8ff;font-weight:bold">Scan</span>() {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#d2a8ff;font-weight:bold">Println</span>(scanner.<span style="color:#d2a8ff;font-weight:bold">Text</span>())
</span></span><span style="display:flex;"><span>		count<span style="color:#ff7b72;font-weight:bold">++</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">:=</span> scanner.<span style="color:#d2a8ff;font-weight:bold">Err</span>(); err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>		fmt.<span style="color:#d2a8ff;font-weight:bold">Fprintln</span>(os.Stderr, <span style="color:#a5d6ff">&#34;reading input:&#34;</span>, err)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	fmt.<span style="color:#d2a8ff;font-weight:bold">Println</span>(count)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>使用NewScanner等方法可以初始化Scanner</li>
<li>使用Split等方法可以改变其属性</li>
<li>scanner.Scan如同Next一样，如果有数据（token或残留数据）则返回true，并且结果可以通过scanner.Text()或者scanner.Bytes()等拿到</li>
</ul>
<h3 id="实现细节">
  实现细节
  <a class="heading-link" href="#%e5%ae%9e%e7%8e%b0%e7%bb%86%e8%8a%82">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Scan函数是核心</p>
<div class="highlight"><pre tabindex="0" style="color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// src/bufio/scan.go:136
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 返回是否完成，false为已经结束，true为未结束
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scan advances the Scanner to the next token, which will then be
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// available through the Bytes or Text method. It returns false when the
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// scan stops, either by reaching the end of the input or an error.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// After Scan returns false, the Err method will return any error that
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// occurred during scanning, except that if it was io.EOF, Err
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// will return nil.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// Scan panics if the split function returns too many empty
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// tokens without advancing the input. This is a common error mode for
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// scanners.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (s <span style="color:#ff7b72;font-weight:bold">*</span>Scanner) <span style="color:#d2a8ff;font-weight:bold">Scan</span>() <span style="color:#ff7b72">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> s.done { <span style="color:#8b949e;font-style:italic">// 如果已经完成，则返回false
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	s.scanCalled = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>	<span style="color:#8b949e;font-style:italic">// Loop until we have a token.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>	<span style="color:#ff7b72">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// See if we can get a token with what we already have.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// If we&#39;ve run out of data but have an error, give the split function
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// a chance to recover any remaining, possibly empty token.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> s.end &gt; s.start <span style="color:#ff7b72;font-weight:bold">||</span> s.err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			advance, token, err <span style="color:#ff7b72;font-weight:bold">:=</span> s.<span style="color:#d2a8ff;font-weight:bold">split</span>(s.buf[s.start:s.end], s.err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span>)<span style="color:#8b949e;font-style:italic">//如果s.err!=nil时为EOF
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			<span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">==</span> ErrFinalToken {
</span></span><span style="display:flex;"><span>					s.token = token
</span></span><span style="display:flex;"><span>					s.done = <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>					<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(err)
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> !s.<span style="color:#d2a8ff;font-weight:bold">advance</span>(advance) {
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			s.token = token <span style="color:#8b949e;font-style:italic">// 注册得到的token
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			<span style="color:#ff7b72">if</span> token <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">if</span> s.err <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#79c0ff">nil</span> <span style="color:#ff7b72;font-weight:bold">||</span> advance &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>					s.empties = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>				} <span style="color:#ff7b72">else</span> { <span style="color:#8b949e;font-style:italic">// token !=nil, s.err!=nil &amp;&amp; advance&lt;=0 这个条件说明splitFunc实现的有问题
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>					<span style="color:#8b949e;font-style:italic">// Returning tokens not advancing input at EOF.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>					s.empties<span style="color:#ff7b72;font-weight:bold">++</span>
</span></span><span style="display:flex;"><span>					<span style="color:#ff7b72">if</span> s.empties &gt; maxConsecutiveEmptyReads {
</span></span><span style="display:flex;"><span>						panic(<span style="color:#a5d6ff">&#34;bufio.Scan: too many empty tokens without progressing&#34;</span>)
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#8b949e;font-style:italic">// 后面的全部为s.end == s.start &amp;&amp; s.err == nil，或者s.token==nil
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// We cannot generate a token with what we are holding.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// If we&#39;ve already hit EOF or an I/O error, we are done.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> s.err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#8b949e;font-style:italic">// Shut it down.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			s.start = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>			s.end = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// Must read more data.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// 尝试读取更多的数据来继续Scan
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// First, shift data to beginning of buffer if there&#39;s lots of empty space
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// or space is needed.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> s.start &gt; <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:bold">&amp;&amp;</span> (s.end <span style="color:#ff7b72;font-weight:bold">==</span> len(s.buf) <span style="color:#ff7b72;font-weight:bold">||</span> s.start &gt; len(s.buf)<span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#a5d6ff">2</span>) {
</span></span><span style="display:flex;"><span>			copy(s.buf, s.buf[s.start:s.end])
</span></span><span style="display:flex;"><span>			s.end <span style="color:#ff7b72;font-weight:bold">-=</span> s.start
</span></span><span style="display:flex;"><span>			s.start = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// Is the buffer full? If so, resize.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">if</span> s.end <span style="color:#ff7b72;font-weight:bold">==</span> len(s.buf) {
</span></span><span style="display:flex;"><span>			<span style="color:#8b949e;font-style:italic">// Guarantee no overflow in the multiplication below.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>			<span style="color:#ff7b72">const</span> maxInt = int(^uint(<span style="color:#a5d6ff">0</span>) <span style="color:#ff7b72;font-weight:bold">&gt;&gt;</span> <span style="color:#a5d6ff">1</span>)
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> len(s.buf) <span style="color:#ff7b72;font-weight:bold">&gt;=</span> s.maxTokenSize <span style="color:#ff7b72;font-weight:bold">||</span> len(s.buf) &gt; maxInt<span style="color:#ff7b72;font-weight:bold">/</span><span style="color:#a5d6ff">2</span> {
</span></span><span style="display:flex;"><span>				s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(ErrTooLong)
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			newSize <span style="color:#ff7b72;font-weight:bold">:=</span> len(s.buf) <span style="color:#ff7b72;font-weight:bold">*</span> <span style="color:#a5d6ff">2</span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> newSize <span style="color:#ff7b72;font-weight:bold">==</span> <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>				newSize = startBufSize
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> newSize &gt; s.maxTokenSize {
</span></span><span style="display:flex;"><span>				newSize = s.maxTokenSize
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			newBuf <span style="color:#ff7b72;font-weight:bold">:=</span> make([]<span style="color:#ff7b72">byte</span>, newSize)
</span></span><span style="display:flex;"><span>			copy(newBuf, s.buf[s.start:s.end])
</span></span><span style="display:flex;"><span>			s.buf = newBuf
</span></span><span style="display:flex;"><span>			s.end <span style="color:#ff7b72;font-weight:bold">-=</span> s.start
</span></span><span style="display:flex;"><span>			s.start = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#8b949e;font-style:italic">// Finally we can read some input. Make sure we don&#39;t get stuck with
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// a misbehaving Reader. Officially we don&#39;t need to do this, but let&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#8b949e;font-style:italic">// be extra careful: Scanner is for safe, simple jobs.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span>		<span style="color:#ff7b72">for</span> loop <span style="color:#ff7b72;font-weight:bold">:=</span> <span style="color:#a5d6ff">0</span>; ; {
</span></span><span style="display:flex;"><span>			n, err <span style="color:#ff7b72;font-weight:bold">:=</span> s.r.<span style="color:#d2a8ff;font-weight:bold">Read</span>(s.buf[s.end:len(s.buf)])
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> n &lt; <span style="color:#a5d6ff">0</span> <span style="color:#ff7b72;font-weight:bold">||</span> len(s.buf)<span style="color:#ff7b72;font-weight:bold">-</span>s.end &lt; n {
</span></span><span style="display:flex;"><span>				s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(ErrBadReadCount)
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			s.end <span style="color:#ff7b72;font-weight:bold">+=</span> n
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> err <span style="color:#ff7b72;font-weight:bold">!=</span> <span style="color:#79c0ff">nil</span> {
</span></span><span style="display:flex;"><span>				s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(err)
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> n &gt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>				s.empties = <span style="color:#a5d6ff">0</span>
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>			loop<span style="color:#ff7b72;font-weight:bold">++</span>
</span></span><span style="display:flex;"><span>			<span style="color:#ff7b72">if</span> loop &gt; maxConsecutiveEmptyReads {
</span></span><span style="display:flex;"><span>				s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(io.ErrNoProgress)
</span></span><span style="display:flex;"><span>				<span style="color:#ff7b72">break</span>
</span></span><span style="display:flex;"><span>			}
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// advance consumes n bytes of the buffer. It reports whether the advance was legal.
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic">// 检查的同时会修改s.start
</span></span></span><span style="display:flex;"><span><span style="color:#8b949e;font-style:italic"></span><span style="color:#ff7b72">func</span> (s <span style="color:#ff7b72;font-weight:bold">*</span>Scanner) <span style="color:#d2a8ff;font-weight:bold">advance</span>(n <span style="color:#ff7b72">int</span>) <span style="color:#ff7b72">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> n &lt; <span style="color:#a5d6ff">0</span> {
</span></span><span style="display:flex;"><span>		s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(ErrNegativeAdvance)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">if</span> n &gt; s.end<span style="color:#ff7b72;font-weight:bold">-</span>s.start {
</span></span><span style="display:flex;"><span>		s.<span style="color:#d2a8ff;font-weight:bold">setErr</span>(ErrAdvanceTooFar)
</span></span><span style="display:flex;"><span>		<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">false</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	s.start <span style="color:#ff7b72;font-weight:bold">+=</span> n
</span></span><span style="display:flex;"><span>	<span style="color:#ff7b72">return</span> <span style="color:#79c0ff">true</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
      </div>


      <footer>
        


        
        
        
        
        

        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2020 -
    
    2024
     Timothy Wu 
    ·
    
     <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/" target="_blank" rel="noopener">Coder</a>.
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js" integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script>
  

  

  


  

  

  

  

  

  

  

  

  

  

  

  

  

  

  
</body>

</html>
