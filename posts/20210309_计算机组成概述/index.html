<!DOCTYPE html>
<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="robots" content="noodp" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
        <title>计算机组成-概述 - 实践出真知</title><meta name="Description" content=""><meta property="og:title" content="计算机组成-概述" />
<meta property="og:description" content="第1章 计算机系统概述 冯诺依曼结构：运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机一般把控制器和运算器集成在一个芯片上，合" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-09T14:26:14+08:00" />
<meta property="article:modified_time" content="2021-03-09T14:26:14+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="计算机组成-概述"/>
<meta name="twitter:description" content="第1章 计算机系统概述 冯诺依曼结构：运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机一般把控制器和运算器集成在一个芯片上，合"/>
<meta name="application-name" content="实践出真知">
<meta name="apple-mobile-web-app-title" content="实践出真知"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
        <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="manifest" href="/site.webmanifest"><link rel="canonical" href="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" /><link rel="prev" href="http://wtysos11.github.io/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" /><link rel="next" href="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" /><link rel="stylesheet" href="/lib/normalize/normalize.min.css"><link rel="stylesheet" href="/css/style.min.css"><link rel="stylesheet" href="/lib/fontawesome-free/all.min.css"><link rel="stylesheet" href="/lib/animate/animate.min.css"><script type="application/ld+json">
    {
        "@context": "http://schema.org",
        "@type": "BlogPosting",
        "headline": "计算机组成-概述",
        "inLanguage": "zh-CN",
        "mainEntityOfPage": {
            "@type": "WebPage",
            "@id": "http:\/\/wtysos11.github.io\/posts\/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0\/"
        },"genre": "posts","keywords": "考研, 计算机组成","wordcount":  21418 ,
        "url": "http:\/\/wtysos11.github.io\/posts\/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0\/","datePublished": "2021-03-09T14:26:14+08:00","dateModified": "2021-03-09T14:26:14+08:00","publisher": {
            "@type": "Organization",
            "name": "Carlo Wu"},"author": {
                "@type": "Person",
                "name": "Carlo Wu"
            },"description": ""
    }
    </script></head>
    <body header-desktop="" header-mobile=""><script type="text/javascript">(window.localStorage && localStorage.getItem('theme') ? localStorage.getItem('theme') === 'dark' : ('' === 'auto' ? window.matchMedia('(prefers-color-scheme: dark)').matches : '' === 'dark')) && document.body.setAttribute('theme', 'dark');</script>

        <div id="mask"></div><div class="wrapper"><header class="desktop" id="header-desktop">
    <div class="header-wrapper">
        <div class="header-title">
            <a href="/" title="实践出真知">实践出真知</a>
        </div>
        <div class="menu">
            <div class="menu-inner"><a class="menu-item" href="/posts/"> 文章 </a><a class="menu-item" href="/tags/"> 标签 </a><a class="menu-item" href="/categories/"> 分类 </a><span class="menu-item delimiter"></span><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                    <i class="fas fa-adjust fa-fw"></i>
                </a>
            </div>
        </div>
    </div>
</header><header class="mobile" id="header-mobile">
    <div class="header-container">
        <div class="header-wrapper">
            <div class="header-title">
                <a href="/" title="实践出真知">实践出真知</a>
            </div>
            <div class="menu-toggle" id="menu-toggle-mobile">
                <span></span><span></span><span></span>
            </div>
        </div>
        <div class="menu" id="menu-mobile"><a class="menu-item" href="/posts/" title="">文章</a><a class="menu-item" href="/tags/" title="">标签</a><a class="menu-item" href="/categories/" title="">分类</a><a href="javascript:void(0);" class="menu-item theme-switch" title="切换主题">
                <i class="fas fa-adjust fa-fw"></i>
            </a></div>
    </div>
</header>
<div class="search-dropdown desktop">
    <div id="search-dropdown-desktop"></div>
</div>
<div class="search-dropdown mobile">
    <div id="search-dropdown-mobile"></div>
</div>
<main class="main">
                <div class="container"><div class="toc" id="toc-auto">
            <h2 class="toc-title">目录</h2>
            <div class="toc-content" id="toc-content-auto"></div>
        </div><article class="page single"><h1 class="single-title animated flipInX">计算机组成-概述</h1><div class="post-meta">
            <div class="post-meta-line"><span class="post-author"><a href="https://github.com/wtysos11/" title="Author" target="_blank" rel="noopener noreffer author" class="author"><i class="fas fa-user-circle fa-fw"></i>Carlo Wu</a></span>&nbsp;<span class="post-category">收录于 <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><i class="far fa-folder fa-fw"></i>计算机基础</a></span></div>
            <div class="post-meta-line"><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime="2021-03-09">2021-03-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 21418 字&nbsp;
                <i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 43 分钟&nbsp;</div>
        </div><div class="details toc" id="toc-static"  kept="">
                <div class="details-summary toc-title">
                    <span>目录</span>
                    <span><i class="details-icon fas fa-angle-right"></i></span>
                </div>
                <div class="details-content toc-content" id="toc-content-static"><nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#125-计算机系统的多级层次结果">1.2.5 计算机系统的多级层次结果</a></li>
      </ul>
    </li>
    <li><a href="#13-计算机的性能指标">1.3 计算机的性能指标</a>
      <ul>
        <li><a href="#浮点数">浮点数</a></li>
        <li><a href="#易忘知识点">易忘知识点</a></li>
      </ul>
    </li>
  </ul>

  <ul>
    <li>
      <ul>
        <li><a href="#312-存储器的性能指标">3.1.2 存储器的性能指标</a></li>
      </ul>
    </li>
    <li><a href="#32-存储器的层次化结构">3.2 存储器的层次化结构</a></li>
    <li><a href="#33-半导体随机存储器">3.3 半导体随机存储器</a>
      <ul>
        <li></li>
        <li><a href="#333-只读存储器">3.3.3 只读存储器</a></li>
      </ul>
    </li>
    <li><a href="#34-主存储器与cpu的连接">3.4 主存储器与CPU的连接</a>
      <ul>
        <li><a href="#343-存储芯片的地址分配和片选">3.4.3 存储芯片的地址分配和片选</a></li>
        <li><a href="#351-双端口ram">3.5.1 双端口RAM</a></li>
        <li><a href="#352-多模块存储器">3.5.2 多模块存储器</a></li>
        <li><a href="#36-高速缓冲器">3.6 高速缓冲器</a></li>
        <li><a href="#363-cache和主存的映射方式">3.6.3 Cache和主存的映射方式</a></li>
        <li><a href="#364-cache中主存块的替换算法">3.6.4 Cache中主存块的替换算法</a></li>
        <li><a href="#365-cache写策略">3.6.5 Cache写策略</a></li>
        <li><a href="#42-指令寻址方式">4.2 指令寻址方式</a></li>
        <li><a href="#43-cisco和risc的基本概念">4.3 CISCO和RISC的基本概念</a></li>
        <li><a href="#51-cpu的功能和基本结构">5.1 CPU的功能和基本结构</a></li>
        <li><a href="#52-指令执行过程">5.2 指令执行过程</a></li>
        <li><a href="#53-数据通路的功能和基本结构">5.3 数据通路的功能和基本结构</a></li>
        <li><a href="#54-控制器的功能和工作原理">5.4 控制器的功能和工作原理</a></li>
        <li><a href="#55-指令流水线">5.5 指令流水线</a></li>
      </ul>
    </li>
    <li><a href="#第6章-总线">第6章 总线</a>
      <ul>
        <li><a href="#61-总线概述">6.1 总线概述</a></li>
        <li><a href="#62-总线仲裁">6.2 总线仲裁</a></li>
        <li><a href="#63-总线操作和定时">6.3 总线操作和定时</a></li>
        <li><a href="#64-总线标准">6.4 总线标准</a></li>
      </ul>
    </li>
    <li><a href="#第7章-输入输出系统">第7章 输入/输出系统</a>
      <ul>
        <li><a href="#71-io系统基本概念">7.1 I/O系统基本概念</a></li>
        <li><a href="#72-外部设备">7.2 外部设备</a></li>
        <li><a href="#73-io接口">7.3 IO接口</a></li>
        <li><a href="#74-io方式">7.4 I/O方式</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
            </div><div class="content" id="content"><h1 id="第1章-计算机系统概述">第1章 计算机系统概述</h1>
<p>冯诺依曼结构：运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机一般把控制器和运算器集成在一个芯片上，合称为中央处理器。
现代计算机一般以存储器为中心，使I/O操作尽可能绕过CPU，直接在I/O设备与存储器间完成，从而提高系统的整体运行效率。</p>
<p>重要设备：</p>
<ul>
<li>地址寄存器MAR：存放访存地址，经过地址译码后可以找到所选的存储单元。</li>
<li>数据寄存器MDR：是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息，失序控制逻辑用于产生存储器操作所需的各种时序信号。位数和存储字长相等。</li>
</ul>
<p>MAR和MDR虽然是存储器的一部分，但是确实在现代CPU内的。</p>
<ul>
<li>运算器：核心是ALUM，包含若干通用寄存器用于暂存操作数和中间结果。另外还有程序状态寄存器PSW，用来保留各类运算指令或测试指令的结果的各类状态信息，以表征系统运行状态。</li>
<li>控制器：由程序计数器PC、指令寄存器IR、控制单元CU组成。PC存放当前欲执行指令的地址。IR用来存放当前的指令，内容来自于主存的MDR。</li>
</ul>
<p>CPU和主存储器构成主机，计算机中除去主机的其他硬件设备统称为外部设备。</p>
<ul>
<li>系统软件：保证计算机系统高效、正确运行的基础软件，包括操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序。</li>
<li>应用软件：用户为解决某个应用领域中的各类问题而编制的程序。</li>
</ul>
<p>PS：DBMS和DBS是有区别的。DBMS是系统软件，而DBS是引入DBMS后的系统。</p>
<p>信息流程：</p>
<ul>
<li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li>
<li>分析指令：OP(IR)-&gt;CU</li>
<li>执行指令：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li>
</ul>
<h3 id="125-计算机系统的多级层次结果">1.2.5 计算机系统的多级层次结果</h3>
<ol>
<li>微程序机器层。硬件层，由机器硬件直接执行微指令。</li>
<li>传统机器语言层。机器层，由微程序解释机器指令系统。</li>
<li>操作系统层。由操作系统定义和解释软件指令，作为广义指令。以及机器指令组成。</li>
<li>汇编语言层。</li>
<li>高级语言层。</li>
<li>应用层。</li>
</ol>
<p>层次之间，下层是上层的基础，上层是下层的扩展。</p>
<h2 id="13-计算机的性能指标">1.3 计算机的性能指标</h2>
<ol>
<li>机器字长：计算机进行一次整数运算所能处理的二进制数据的位数。</li>
<li>数据通路带宽：数据总线一次能并行传送信息的位数</li>
<li>贮存容量：主存储器所能存储信息的最大容量。MAR的位数反应了存储单元的个数，MDR的位数反应了可寻址范围的最大值。</li>
<li>吞吐量：系统在单位时间内处理请求的数目。</li>
</ol>
<ul>
<li>CPU时钟周期：CPU中最小的时间单位，每个动作至少需要一个时钟周期。</li>
<li>CPU时钟主频：CPU时钟周期的倒数。主频越高，完成指令的一个执行步骤所需要的时间越短。</li>
</ul>
<p>CPI：指执行一条指令所需的时钟周期数
CPU执行时间= CPU周期数/主频=（指令条数*CPI）/主频
MIPS(million instructions per second)：每秒执行多少百万条指令。有MIPS=指令条数/(执行时间*10^6)=主频/CPI</p>
<p>MFLOPS，每秒执行多少百万次浮点运算，重要的性能判断标志。</p>
<ul>
<li>平均指令周期 = 1/MIPS</li>
<li>平均每条指令的时钟周期数(CPI)=平均指令周期/CPU时钟周期=1/(MIPS*主频)</li>
</ul>
<p>题目
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65579656-bffd6580-dfaa-11e9-8611-17bab9e2c6e4.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65579656-bffd6580-dfaa-11e9-8611-17bab9e2c6e4.png, https://user-images.githubusercontent.com/21279827/65579656-bffd6580-dfaa-11e9-8611-17bab9e2c6e4.png 1.5x, https://user-images.githubusercontent.com/21279827/65579656-bffd6580-dfaa-11e9-8611-17bab9e2c6e4.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65579656-bffd6580-dfaa-11e9-8611-17bab9e2c6e4.png"
        title="计算机组成第一章题目" />
17.C
解析：基准程序的CPI=2*0.5+3*0.2+4*0.1+5*0.2=3。计算机的主频为1.2GHz，即1200MHz，故该机器的MIPS=1200/3=400
18.D
解析：程序A的运行时间为100秒，除去CPU时间90秒，剩下10秒为I/O时间。CPU提速后运行基准程序A所耗费的时间T=90/1.5+10秒
19.D
解析：假设原来指令条数为x，那么原CPI就为20*f/x（注：f为CPU的时钟频率），经过编译优化后，指令条数减少到原来的70%，即指令条数为0.7x，而CPI增加到原来的1.2倍，即24*f/x，那么现在P在M上的执行时间就为：（指令条数*CPI）/f=(0.7x*24*f/x)/f=16.8秒
20.C
运行时间=指令数*CPI/主频。M1的时间=指令数*21.5，M2的时间=指令数*1/1.2，两者之比为(2/1.5):(1/1.2)=1.6</p>
<p>透明性：在计算机领域中，站在某一类用户的角度，如果感觉不到某个事物或属性的存在，则称“对该用户而言，某个事物或属性是透明的”。这与日常生活中透明的概念刚好相反。</p>
<p>例如，对于高级语言程序员而言，浮点数格式、乘法指令等这些语言的格式、数据如何在运算器中运算都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。</p>
<p>码距：任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。</p>
<p>奇偶校验，最高位为校验位，剩下的是信息位</p>
<ul>
<li>奇校验：1的个数为奇数。</li>
<li>偶校验：1个个数为偶数。</li>
</ul>
<p>缺点为只能发现数据代码中奇数位出现错误的情况，不能纠正错误。</p>
<p>海明码的位数：n位有效信息位，k位校验位，有n+k&lt;=2^k-1。</p>
<p>海明码最高位采用全校验，全校验是对全部数据位和其他校验位采用偶校验计算出来的。</p>
<p>纠错理论：L-1=D+C，且D&gt;=C，这里L是编码最小码距，D为检测错误位数，C为纠正错误位数。</p>
<p>第2章重点复习：补码和原码的乘法和除法
<a href="https://blog.csdn.net/programmer_at/article/details/54882503#t18" target="_blank" rel="noopener noreffer">大佬的博客：数的表示与运算</a>
PS：变形补码等同于模4补码，即符号位有两位</p>
<h3 id="浮点数">浮点数</h3>
<p>值得注意的一点：标准的移码中，对于n+1位，偏移量为2^n，这时候有一个很好的性质，就是移码在表示上等于补码在符号位取反后的结果。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">- IEEE754不是标准的译码，它的偏移量是2^k-1，即对于32位浮点数，偏移量为127
</span><span class="gd">- 从网上的回答来看，目的应当是为了对齐范围
</span></code></pre></div><h4 id="浮点数加减运算">浮点数加减运算</h4>
<ol>
<li>对阶：目的是将小数点的位置对齐，使得两个数阶码相等。求阶差，然后小阶向大阶看齐的原则，将阶码小的尾数右移一位，阶加1，直到阶码相等。尾数右移的时候会舍弃有效位，引起误差。</li>
<li>尾数求和：对阶后尾数按定点数加减法运算。</li>
<li>规格化：尾数计算后有空缺，需要左规；尾数求和时结果溢出，需要右规</li>
<li>舍入：在对阶和右规的过程中，可能将尾数的低位丢失，引起误差，影响精度。（0舍1入，或是恒置1法）</li>
<li>溢出判断：浮点数使用双符号位，如果两个符号位的值不一致，则说明出现了溢出（01正溢出，上溢、10负溢出，下溢）。上溢的时候中断处理，下溢的时候当作机器零使用。</li>
</ol>
<p>阶码全1表示无穷大（根据符号位分为正无穷和负无穷，要求尾数为0）
阶码全0表示非规格数，其中尾数全0表示机器零。
<a href="https://blog.csdn.net/hqin6/article/details/6701109" target="_blank" rel="noopener noreffer">这篇文章</a>介绍的很好。</p>
<p>2009年真题
浮点数加、减运算过程一般包括对阶、尾数运算、规格化、舍入和判溢出等步骤。设浮点数的阶码和尾数均采用补码表示，且位数分别为5位和7位（均含2位符号位）。若有两个数X=2^7*29/32，Y=2%5*5/8，则用浮点加法计算X+Y的最终结果是（）
A. 00111 1100010 B.00111 0100010
C. 01000 0010001 D.发生溢出
解析：选D
根据浮点数的加法步骤进行计算
X：00,111;00,11101
Y：00,101;00,10100
1 对阶。X、Y的阶码相减，可以目测出来是X的阶码比Y大2.根据小阶向大阶看齐的原则，将Y的阶码加2，尾数右移2位，将Y变为00,111;00,00101
2 尾数相加，得到01,00010，尾数相加结果符号位为01，故需要右规
3 规格化。将尾数右移1位，阶码加1，得X+Y：01,000;00,10001
4 判断溢出。阶码符号位为01，说明发生正溢出
本题容易误选B、C，B少了第3和第4步，C少了第4步</p>
<h3 id="易忘知识点">易忘知识点</h3>
<p>大端：高位低地址
小端：低位低地址
如0x12345678，大端为12 34 56 78，小端为78 56 34 12</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65734319-f0591700-e104-11e9-90c5-2dfcbb7fa0e8.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65734319-f0591700-e104-11e9-90c5-2dfcbb7fa0e8.png, https://user-images.githubusercontent.com/21279827/65734319-f0591700-e104-11e9-90c5-2dfcbb7fa0e8.png 1.5x, https://user-images.githubusercontent.com/21279827/65734319-f0591700-e104-11e9-90c5-2dfcbb7fa0e8.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65734319-f0591700-e104-11e9-90c5-2dfcbb7fa0e8.png"
        title="编码" />
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65734320-f0f1ad80-e104-11e9-90f0-9079e593b68d.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65734320-f0f1ad80-e104-11e9-90f0-9079e593b68d.png, https://user-images.githubusercontent.com/21279827/65734320-f0f1ad80-e104-11e9-90f0-9079e593b68d.png 1.5x, https://user-images.githubusercontent.com/21279827/65734320-f0f1ad80-e104-11e9-90f0-9079e593b68d.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65734320-f0f1ad80-e104-11e9-90f0-9079e593b68d.png"
        title="浮点数" /></p>
<h1 id="第三章-存储单元">第三章 存储单元</h1>
<h3 id="312-存储器的性能指标">3.1.2 存储器的性能指标</h3>
<ol>
<li>存储容量=存储字数*字长，存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量</li>
<li>单位成本：每位价格=总成本/总容量</li>
<li>存储速度：数据传输率=数据的宽度/存储周期</li>
</ol>
<ul>
<li>存取时间Ta：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间</li>
<li>存取周期Tm：又称读写周期或访问周期，指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立地访问存储器操作之间所需的最小时间</li>
<li>主存带宽Bm：又称数据传输率，表示每秒从主存进出信息的最大数量，单位为字节/秒之类
存取周期一般大于存取时间，因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于破坏性读出的存储器（RAM），存取周期往往比存取时间大得多。</li>
</ul>
<h2 id="32-存储器的层次化结构">3.2 存储器的层次化结构</h2>
<p>速度、容量和价格三者不能同时取得。</p>
<ul>
<li>cache-主存：主要解决CPU和主存速度不匹配的问题</li>
<li>主存-辅存：主要解决存储系统的容量问题
上一层中的内容都是下一层中内容的副本。</li>
</ul>
<h2 id="33-半导体随机存储器">3.3 半导体随机存储器</h2>
<ul>
<li>SRAM：静态随机存储器，非破坏性读出，但是易失，断点信息不保存。功耗大、集成度低，一般用作高速缓存。</li>
<li>DRAM：动态随机存储器，存取速度较慢，破坏性读出且易失</li>
</ul>
<p>DRAM需要定期刷新，重新将信息写入电容中。</p>
<ul>
<li>集中刷新：在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生。优点是读写操作不受刷新操作影响，缺点是刷新时不能访问存储器</li>
<li>分散刷新：把对每一行的刷新分散到各个工作周期中。优点是没有死区，缺点是加长了系统的存取周期，降低了整机速度</li>
<li>异步刷新：结合两者，具体做法是将刷新周期除以行数，得到两次刷新操作的时间间隔t，逻辑电路每隔t秒产生一次刷新请求，尽量减少刷新的次数
透明刷新：将刷新安排在不需要访问存储器的译码阶段，。</li>
</ul>
<p>特点：</p>
<ol>
<li>刷新对CPU透明，即不依赖于外部的访问</li>
<li>DRAM以行为单位刷新，只需要行地址</li>
<li>刷新操作仅仅是给栅极电容补充电荷而不需要信息输出，而且不需要选片，整个存储器的所有芯片同时被刷新。</li>
</ol>
<h4 id="地址复用技术">地址复用技术</h4>
<p>来自百度知道
书上并没有明确提出这个概念，不过参考各种资料可以得出如下结论：</p>
<ol>
<li>地址复用技术只适用于DRAM，不适用于SRAM</li>
<li>地址复用技术的目的是为了减少地址线的数量，便于增加DRAM的集成度</li>
<li>地址复用技术的本质是分两次送行列地址，因为半导体存储芯片的核心存储矩阵是采用行列地址交叉确定存储单元，所以既可以像SRAM那样一次同时取得行列地址，提高运行速度，也可以像DRAM那样分两次取得行列地址，减少地址线的数量。
另外SRAM与DRAM有许多不同，这个技术也是导致不同的原因之一。</li>
</ol>
<h3 id="333-只读存储器">3.3.3 只读存储器</h3>
<p>非易失，断电后信息保存</p>
<ol>
<li>MROM：任何人无法改变内容</li>
<li>PROM：一次可编程ROM，允许用户自行写入程序，一旦写入后内容无法改变</li>
<li>EPROM：可以进行多次改写，当需要改变内容时需要将其中的全部内容擦除，再进行编成。分为紫外线擦除和电可擦除式两种。（编程次数有限，且写入时间过长）</li>
<li>Flash Memory闪存：在EPROM和E2PROM基础上发展起来，在不加点的情况下可以长期保存信息，擦除重写的速度快。</li>
<li>固态硬盘SSD：用固态电子存储芯片阵列制成的磁盘，由控制单元和闪存芯片组成。价格较高</li>
</ol>
<h2 id="34-主存储器与cpu的连接">3.4 主存储器与CPU的连接</h2>
<p>主存容量扩展：位扩展、字扩展、位字扩展</p>
<h3 id="343-存储芯片的地址分配和片选">3.4.3 存储芯片的地址分配和片选</h3>
<p>片选+字选</p>
<ol>
<li>线选法：用高位地址线直接访问存储单元的片选端。优点是实现简单，不需要译码器；缺点是地址空间不连续，选片的地址线必须分时为低电平</li>
<li>译码片选法：用除片内寻址外的高位地址线通过地址译码器芯片产生片选信号</li>
</ol>
<p>##3.5 双口RAM和多模块存储器</p>
<h3 id="351-双端口ram">3.5.1 双端口RAM</h3>
<p>同一个存储器拥有左右两个独立的端口，允许两个独立的控制器同时异步地访问存储单元。当两个端口的地址不相同的时候，在两个端口上的读写操作一定不会产生冲突。
当读写同一个地址单元的时候：不同时存取或者读同一个数据不会产生冲突；同时写入或者一边读取一遍写入会产生冲突。</p>
<h3 id="352-多模块存储器">3.5.2 多模块存储器</h3>
<ol>
<li>单体多字存储器：存储器中只有一个存储体，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，地址必须顺序排列并处于同一个存储单元。优点是增大了存储器的带宽，提高了单体存储器的工作速度。缺点是指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或者操作数不能连续存放，那么效果就不明显了。</li>
<li>多体并行存储器：由多个模块组成，每个模块各自独立，既能够并行工作，又能交叉工作
<ul>
<li>高位交叉编址：高位地址表示体号，低位地址表示体内地址。仍然是顺序存储器，连续的数据放在同一存储单元中。</li>
<li>低位交叉编址：低位地址表示体号，高位地址表示体内地址。由于程序连续存放在相邻体中，因此称采用此编址方式的存储器为交叉存储器。</li>
</ul>
</li>
</ol>
<p>低位交叉编址后，可以在不改变每个模块存取周期的前提下，采用流水线的方式并行存取，提高存储器的带宽。
设模块字长等于数据总线宽度，模块存取一个字的存取周期为T，总线传送周期为r，为实现流水线方式存取，则存储器交叉模块数应大于等于m=T/r
其中，m称为交叉存取度，每经r时间延迟后启动下一个模块。如果保证流水线国祚，则连续存取m个字所需的时间为t1=T+(m-1)r</p>
<p>已知命中率为H，主存访问时间与cache访问时间的倍率r</p>
<p>cache主存系统的效率：e=访问Cache的时间/平均访存时间=1/[H+(1-H)r]</p>
<h3 id="36-高速缓冲器">3.6 高速缓冲器</h3>
<h4 id="361-程序访问的局部性原理">3.6.1 程序访问的局部性原理</h4>
<p>包括时间局部性和空间局部性。时间局部性指的是最近的未来要用到的信息，很可能是现在正在使用的信息，这是因为程序存在循环。空间局部性指的是最近的未来要用到的信息，很可能与现在正在使用的信息在存储空间上是邻近的，这是因为指令通常是顺序存放、顺序执行的，数据一般也是以向量、数组、表等形式簇聚地存储在一起。</p>
<p>高速缓存由SRAM构成</p>
<p>CPU要访问的信息在cache中的比率称为命中率，设总命中次数为Nc，访问内存的总次数为Nm，命中率H=Nc/(Nc+Nm)
平均访问时间Ta=Htc+(1-H)tm</p>
<h3 id="363-cache和主存的映射方式">3.6.3 Cache和主存的映射方式</h3>
<p>cache中要为每一块加一个标记，指明它是主存中那一块的副本，内容相当于主存中块的编号。
为了说明标记是否有效，每个标记至少应该设置一个有效位，该位为1的时候，表示Cache映射的主存块数据有效；否则无效。</p>
<ol>
<li>直接映射：j=i mod 2^c，其中j是cache的块号，i是主存的块号，2^c是cache中的总块数。直接映射的地址结构为：主存字块标记+Cache字块地址+字块内地址</li>
<li>全相联映射：可以把主存块装入Cache中的任何位置。通常采用按内容寻址的相联存储器来进行地址映射。地址结构为：主存字块标记+字块内地址</li>
<li>组相联映射：将cache分为大小相同的组，主存的一个数据块可以装入到一组内的任何一个位置，是对全相联映射和直接映射的一种折中。j=i mod Q，j是缓存的组号，i是主存的块号，Q是Cache的组数。地址结构：主存字块标记+组地址+字块内地址</li>
</ol>
<p>例题
假设某个计算机的主存地址空间大小为256MB，按字节寻址，其数据Cache有8个Cache行，行长为64B，那么
1.若不考虑用于cache的一致维护性和替换算法控制位，并且采用直接映射方式，则该数据cache的总容量为多少？
2.若该cache采用直接映射方式，则主存地址为3200(十进制)的主存块对应的cache行号是多少？若采用二路组相联映射又是多少？
3.以直接映射为例，简述访存过程（设访存的地址为0123456H）
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65736747-bab92b80-e10e-11e9-80a5-1614b7e9fbf1.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65736747-bab92b80-e10e-11e9-80a5-1614b7e9fbf1.png, https://user-images.githubusercontent.com/21279827/65736747-bab92b80-e10e-11e9-80a5-1614b7e9fbf1.png 1.5x, https://user-images.githubusercontent.com/21279827/65736747-bab92b80-e10e-11e9-80a5-1614b7e9fbf1.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65736747-bab92b80-e10e-11e9-80a5-1614b7e9fbf1.png"
        title="二路组相联" /></p>
<ol>
<li>4256bit，标记字段长度的计算：主存地址有28位(256MB=2^28B)，其中6位为块内地址(2^6B=64B)，3位为行号，剩余28-6-3=19位为标记字段，总容量为8*(1+19+512)=4256bit</li>
<li>直接映射方式中，主存按照块的大小划分，主存地址3200对应的字块号为3200B/64B=50。而Cache只有8行，则50mod8=2，故对应的cache行号为2
二路组相联，实际上就是将两个cache行合并，内部采用全相联方式，外部采用直接映射方式，50mod4=2，对应的组号为2，也就是对应的cache行号为4或5.</li>
<li>直接映射方式，28位主存地址可分为19位的主存标记位，3位的块号，6位的块内地址，即0000 0001 0010 0011 010位主存标记为，001位块号，010110位块内地址。
<ul>
<li>首先根据块号，查Cache（即001号Cache行）中对应主存标记位，看是否相同。如果相同，再看Cache行中的装入有效位是否为1，如果是，则表示有效，称此为访问命中，按块内地址010110读出Cache行所对应的单元送入CPU中，完成访存</li>
<li>如果出现标记位不相等或者有效位为0的情况，则是不命中，访问内存将数据取出送往CPU和Cache的对应块中，把主存的最高19位存入001行的Tag中，并将有效位置1.</li>
</ul>
</li>
</ol>
<h4 id="cache中的标记位">cache中的标记位</h4>
<p><a href="http://www.cskaoyan.com/thread-211356-1-1.html" target="_blank" rel="noopener noreffer">详细</a></p>
<ul>
<li>脏位：使用写回法修改数据的时，会先修改cache中的数据，再修改脏位，表示修改过。如果cache中的数据被换出且脏位被修改过，需要写回内存。</li>
<li>控制位：替换算法控制位，正常情况不用考虑，位数未知。</li>
<li>维护位：一致性维护位，一般不用考虑，主要用于多核调度的数据一致性。</li>
<li>有效位：标志着Cache数据是否有效的，比如刚开始的时候cache数据就是无效的。1位</li>
<li>标记位：主存字块标记位，表示这块Cache代表的主存中的哪一块。主存地址=主存字块标记位+Cache中的组号/直接映射号+cache内偏移</li>
</ul>
<h3 id="364-cache中主存块的替换算法">3.6.4 Cache中主存块的替换算法</h3>
<p>采用全相联映射和组相联映射方式时，当cache的空间已经被占满时，就需要使用替换算法替换cache行。</p>
<ol>
<li>随机算法：完全随机确定，命中率较低</li>
<li>先进先出算法：将最早调入的行进行替换，没有依据程序访问的局部性原理。</li>
<li>近期最少使用算法：堆栈类算法，平均命中率比FIFO高。实现上对每行设置一个计数器，Cache每命中一次，命中行计数器清0，而其他各行计数器均加1，需要替换时将计数值最大的行换出。</li>
<li>最不经常使用算法：将一段时间内被访问次数最少的存储行换出。每行也设置一个计数器，新行建立后从0开始计数，每访问一次，被访问的行计数器加1，需要替换的时候将计数值最小的行换出</li>
</ol>
<h3 id="365-cache写策略">3.6.5 Cache写策略</h3>
<p>对于Cache写命中，两种策略</p>
<ol>
<li>全写法(写直通法、write-through)：必须把数据同时写入cache和主存。替换时直接覆盖。实现简单，但是增加了访存次数。
<ul>
<li>写缓冲：为了减少全写法直接写入主存的时间消耗，在cache和主存之间加一个写缓冲。可以解决速度不匹配的问题，但是频繁写的时候可能会饱和溢出</li>
</ul>
</li>
<li>写回法(write-back)：不立即写入主存，只有当此块被换出时才写回主存。减少了访存次数，但存在不一致的隐患。实现上必须为每个cache行设置一个标志位（脏位），一次反映此块是否被CPU修改过。</li>
</ol>
<p>写不命中：</p>
<ol>
<li>写分配法(write-allocate)：加载主存中的块到cache中，然后更新这个块。缺点是每次不命中都要从主存中读取一块</li>
<li>非写分配法(not-write-allocate)：只写入内存，不进行掉块。</li>
</ol>
<p>一般非写分配法与全写法合用。写分配法通常和写回法合用。</p>
<p>PS：需要意识到，cache中的内容都是主存中的备份，因此在计算存储系统容量的时候不能够简单地将主存容量与cache容量相加。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-diff" data-lang="diff"><span class="gd">- 主存地址从0开始的时候，组相联的组号需要慎重考虑是否能直接通过求余得到（仔细思考）
</span><span class="gd"></span>
## 3.7 虚拟存储器
与cache的不同之处：
1. cache是为了解决系统速度，而虚拟存储器解决的是主存容量。
2. cache全由硬件实现，对所有程序员透明；而虚拟存储器由OS和硬件实现，对系统程序员不透明。
3. CPU速度为cache的10倍，而主存速度为磁盘速度的100倍，故虚拟存储器系统不命中时对系统性能的影响更大。
4. cache不命中的时候主存能直接和CPU通信，把数据调入cache中。而虚拟存储器不命中时只能先将数据调入主存，不能直接和CPU通信。
</code></pre></div><p>PS：指令和数据可以分别存储在不同的cache中，其特点是允许CPU在同一Cache存储周期内同时提取指令和数据，由于指令执行过程取值和取数据都有可能访问cache，这一特性可以保证不同的指令同时访存。</p>
<h3 id="42-指令寻址方式">4.2 指令寻址方式</h3>
<p>寻址方式是指寻找指令或操作数有效地址的方式，也就是确定本条指令的数据地址以及下一条要执行的指令地址的方法。分为指令寻址和数据寻址两大类。</p>
<p>指令中的地址码字段叫做形式地址A，通过A结合寻址方式可以计算出操作数在存储器中的真实地址，称为有效地址EA。</p>
<h4 id="421-指令寻址和数据寻址">4.2.1 指令寻址和数据寻址</h4>
<p>指令寻址的方式有两种，一种是顺序寻址方式，另一种是跳跃寻址方式。</p>
<ol>
<li>顺序寻址方式通过程序计数器PC加1（1个指令字长），自动形成下一条指令的地址。</li>
<li>跳跃寻址则通过转移类指令实现。跳跃指下一条指令的地址码由本条指令给出（提供计算方式，可能受状态寄存器和操作数的控制），跳跃到的地址分为绝对地址（由标记符直接得到）和相对地址（对于当前指令地址的偏移量），跳跃的结果是当前指令修改PC值，所以下一条指令仍然是通过程序计数器PC给出。</li>
</ol>
<p>数据寻址：数据寻址就是如何在指令中表示一个操作数的地址，如何用这种表示得到操作数或怎样计算出操作数的地址。</p>
<p>指令格式：操作码+寻址特征+形式地址A</p>
<h4 id="422-常见的数据寻址方式">4.2.2 常见的数据寻址方式</h4>
<ol>
<li>隐含寻址：不明显给出操作数的地址，在指令中隐含着操作数的地址。优点是有利于缩短指令字长，缺点是需要增加存储操作数或隐含地址的硬件。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155889-e0220980-f349-11e9-9634-51c05c3148e1.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155889-e0220980-f349-11e9-9634-51c05c3148e1.png, https://user-images.githubusercontent.com/21279827/67155889-e0220980-f349-11e9-9634-51c05c3148e1.png 1.5x, https://user-images.githubusercontent.com/21279827/67155889-e0220980-f349-11e9-9634-51c05c3148e1.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155889-e0220980-f349-11e9-9634-51c05c3148e1.png"
        title="1隐含寻址" /></li>
<li>立即（数）寻址：这些指令的地址字段指出的不是操作数的地址，而是操作数本身，又称为立即数。数据采用补码形式存放，优点是指令在执行期间不用访问主存，执行时间最短；缺点是A的位数限制了立即数的范围。</li>
<li>直接寻址：形式地址A=EA。优点是简单，只用访问一次主存；缺点是A的位数决定了该指令操作数的寻址范围，且操作数的地址不易修改。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155890-e57f5400-f349-11e9-9c58-a8b078316e7e.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155890-e57f5400-f349-11e9-9c58-a8b078316e7e.png, https://user-images.githubusercontent.com/21279827/67155890-e57f5400-f349-11e9-9c58-a8b078316e7e.png 1.5x, https://user-images.githubusercontent.com/21279827/67155890-e57f5400-f349-11e9-9c58-a8b078316e7e.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155890-e57f5400-f349-11e9-9c58-a8b078316e7e.png"
        title="2立即直接寻址" /></li>
<li>间接寻址：指令的地址字段给出的形式地址A不是操作数的真正地址EA，而是操作数有效地址所在的存储单元的地址（EA=(A)）。可以是一次间接寻址或是多次间接寻址。优点是可扩大寻址范围，便于编制程序（方便实现子程序返回）；缺点是指令在执行期间要多次访存，访问速度过慢，一般使用寄存器间接寻址。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155891-e9ab7180-f349-11e9-8385-0143ab150cea.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155891-e9ab7180-f349-11e9-8385-0143ab150cea.png, https://user-images.githubusercontent.com/21279827/67155891-e9ab7180-f349-11e9-8385-0143ab150cea.png 1.5x, https://user-images.githubusercontent.com/21279827/67155891-e9ab7180-f349-11e9-8385-0143ab150cea.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155891-e9ab7180-f349-11e9-8385-0143ab150cea.png"
        title="间接寻址" /></li>
<li>寄存器寻址：由指令直接给出操作数所在寄存器编号，即EA=R_i。优点是指令在执行期间不访问主存，只访问寄存器；缺点是寄存器价格昂贵，数量有限。</li>
<li>寄存器间接寻址：寄存器存放着操作数所在主存单元的地址，即EA=(R_i)，比一般的间接寻址速度更快，但是指令的执行阶段需要访问主存。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155894-edd78f00-f349-11e9-8e93-99a8f2f395ed.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155894-edd78f00-f349-11e9-8e93-99a8f2f395ed.png, https://user-images.githubusercontent.com/21279827/67155894-edd78f00-f349-11e9-8e93-99a8f2f395ed.png 1.5x, https://user-images.githubusercontent.com/21279827/67155894-edd78f00-f349-11e9-8e93-99a8f2f395ed.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155894-edd78f00-f349-11e9-8e93-99a8f2f395ed.png"
        title="寄存器寻址" /></li>
<li>相对寻址：把PC的内容+A得到操作数的有效地址，即EA=(PC)+A，A是相对于当前地址的偏移量，可正可负。优点是操作数的地址不固定，便于程序浮动，广泛用于转移指令。（值得注意的是，对于转移指令JMP A，PC会自动执行PC+1，也就是说会跳到目的指令的下一条指令执行）
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155895-f334d980-f349-11e9-96eb-5f28125bab2d.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155895-f334d980-f349-11e9-96eb-5f28125bab2d.png, https://user-images.githubusercontent.com/21279827/67155895-f334d980-f349-11e9-96eb-5f28125bab2d.png 1.5x, https://user-images.githubusercontent.com/21279827/67155895-f334d980-f349-11e9-96eb-5f28125bab2d.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155895-f334d980-f349-11e9-96eb-5f28125bab2d.png"
        title="相对寻址" /></li>
<li>基址寻址：将CPU中基址寄存器（BR）的内容加上指令格式中的形式地址A，形成操作数的有效地址，即EA=(BR)+A。基址寄存器是面向操作系统的，主要目的是解决程序逻辑空间与存储器物理空间的无关性，在程序执行过程中，基址寄存器的内容不变（作为基地址），形式地址可变（作为偏移量）。优点是可以扩大寻址范围，用户不必考虑自己的程序位于主存的哪一空间区域，利于多道程序设计，但偏移量的位数较短。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155897-f760f700-f349-11e9-9e26-2a86237455d7.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155897-f760f700-f349-11e9-9e26-2a86237455d7.png, https://user-images.githubusercontent.com/21279827/67155897-f760f700-f349-11e9-9e26-2a86237455d7.png 1.5x, https://user-images.githubusercontent.com/21279827/67155897-f760f700-f349-11e9-9e26-2a86237455d7.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155897-f760f700-f349-11e9-9e26-2a86237455d7.png"
        title="基址寻址" /></li>
<li>变址寻址：变址寄存器IX，EA=(IX)+A。变址寄存器是面向用户的，在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），而形式地址A不变（作为基地址）。优点是可以扩大寻址范围，利于编制循环程序，主要用于处理数组问题。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155899-fb8d1480-f349-11e9-8ac4-62c5d816876d.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155899-fb8d1480-f349-11e9-8ac4-62c5d816876d.png, https://user-images.githubusercontent.com/21279827/67155899-fb8d1480-f349-11e9-8ac4-62c5d816876d.png 1.5x, https://user-images.githubusercontent.com/21279827/67155899-fb8d1480-f349-11e9-8ac4-62c5d816876d.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155899-fb8d1480-f349-11e9-8ac4-62c5d816876d.png"
        title="变址寻址" /></li>
<li>堆栈寻址：堆栈是一块LIFO的存储区，地址由特定的寄存器=堆栈指针SP负责。堆栈可分为硬堆栈（寄存器堆栈）与软堆栈（主存堆栈），通过无操作数，隐式地使用SP完成操作。</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65738167-85630c80-e113-11e9-9036-29bf216ff722.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65738167-85630c80-e113-11e9-9036-29bf216ff722.png, https://user-images.githubusercontent.com/21279827/65738167-85630c80-e113-11e9-9036-29bf216ff722.png 1.5x, https://user-images.githubusercontent.com/21279827/65738167-85630c80-e113-11e9-9036-29bf216ff722.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65738167-85630c80-e113-11e9-9036-29bf216ff722.png"
        title="访存次数" /></p>
<h3 id="43-cisco和risc的基本概念">4.3 CISCO和RISC的基本概念</h3>
<ul>
<li>CISC，复杂指令系统计算机，典型的有采用x86架构</li>
<li>RISC，精简指令系统计算机，ARM和MIPS架构</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65749929-c9690800-e139-11e9-8b56-6f905bb707b7.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65749929-c9690800-e139-11e9-8b56-6f905bb707b7.png, https://user-images.githubusercontent.com/21279827/65749929-c9690800-e139-11e9-8b56-6f905bb707b7.png 1.5x, https://user-images.githubusercontent.com/21279827/65749929-c9690800-e139-11e9-8b56-6f905bb707b7.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65749929-c9690800-e139-11e9-8b56-6f905bb707b7.png"
        title="RISC和CISCO" /></p>
<h3 id="51-cpu的功能和基本结构">5.1 CPU的功能和基本结构</h3>
<h4 id="512-cpu的基本结构">5.1.2 CPU的基本结构</h4>
<ol>
<li>运算器，计算机对数据进行加工处理的中心，主要由算术逻辑单元ALUM、暂存寄存器、累加寄存器ACC、通用寄存器组、程序状态字寄存器（PSW）、移位器、计数器（CT）等组成。
<ol>
<li>算术逻辑单元：主要功能是进行算术/逻辑运算</li>
<li>暂存寄存器：暂存从主存读来的寄存器</li>
<li>累加寄存器：通用寄存器，暂存ALU运算的记过</li>
<li>通用寄存器组：用于存放操作数和各种地址信息。SP是堆栈指针，用于指示栈顶的地址。</li>
<li>程序状态字寄存器：保留由算术逻辑运算指令或测试指令的结果而建立的各种状态信息
<ol>
<li>CY/CF(carry)：加法运算中有进位或减法运算中有借位置1，否则置0</li>
<li>OV/OF：有无溢出，溢出时OF=1</li>
<li>SF/NF(symbol flag)：符号标志，判断指令执行后结果是否为负，如果是SF=1</li>
<li>ZF：零标志，判断结果是否为0，如果是ZF=1</li>
<li>IF：允许中断</li>
<li>TF：跟踪标志</li>
</ol>
</li>
<li>移位器：对操作数或运算结果进行移位运算</li>
<li>计数器：控制乘除运算的操作步数</li>
</ol>
</li>
<li>控制器：整个系统的指挥中枢，基本功能是执行指令，每条指令的执行都是由控制器发出的一组微操作实现的。工作原理是根据指令操作码、指令的执行步骤和条件信号来形成当前计算机各部件要用到的控制信号。分为硬布线控制器和微程序控制器两种。
<ol>
<li>程序计数器PC：用于指出下一条指令在主存中的存放地址。CPU根据PC的内容去主存中取指令</li>
<li>指令寄存器IR：用于保存当前正在执行的那条指令</li>
<li>指令译码器：对操作码字段进行译码，向控制器提供特定的操作信号。</li>
<li>存储器地址寄存器MAR：用于存放所要访问的主存单元的地址</li>
<li>存储器数据寄存器MDR：用于存放向主存写入的信息或从主存中读出的信息</li>
<li>时序系统：用于产生各种时序信号</li>
<li>微操作信号发生器：根据IR、PSW的内容以及时序信号，产生控制整个计算机系统所需要的各种控制信号，结构有组合逻辑型和存储逻辑型。</li>
</ol>
</li>
</ol>
<h3 id="52-指令执行过程">5.2 指令执行过程</h3>
<p>指令字长一般都取存储字长的整数倍，和机器字长没有关系。</p>
<h4 id="521-指令周期">5.2.1 指令周期</h4>
<p>指令周期：CPU从主存中每取出并执行一条指令所需的全部时间，也就是CPU完成一条指令的时间。
指令周期常常用若干机器周期表示，一个机器周期包含若干个时钟周期。
时钟周期，又称为节拍或T周期，是CPU操作的最基本单位。
机器周期，又称为CPU周期，是执行指令一项操作（取值、执行）的时间</p>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65738913-2226a980-e116-11e9-9128-6d25c4446f71.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65738913-2226a980-e116-11e9-9128-6d25c4446f71.png, https://user-images.githubusercontent.com/21279827/65738913-2226a980-e116-11e9-9128-6d25c4446f71.png 1.5x, https://user-images.githubusercontent.com/21279827/65738913-2226a980-e116-11e9-9128-6d25c4446f71.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65738913-2226a980-e116-11e9-9128-6d25c4446f71.png"
        title="各周期的关系" /></p>
<p>对于无条件转移指令，执行的时候不需要访问内存，只包含取指阶段（包括取值和分析）和执行阶段，所以其指令周期仅包含取指周期和执行周期。
对于间接寻址的指令，为了取操作数，需要先访问一次主存，取出有效地址，然后再访问主存取出操作数，所以还需要包括间址周期。
如果存在中断的话，还会有中断周期。完整的指令周期应该包含取值、间址、执行和中断4个周期。</p>
<p>上述4个工作周期CPU都需要访存，只是访存的目的不相同。
CPU设置4个标志触发器FE、IND、EX和INT，分别对应取值、间址、执行和中断周期。
PS：中断周期中进栈操作是将SP减1，和传统意义上相反。原因是计算机的堆栈中都是向低地址增加，所以进栈是减1而非加1.</p>
<h4 id="522-指令周期的数据流">5.2.2 指令周期的数据流</h4>
<p>取值周期，任务是根据PC中的内容从主存中取出指令代码并存放在IR中。</p>
<p>1.PC-&gt;MAR-&gt;地址总线-&gt;主存
2. CU发出控制信号-&gt;控制总线-&gt;主存
3. 主存-&gt;数据总线-&gt;MDR-&gt;IR
4. CU发出读命令-&gt;PC内容加1</p>
<p>间址周期，任务是取操作数有效地址。以一次间址为例，将指令中的地址码送到MAR并送至地址总线，此后CU向存储器发读命令，以获取有效地址并存至MDR。</p>
<ol>
<li>Ad(IR)-&gt;MAR-&gt;地址总线-&gt;主存</li>
<li>CU发出读命令-&gt;控制总线-&gt;主存</li>
<li>主存-&gt;数据总线-&gt;MDR（存放有效地址）
其中，Ad(IR)表示取出IR中存放的指令字的地址字段。</li>
</ol>
<p>执行周期，任务是根据IR中的指令字的操作码和操作数通过ALUM操作产生执行结果。</p>
<p>中断周期，任务是处理中断请求。假设程序断点存入堆栈中，并用SP指示栈顶地址，而且进栈操作是先修改栈顶指针，后存入数据。</p>
<h3 id="53-数据通路的功能和基本结构">5.3 数据通路的功能和基本结构</h3>
<p>数据在功能部件之间的传送路径称为数据通路，描述了信息从什么地方开始，中间经过哪个寄存器或多路开关，最后传送到哪个寄存器。</p>
<h4 id="532-数据通路的基本结构">5.3.2 数据通路的基本结构</h4>
<ol>
<li>CPU内部单总线方式。将所有寄存器的输入端和输出端都连接到一条公共的通路上，存在较多的冲突现象，性能较低</li>
<li>CPU内部三总线方式。将所有寄存器的输入端和输出端都连接到多条公共的通路上，同时在多个总线上传送不同的数据，提高效率</li>
<li>专用数据通路方式，避免使用共享总线，性能比较高，但是硬件量大</li>
</ol>
<h3 id="54-控制器的功能和工作原理">5.4 控制器的功能和工作原理</h3>
<p>控制器的主要功能：</p>
<ol>
<li>从主存中取出一条指令，并指出下一条指令在主存中的位置</li>
<li>对指令进行译码或测试，产生相应的操作控制信号，以便启动规定的动作</li>
<li>指挥并控制CPU、主存、输入和输出设备之间的数据流动方向</li>
</ol>
<h4 id="542-硬布线控制器">5.4.2 硬布线控制器</h4>
<p>基本原理：根据指令的要求、当前的时序及外部和内部的状态情况，按时间的顺序发送一系列微操作控制信号。由复杂的组合逻辑门电路和一些触发器构成，因此又称为组合逻辑控制器。</p>
<p>CPU的控制方式：控制单元控制一条指令执行的过程，实质上是依次执行一个确定的微操作序列的过程。因为每条指令和每个微操作所需的执行时间也不同，有3种控制方式：</p>
<ol>
<li>同步控制方式：系统有统一的时钟，所有的控制信号来自统一的时钟信号。通常以最长的微操作序列和最繁琐的微操作作为标准，采用完全统一的、具有相同时间间隔和相同数目的节拍作为机器周期来运行不同的指令。优点是控制电路简单，缺点是运行速度慢</li>
<li>异步控制方式：不存在基准时钟信号，各部件按照自身固有的速度工作，通过应答方式进行联络。优点是速度快，缺点是控制电路复杂</li>
<li>联合控制方式：介于同步、异步的一种折中，对不同指令的微操作实行大部分同步控制、小部分异步控制的方法</li>
</ol>
<p>硬布线控制单元设计步骤：</p>
<ol>
<li>列出微操作命令的操作时间表</li>
<li>进行微操作信号总和</li>
<li>画出微操作命令的逻辑图</li>
</ol>
<h4 id="543-微程序控制器">5.4.3 微程序控制器</h4>
<p>基本思想是将每一条机器指令编写成一个微程序，每一个微程序包含若干条微指令，每一条微指令对应一个或几个微操作命令。</p>
<ul>
<li>微命令和微操作是一一对应的，微命令是微操作的控制信号，微操作是微命令的执行过程</li>
<li>微指令是若干微命令的集合。</li>
<li>微周期通常指从控制存储器中读取一条微指令并执行相应微操作所需的时间</li>
</ul>
<p>微程序控制器的基本组成：
主要画出的是微程序控制器比组合逻辑控制器多出的部件</p>
<ol>
<li>控制存储器CM：它是微程序控制器的核心部件，用于存放各指令对应的微程序，可以用ROM构成</li>
<li>微指令寄存器CMDR：用于存放从CM中取出的微指令，它的位数同微指令字长相等</li>
<li>微地址形成部件：用于产生初始微地址和后继微地址，以保证微指令的连续执行</li>
<li>微地址寄存器CMAR：接收微地址形成部件送来的微地址，为在CM中读取微指令做准备</li>
</ol>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65748649-054e9e00-e137-11e9-9844-5d75cad74502.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65748649-054e9e00-e137-11e9-9844-5d75cad74502.png, https://user-images.githubusercontent.com/21279827/65748649-054e9e00-e137-11e9-9844-5d75cad74502.png 1.5x, https://user-images.githubusercontent.com/21279827/65748649-054e9e00-e137-11e9-9844-5d75cad74502.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65748649-054e9e00-e137-11e9-9844-5d75cad74502.png"
        title="微程序控制器" />
微程序控制器的工作流程：</p>
<ol>
<li>执行取微指令公共操作</li>
<li>由机器指令的操作码字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR</li>
<li>从CM中逐条取出对应的微指令并执行</li>
<li>执行完对应于一条机器指令的一个微程序后又回到取值微程序的入口地址，继续1，以完成取下一条机器指令的公共操作。</li>
</ol>
<p>微指令的编码方式：编码的目的是在保证速度的情况下，尽量缩短微指令字长</p>
<ol>
<li>直接编码方式（直接控制）：微指令的微命令字段中每一位都代表一个微命令。设计微指令时，选用或不选用某个微命令，只需要将对应的位设为0或1即可。优点是简单、直观；缺点是微指令过长。</li>
<li>字段直接编码方式：将微指令的微命令字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同的字段中，每个字段独立编码。可以缩短字长，但是比较慢（一般每个小段还要留出一个状态，表示本字段不发出任何微命令）</li>
<li>字段间接编码方式：一些字段中的某些微命令需要由另一个字段中的某些微命令来解释，由于不是靠字段直接译码发出的微指令，故称为字段间接译码，又称隐式编码。可以进一步缩短微指令字长，但是削弱了微指令的并行执行能力，所以一般作为辅助手段。</li>
</ol>
<p>微指令的地址形成方式：</p>
<ol>
<li>直接由微指令的下地址字段指出。微程序格式中设置一个下地址字段，由微程序的下地址字段直接指出后继微指令的地址，又称为断定模式。</li>
<li>根据机器指令的操作码形成。当机器指令取至指令寄存器后，微指令的地址由操作码经微地址形成部件形成。
其他形成微指令序列地址的方式：</li>
</ol>
<ul>
<li>增量计数器法，适用于后继微指令的地址是连续的情况</li>
<li>根据各种标志决定微指令分支转移的地址</li>
<li>通过网络测试形成</li>
<li>由硬件直接产生微程序入口地址</li>
</ul>
<p>微指令的格式：</p>
<ol>
<li>水平型微指令：直接编码、字段直接编码、字段间接编码和混合编码都属于这种。指令字中的一位对应一个控制信号，一条水平型微指令定义并执行几种并行的基本操作
优点是微程序短，执行速度快；缺点是微指令长，编写微程序较麻烦</li>
<li>垂直型微指令。采用类似机器操作码的方式，在微指令中设置微操作字段，采用微操作码编译法。一条垂直型微指令只能定义并执行一种基本操作。
优点是微指令短、简单、规整；缺点是微程序长，执行速度慢，效率低</li>
<li>混合型微指令。在垂直型的基础上增加一些不太复杂的并行操作。
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65747697-a9831580-e134-11e9-8e49-890c507dfab7.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65747697-a9831580-e134-11e9-8e49-890c507dfab7.png, https://user-images.githubusercontent.com/21279827/65747697-a9831580-e134-11e9-8e49-890c507dfab7.png 1.5x, https://user-images.githubusercontent.com/21279827/65747697-a9831580-e134-11e9-8e49-890c507dfab7.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65747697-a9831580-e134-11e9-8e49-890c507dfab7.png"
        title="微指令区别" /></li>
</ol>
<p>微指令控制单元的设计步骤：</p>
<ol>
<li>写出对应机器指令的微操作命令及节拍安排</li>
<li>确定微指令格式</li>
<li>编写微指令码点</li>
</ol>
<ul>
<li>动态微程序设计：一台微程序控制的计算机，如果能够根据用户的要求改变微程序，那么这台机器就具有动态微程序设计功能。需要可写控制寄存器的支持，可采用可擦除只读寄存器EPROM。</li>
<li>毫微程序设计：如果硬件不由微程序直接控制，而是通过存放在第二级控制寄存器中的毫微程序来解释的，则直接控制硬件的是毫微微指令。</li>
</ul>
<p><img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65748216-f9161100-e135-11e9-8580-7c3a721a9b05.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65748216-f9161100-e135-11e9-8580-7c3a721a9b05.png, https://user-images.githubusercontent.com/21279827/65748216-f9161100-e135-11e9-8580-7c3a721a9b05.png 1.5x, https://user-images.githubusercontent.com/21279827/65748216-f9161100-e135-11e9-8580-7c3a721a9b05.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65748216-f9161100-e135-11e9-8580-7c3a721a9b05.png"
        title="硬布线和毫微" /></p>
<h3 id="55-指令流水线">5.5 指令流水线</h3>
<h4 id="552-流水线的分类">5.5.2 流水线的分类</h4>
<ul>
<li>部件功能级流水：将复杂的算术逻辑运算组成流水线工作方式。例如，将浮点加法运算分成求阶差、对阶、尾数相加以及结果规格化4个子过程</li>
<li>处理机级流水：把一条指令解释过程分成多个子过程，如前面提到的取值、译码、执行、访存及写回5个子过程</li>
<li>处理机间流水，一种宏流水，每一个处理机专门完成某一专门任务，各个处理机所得到的结果需存放在下一个处理机所共享的存储器中。</li>
</ul>
<h4 id="553-影响流水线的因素">5.5.3 影响流水线的因素</h4>
<ul>
<li>结构相关（资源冲突）
由于多条指令在同一时刻争用同一资源而引起的冲突称为结构相关。两种解决方法：</li>
</ul>
<ol>
<li>前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期。</li>
<li>单独设置数据存储器和指令存储器，使两项操作各自在不同的存储器中进行。（资源重复配置）</li>
</ol>
<ul>
<li>数据相关（数据冲突）
数据相关指在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况，则这两条指令即为数据相关。解决方法：</li>
</ul>
<ol>
<li>把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行，可分为硬件阻塞（stall）和软件插入&quot;NOP&quot;指令两种方法。</li>
<li>设置相关专用通路，即不等前一条指令把计算结果写回寄存器组，下一条指令也不再读寄存器组，而是直接把前一条指令的ALU的计算结果作为自己的输入数据开始计算过程。（数据旁路技术）</li>
<li>通过编译器对数据相关的指令编译优化的方法，通过调整指令顺序来解决数据相关。</li>
</ol>
<ul>
<li>控制相关（控制冲突）
当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。解决的方法：</li>
</ul>
<ol>
<li>对转移指令进行分支预测，尽早生成转移目标地址。分支预测分为简单（静态）预测和动态预测。静态预测总是预测条件不满足，即继续执行分支指令的后续指令。动态预测根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率。</li>
<li>预测转移成功和不成功两个控制流方向上的目标指令。</li>
<li>加快和提前形成条件码。</li>
<li>提高转移方向的猜准率。</li>
</ol>
<h4 id="554-流水线的性能指标">5.5.4 流水线的性能指标</h4>
<ul>
<li>
<p>吞吐率，指在单位时间内流水线所完成的任务数量，或是输出结果的数量。TP=n/Tk，其中n是任务数，Tk是处理完成n个任务所用的时间。</p>
</li>
<li>
<p>加速比，指完成同样一批任务，不使用流水线所用的时间与使用流水线所用的时间之比。设T0表示不使用流水线时的执行时间，即顺序执行所用的时间；Tk表示使用流水线时的执行时间，加速比S=T0/Tk。
如果流水线各段执行时间都相等，则一条k段流水线完成n个任务所需要的时间为Tk=(k+n-1)*\delta t。而不使用流水线，即顺序执行n个任务时，所需的时间为T0=kn\delta t，代入有加速比S=kn/(k+n-1)</p>
</li>
<li>
<p>效率，流水线的设备利用率称为流水线的效率。在时空图上，流水线的效率定义为完成n个任务占用的时空图有效面积与n个任务所用的时间与k个流水段所围成的时空区总面积之比。E=T0/kTk</p>
</li>
</ul>
<h4 id="555-超标量流水线的基本概念">5.5.5 超标量流水线的基本概念</h4>
<p>超标量流水线技术：每个时钟周期可并发多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此配置多个功能部件。
超流水线技术：在一个时钟周期内再分段，在一个时钟周期内一个功能部件使用多次。
超长指令字：由编译程序挖掘出指令潜在的并行性，将多条能并行操作的指令组合成一条具有多个操作码字段的超长指令字。</p>
<h4 id="真题">真题</h4>
<p>2017-19 下列关于指令流水线数据通路的叙述中，错误的是（）
A. 包含生成控制信号的控制部件 B. 包含算术逻辑运算部件ALU
C. 包含通用寄存器组和取指部件 D. 由组合逻辑电路和时序逻辑电路组成
解析：选A
流水线中各个子系统之间通过数据总线连接形成的数据传送路径称为数据通路，包含程序计数器、算术逻辑运算部件、通用寄存器组、取值部件等，不包括控制部件。</p>
<h2 id="第6章-总线">第6章 总线</h2>
<h3 id="61-总线概述">6.1 总线概述</h3>
<h4 id="612-总线的分类">6.1.2 总线的分类</h4>
<p>片内总线：芯片内部的总线，比如CPU芯片内部寄存器与寄存器之间、寄存器与ALUM之间的公共连接线</p>
<p>系统总线</p>
<ol>
<li>数据总线，用来传输各种功能部件之间的数据信息，是双向传输总线，其位数与机器字长、存储字长有关。</li>
<li>地址总线，用来指出数据总线上源数据或目的数据所在的主存单元或I/O端口的地址，单向传输总线，地址总线的位数与主存地址空间的大小有关。</li>
<li>控制总线，传输的是控制信息，包括CPU送出的控制命令和主存返回CPU的反馈信号。</li>
</ol>
<p>通信总线：计算机系统之间或计算机系统与其他系统之间信息传送的总线，也称为外部总线。</p>
<h4 id="614-总线的性能指标">6.1.4 总线的性能指标</h4>
<ul>
<li>传输周期：一次总线操作所需要的时间，简称总线周期。总线周期通常由若干个总线时钟周期组成。</li>
<li>总线时钟周期：即机器的时钟周期</li>
<li>总线的工作频率：总线上各种操作的频率，为总线周期的倒数，如果总线周期=N个时钟周期，总线的工作频率=时钟频率/N</li>
<li>总线宽度：总线位宽，总线上能同时传输的数据位数</li>
<li>总线带宽：可理解为总线的数据传输率，即单位时间内总线上可传输数据的位数。</li>
<li>总线带宽=总线宽度*总线工作频率/8 单位：B/s</li>
</ul>
<h3 id="62-总线仲裁">6.2 总线仲裁</h3>
<h4 id="621-集中仲裁方式">6.2.1 集中仲裁方式</h4>
<p>总线控制逻辑集中于一个设备上，利用一个特定的裁决算法进行裁决，称为集中仲裁方式</p>
<ol>
<li>链式查询方式：总线上所有的部件共用一根总线请求线，响应信号逐个传递。如果响应信号到达的部件有总线请求，则信号被截住，不再传下去。
<ul>
<li>优点：优先级固定，结构简单，扩展容易</li>
<li>缺点：对硬件电路的故障敏感，且优先级不可改变，可能会饥饿</li>
</ul>
</li>
<li>计数器定时查询方式：采用一个计数器控制总线使用权，计数器计数是，如果地址线上的计数值与请求使用总线设备的地址一致时，该设备获得总线使用权，同时中止计数器的计数及查询。
<ul>
<li>优点：设备使用总线的优先级相等，而且硬件故障不那么敏感</li>
<li>缺点：增加了控制线数，控制更加复杂</li>
</ul>
</li>
<li>独立请求方式：每个设备均有一对总线请求线和总线允许线。
<ul>
<li>优点：响应速度快</li>
<li>缺点：控制线数量很多，总线逻辑更加复杂
总结：
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/65765925-11992200-e15c-11e9-8622-979e63f4eda6.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/65765925-11992200-e15c-11e9-8622-979e63f4eda6.png, https://user-images.githubusercontent.com/21279827/65765925-11992200-e15c-11e9-8622-979e63f4eda6.png 1.5x, https://user-images.githubusercontent.com/21279827/65765925-11992200-e15c-11e9-8622-979e63f4eda6.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/65765925-11992200-e15c-11e9-8622-979e63f4eda6.png"
        title="总线" /></li>
</ul>
</li>
</ol>
<h4 id="622-分布仲裁方式">6.2.2 分布仲裁方式</h4>
<p>每个设备有自己的仲裁号和仲裁器，每个仲裁器将从仲裁总线上得到的仲裁号与自己的仲裁号进行比较，如果仲裁总线上的号优先级高，则它的总线请求不予响应，并撤销它的仲裁号。最终，获胜者的仲裁号保留在仲裁总线上。</p>
<h3 id="63-总线操作和定时">6.3 总线操作和定时</h3>
<h4 id="631-总线传输的4个阶段">6.3.1 总线传输的4个阶段</h4>
<p>1.申请分配阶段：由使用总线的主模块向总线仲裁机构申请。
2. 寻址阶段：取得了使用权的主模块通过总线访问本次要访问的从模块
3. 传输阶段：主模块和从模块进行数据交换
4. 结束阶段：主模块让出总线使用权。</p>
<h4 id="632-同步定时方式">6.3.2 同步定时方式</h4>
<p>系统采用一个统一的时钟信号来协调发送和接收双方的传送定时关系。产生相等的间隔，每个间隔构成一个总线周期，在一个总线周期中，发送方和接收方可以进行一次数据传送。
优点：传送速度快，具有较高的传输速率；总线控制逻辑简单
缺点：主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差。</p>
<h4 id="633-异步定时方式">6.3.3 异步定时方式</h4>
<p>没有同一的时钟或固定的时间间隔，完全依靠双方相互发送握手信号。
通常，把交换信息的两个部件分为主设备和从设备，主设备提出交换信息的“请求”信号，从设备发出“回答”信号</p>
<ul>
<li>优点：总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合。</li>
<li>缺点：比同步控制方式稍微复杂一些，速度比同步定时方式慢</li>
</ul>
<p>根据请求和回答信号是否互锁，又分为3种类型：</p>
<ol>
<li>不互锁方式：主设备发出请求信号后，不必等到接到从设备的回答信号，而是经过一段时间后，便撤销请求信号。从设备在接到请求信号后，发出回答信号，并在一段时间后，自动撤销回答信号。</li>
<li>半互锁方式：主设备发出请求信号后，必须等待从设备发出回答信号，才能撤销请求信号，有互锁。从设备在接到请求信号后，发出回答信号，不必等待主设备的请求信号撤销，而是隔一段时间自动撤销。</li>
<li>全互锁方式：主设备发出请求信号后，必须在从设备回答后，才能撤销。从设备发出回答信号后，必须等主设备请求信号撤销后，才能撤销。</li>
</ol>
<h3 id="64-总线标准">6.4 总线标准</h3>
<h4 id="641-常见的总线标准">6.4.1 常见的总线标准</h4>
<ol>
<li>ISA总线，Industry Standard Architecture，工业标准体系结构总线，是最早出现的微型计算机的系统总线标准，应用在IBM的AT机上。</li>
<li>EISA总线，扩展的ISA总线，为配合32位CPU设计的总线扩展标准，对ISA完全兼容。</li>
<li>VESA总线，32位标准的计算机局部总线，是针对多媒体PC要求高速传送活动图像的大量数据应运而生的。</li>
<li>PCI总线(Peripheral Component Interconnect，外部设备互连总线)，是高性能的32位或64位总线，是专为高度集成的外围部件、扩充插板和处理器/存储器系统而设计的互联机制（显卡、声卡、网卡）。支持即插即用，是一个与处理器时钟无关的高速外围总线，属于局部总线。</li>
<li>PCI-Express：串行传输</li>
<li>AGP，视频接口标准，连接主存和图形存储器，局部总线。
7.RS-232C总线，串行通信总线标准</li>
<li>USB总线，通用串行总线，设备总线，即插即拔</li>
<li>PCMCIA，小型的用于扩展功能的差错，即插即用</li>
<li>IDE总线，是一种IDE接口磁盘驱动器接口类型，硬盘和光驱通过IDE接口与主板连接。</li>
<li>SCSI小型计算机系统接口，用于计算机和智能设备（硬盘、光驱）系统级接口的独立处理器标准
12.SATA串行高级技术附件，基于行业标准的串行硬件驱动接口，硬盘接口规范。</li>
</ol>
<p>并行总线因为涉及到多条线之间数据同步的问题，所以速度其实是不如串行总线快的。</p>
<h2 id="第7章-输入输出系统">第7章 输入/输出系统</h2>
<h3 id="71-io系统基本概念">7.1 I/O系统基本概念</h3>
<h4 id="712-io控制方式">7.1.2 I/O控制方式</h4>
<p>基本的控制方式有4种：</p>
<ol>
<li>程序查询方式：由CPU通过程序不断查询I/O设备是否已经做好准备，从而控制I/O设备与主机交换信息。</li>
<li>程序中断方式：只在I/O设备准备就绪并向CPU发出中断请求时才予以响应。</li>
<li>DMA方式：主存和I/O设备之间有一条直接数据通路，当主存和I/O设备交换信息时，无需调用中断服务程序。</li>
<li>通道方式：在系统中设有通道控制部件，每个通道都挂接若干外设，主机在执行I/O命令时，只需要启动有关通道，通道将执行通道程序，从而完成I/O操作。</li>
</ol>
<h3 id="72-外部设备">7.2 外部设备</h3>
<p>除主机之外，能直接或间接与计算机交换信息的装置。</p>
<h4 id="722-输出设备">7.2.2 输出设备</h4>
<ol>
<li>显示器
吸纳是存储器VRAM：也称刷新存储器，为了不断提高刷新图像的信号，必须把一帧图像信息存储在刷新存储器中。
VRAM容量=分辨率*灰度级位数
VRAM带宽=分辨率*灰度级位数*帧频</li>
</ol>
<h4 id="723-外存储器">7.2.3 外存储器</h4>
<p>磁盘存储器</p>
<ul>
<li>平均存取时间=寻道时间（磁头移动道目的磁道）、旋转延迟时间（磁头定位到所在扇区）和传输时间（传输数据所花费的时间）3个部分构成。</li>
<li>数据传输率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。假设磁盘转速为r（转/秒），每条磁道容量为N个字节，则数据传输率为Dr=r/N.</li>
</ul>
<p>磁盘阵列
RAID通过使用多个磁盘，提高了传输率；通过在多个磁盘上并行存取来大幅提高存储系统的数据吞吐量；通过镜像功能，可以提高安全可靠性；通过数据校验，可以提供容错能力。</p>
<p>一个汉字内码在主存中占用2个字节，输出的字形码16*16点阵占用32个字节。</p>
<p>在字符显示器中的VRAM存放ASCII码以显示字符。</p>
<h3 id="73-io接口">7.3 IO接口</h3>
<p>CPU同外设之间的信息传送实质上是对接口中的某些寄存器（即端口）进行读或写，如传输数据是对数据端口DBR进行读写操作。
接口与端口不同，端口是指接口电路中可以进行读/写的寄存器，若干个端口加上相应的控制逻辑才可以组成接口。</p>
<ul>
<li>内部接口：与系统总线相连，实质上是与内存、CPU相连，数据的传输方式只能是并行传输。</li>
<li>外部接口：通过接口电缆与外设相连，可能是串行方式，所以IO接口需要具有串/并转换功能。</li>
</ul>
<h4 id="734-io端口及其编址">7.3.4 IO端口及其编址</h4>
<p>每一个端口对应一个端口地址</p>
<ol>
<li>统一编址：又称为存储器映射编址，是指把IO端口当作存储器的单元进行地址分配。不用专门的输入输出指令，用统一的访存指令即可访问IO端口。但是占用了存储器地址会使内存容量变小，且利用存储器编址的IO设备进行数据输入/输出操作，执行速度较慢。</li>
<li>独立编址：又称为IO映射方式，即IO端口地址与存储器地址无关，独立编址CPU需要设置专门的输入/输出指令访问端口。优点是程序清晰，缺点是输入/输出指令横扫，一般只能对端口进行传送操作，控制比较复杂。</li>
</ol>
<h3 id="74-io方式">7.4 I/O方式</h3>
<p>前两者更依赖于CPU中程序指令的执行。</p>
<h4 id="741-程序查询方式">7.4.1 程序查询方式</h4>
<p>信息交换的控制完全由主机执行程序实现，程序查询方式接口中设置一个数据缓冲寄存器（数据端口）和一个设备状态寄存器（控制端口）。当主机进行I/O操作时，首先发出询问信号，读取设备的状态并根据设备状态决定下一步操作究竟是进行数据传送还是等待。</p>
<p>工作流程：</p>
<ol>
<li>CPU执行初始化程序，并预置传送参数。</li>
<li>向I/O接口发出命令字，启动I/O设备。</li>
<li>从外设接口读取其状态信息。</li>
<li>CPU不断查询I/O设备状态，直到外设准备就绪</li>
<li>传送一次数据。</li>
<li>修改地址和计数器参数</li>
<li>判断传送是否结束，若没有结束转第3步，直到计数器为0.</li>
</ol>
<p>CPU与I/O串行工作，一旦启动I/O，必须停止现行程序的运行，并在现行程序中插入一段程序。
CPU在信息传送过程中要花费很多时间用于查询和等待，而且一段时间内只能和一台外设交换信息，效率大大降低。</p>
<h4 id="742-程序中断方式">7.4.2 程序中断方式</h4>
<p>程序中断是指在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊请求，CPU暂时中止现行程序，而转去对这些异常情况或特殊请求进行处理，在处理完毕后又自动返回到现行程序的断点处，继续执行原程序。</p>
<h5 id="内中断和外中断">内中断和外中断</h5>
<p>根据中断源的不同，可以将中断源分为内中断和外中断两种。
每个中断源向CPU发出中断请求的时间是随机的。为了记录中断事件并区分不同的中断源，中断系统需对每个中断源设置中断请求标记触发器INTRODUCE，当其状态为1时，表示中断源有请求。这些触发器可组成中断请求标记寄存器，该寄存器可集中在CPU中，也可分散在各个中断源中。</p>
<ul>
<li>
<p>外中断：狭义上的中断，来自处理器和内存之外的部件引起的中断，包括IO设备发出的IO中断、外部信号中断（如Ctrl+C、ESC等），以及各种定时器引起的时钟中断。</p>
</li>
<li>
<p>内中断：又称异常，主要指在处理器和内存内部产生的中断。包括程序运算引起的各种错误，如地址非法、校验错、页面失效、存取访问控制错（访存时缺页）、算术操作溢出、数据格式非法、除数为0、非法指令、用户程序执行特权指令、分时系统中的时间片中断以及用户态到核心态的切换。</p>
</li>
<li>
<p>硬件中断：通过外部硬件产生的中断，属于外中断</p>
</li>
<li>
<p>软件中断：通过某条指令产生的中断，可以编成实现，属于内中断。</p>
</li>
<li>
<p>非屏蔽中断：一种硬件中断，不可屏蔽中断请求NMI控制，不受中断标志位IF的影响，即使在关中断（IF=0）的情况下也会被响应。</p>
</li>
<li>
<p>可屏蔽中断：也是一种硬件中断，通过中断请求标记触发器INTRODUCE控制，且受中断标志位IF的影响，在关中断情况下不接收中断请求。
一般而言，只要是延迟也不会有太大影响的（比如打印机等外设）都是可以屏蔽的。如果延迟会造成重大印象的（比如断电）那就不可以屏蔽
<a href="https://bbs.pediy.com/thread-155667.htm" target="_blank" rel="noopener noreffer">软件中断是否可以被屏蔽</a></p>
</li>
</ul>
<h5 id="中断判优">中断判优</h5>
<p>中断系统在一瞬间只能够响应一个中断源的请求，如果有多个中断源同时请求，需要通过中断判优逻辑确定响应哪个中断源的请求。</p>
<ul>
<li>硬件实现：硬件排队器</li>
<li>软件实现：查询程序</li>
</ul>
<p>CPU响应中断必须满足以下3个条件：</p>
<ol>
<li>中断源有中断请求</li>
<li>CPU允许中断及开中断</li>
<li>一条指令执行完毕，且没有更紧迫的任务</li>
</ol>
<p>中断隐指令：CPU响应中断后，经过某些操作，转去执行中断服务程序（由硬件直接实现）</p>
<p>工作流程：</p>
<ol>
<li>关中断。处理器响应中断后，首先要保护程序的现场状态。</li>
<li>保存断点。为了保证中断服务程序执行完毕后能正确地返回原来的程序，必须将原来程序的断点保存起来。</li>
<li>引出中断服务程序。（实质上是取出中断服务程序的入口地址，中断向量，然后送入程序计数器中）可以用硬件向量法和软件查询法寻找入口地址</li>
<li>保存现场和屏蔽字。进入中断服务程序后首先要保存现场，现场信息一般指的是程序状态字、中断屏蔽器和CPU中某些寄存器的内容</li>
<li>开中断。允许中断嵌套</li>
<li>执行中断服务程序。这是中断系统的核心</li>
<li>关中断。保证恢复现场和屏蔽字时不被打断</li>
<li>开中断、中断返回。中断服务程序的最后一条指令是中断返回指令，使其返回原程序的断点处，以便继续执行原程序。</li>
</ol>
<p>1-3是中断隐指令（硬件自动完成），4-9由中断服务程序完成。</p>
<h5 id="中断屏蔽技术">中断屏蔽技术</h5>
<p>主要用于多重中断，要求CPU具备多重中断的能力</p>
<p>条件：</p>
<ol>
<li>在中断服务程序中提前设置开中断指令。</li>
<li>优先级别高的中断源有权中断优先级别低的中断源</li>
</ol>
<p>而每个中断源都有一个屏蔽触发器，1表示屏蔽该中断源的请求，0表示正常申请，所有屏蔽触发器组合在一起，便构成一个屏蔽字寄存器，屏蔽字寄存器的内容就是屏蔽字。</p>
<p>参见例题
<img
        class="lazyload"
        src="/svg/loading.min.svg"
        data-src="https://user-images.githubusercontent.com/21279827/67155778-d7303880-f347-11e9-991a-f37a5701461a.png"
        data-srcset="https://user-images.githubusercontent.com/21279827/67155778-d7303880-f347-11e9-991a-f37a5701461a.png, https://user-images.githubusercontent.com/21279827/67155778-d7303880-f347-11e9-991a-f37a5701461a.png 1.5x, https://user-images.githubusercontent.com/21279827/67155778-d7303880-f347-11e9-991a-f37a5701461a.png 2x"
        data-sizes="auto"
        alt="https://user-images.githubusercontent.com/21279827/67155778-d7303880-f347-11e9-991a-f37a5701461a.png"
        title="例题" /></p>
<h4 id="743-dma方式">7.4.3 DMA方式</h4>
<p>DMA方式是一种完全由硬件进行成组信息传送的控制方式。具有程序中断方式的优点，即在数据准备阶段，CPU与外设并行工作。
DMA方式是在外设与内存之间开辟一条“直接数据通道”，信息传送不再经过CPU，降低了CPU在传送数据时的开销。（省去了保护、恢复CPU现场等繁琐操作）</p>
<p>有一个对数据传送过程进行控制的硬件，称为DMA控制器。当I/O设备需要进行数据传送时，通过DMA控制器向CPU提出DMA传送请求，CPU响应后将让出系统总线，由DMA控制器接管总线进行数据传送。
过程：</p>
<ol>
<li>接收外设发出的DMA请求，并向CPU发出总线请求</li>
<li>CPU响应此总线请求，发出总线响应信号，接管总线控制权，进入DMA操作周期</li>
<li>确定传送数据的主存单元地址及长度，并能自动修改主存地址计数和传送长度计数</li>
<li>规定数据在主存和外村间的传送方向，发出读写等控制信号，执行数据传送操作</li>
<li>向CPU报告DMA操作的结束。</li>
</ol>
<p>DMA传送方式：主存和DMA控制器之间有一条数据通路，因此主存和IO设备进行数据交换的时候可以不通过CPU。但是IO设备与CPU同时访存的时候可能引起冲突，3种方式：</p>
<ol>
<li>停止CPU访问主存。DMA向CPU发送一个信号，要求CPU放弃地址线、数据线和有关控制线的使用权，DMA在获得总线使用权之后开始数据传送。之后交回。在传送过程中，CPU基本处于不工作状态。</li>
<li>DMA与CPU交替访存。适用于CPU的工作周期比主存存取周期长的情况。例如CPU工作周期1.2us，主存存取周期0.6us，可以将一个CPU周期分为C1周期和C2周期，C1周期专供DMA访存，C2周期专供CPU访存，总线控制权通过C1和C2分时控制</li>
<li>周期挪用/窃取：前两种方式的折中。IO有DMA请求时有三种情况。第1种CPU不再访存，未冲突；第2种，CPU正在访存，必须等待存取周期结束后，CPU再将总线占有权让出；第3种IO和CPU同时请求访存，这时候CPU暂时放弃总线使用权，让IO设备挪用一个或几个存取周期。</li>
</ol>
<p>DMA传送过程：预处理、数据传送和后处理</p>
<ol>
<li>预处理：CPU完成一些必要的准备工作，执行I/O指令以测试I/O设备状态，向DMA控制器的有关寄存器置初值、设置传送方向、启动该设备等。然后，CPU继续执行原来的程序，直到I/O设备准备号发送的数据或接受的数据，此时I/O设备向DMA控制器发送DMA请求，再由DMA控制器向CPU发送总线请求，用以传送数据</li>
<li>数据传送：DMA数据传送可以以单字节或是数据块为基本单位，对于以数据块为单位的传送（如硬盘），DMA占用总线后的输入输入都是通过循环来实现的。这一阶段全部由DMA（硬件）控制</li>
<li>后处理：DMA控制器向CPU发送中断请求，CPU执行中断服务程序做DMA结束处理，包括校验食人鱼主存的数据是否正确、测试传输过程是否出错以及决定是否继续使用DMA传送其他数据块。</li>
</ol>
<p>DMA请求的优先级高于中断请求。</p>
<p><a href="https://blog.csdn.net/fan_zhen_hua/article/details/4585942" target="_blank" rel="noopener noreffer">DMA内容的优秀博客</a></p>
<h4 id="比较">比较</h4>
<h5 id="dma方式和中断方式的区别">DMA方式和中断方式的区别</h5>
<ol>
<li>中断方式是程序的切换，需要保护和恢复现场；DMA方式除了预处理和后处理，其他时候不占用CPU的任何资源</li>
<li>对中断请求的响应只能发生在每条指令执行完毕时（即指令的执行周期之后）；而对DMA请求的响应可以发生在每个机器周期结束时（取值、间址、执行周期之后均可），只要CPU不占用总线就可以被响应。</li>
<li>中断传送过程需要CPU的干预；而DMA传送过程不需要CPU的干预，故数据传输速率非常高，适合高速外设的成组数据传送。</li>
<li>DMA请求的优先级高于中断请求。</li>
<li>中断方式具有对异常事件的处理能力，而DMA方式仅局限于传送数据块的IO操作</li>
<li>从数据传送来看，中断方式靠程序传送，DMA方式靠硬件传送。</li>
</ol>
</div><div class="post-footer" id="post-footer">
    <div class="post-info">
        <div class="post-info-line">
            <div class="post-info-mod">
                <span>更新于 2021-03-09</span>
            </div>
            <div class="post-info-license"></div>
        </div>
        <div class="post-info-line">
            <div class="post-info-md"></div>
            <div class="post-info-share">
                <span><a href="javascript:void(0);" title="分享到 Twitter" data-sharer="twitter" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述" data-hashtags="考研,计算机组成"><i class="fab fa-twitter fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Facebook" data-sharer="facebook" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-hashtag="考研"><i class="fab fa-facebook-square fa-fw"></i></a><a href="javascript:void(0);" title="分享到 WhatsApp" data-sharer="whatsapp" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述" data-web><i class="fab fa-whatsapp fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Line" data-sharer="line" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述"><i data-svg-src="/lib/simple-icons/icons/line.min.svg"></i></a><a href="javascript:void(0);" title="分享到 微博" data-sharer="weibo" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述"><i class="fab fa-weibo fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Myspace" data-sharer="myspace" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述" data-description=""><i data-svg-src="/lib/simple-icons/icons/myspace.min.svg"></i></a><a href="javascript:void(0);" title="分享到 Blogger" data-sharer="blogger" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述" data-description=""><i class="fab fa-blogger fa-fw"></i></a><a href="javascript:void(0);" title="分享到 Evernote" data-sharer="evernote" data-url="http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/" data-title="计算机组成-概述"><i class="fab fa-evernote fa-fw"></i></a></span>
            </div>
        </div>
    </div>

    <div class="post-info-more">
        <section class="post-tags"><i class="fas fa-tags fa-fw"></i>&nbsp;<a href="/tags/%E8%80%83%E7%A0%94/">考研</a>,&nbsp;<a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">计算机组成</a></section>
        <section>
            <span><a href="javascript:void(0);" onclick="window.history.back();">返回</a></span>&nbsp;|&nbsp;<span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav"><a href="/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/" class="prev" rel="prev" title="操作系统-概述"><i class="fas fa-angle-left fa-fw"></i>操作系统-概述</a>
            <a href="/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/" class="next" rel="next" title="计算机网络-概述">计算机网络-概述<i class="fas fa-angle-right fa-fw"></i></a></div>
</div>
<div id="comments"><div id="utterances"></div><noscript>
                Please enable JavaScript to view the comments powered by <a href="https://utteranc.es/">Utterances</a>.
            </noscript></div></article></div>
            </main><footer class="footer">
        <div class="footer-container"><div class="footer-line">由 <a href="https://gohugo.io/" target="_blank" rel="noopener noreffer" title="Hugo 0.87.0">Hugo</a> 强力驱动 | 主题 - <a href="https://github.com/dillonzq/LoveIt" target="_blank" rel="noopener noreffer" title="LoveIt 0.2.10"><i class="far fa-kiss-wink-heart fa-fw"></i> LoveIt</a>
                </div><div class="footer-line"><i class="far fa-copyright fa-fw"></i><span itemprop="copyrightYear">2021</span><span class="author" itemprop="copyrightHolder">&nbsp;<a href="https://github.com/wtysos11/" target="_blank">Carlo Wu</a></span>&nbsp;|&nbsp;<span class="license"><a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">CC BY-NC 4.0</a></span></div>
        </div>
    </footer></div>

        <div id="fixed-buttons"><a href="#" id="back-to-top" class="fixed-button" title="回到顶部">
                <i class="fas fa-arrow-up fa-fw"></i>
            </a><a href="#" id="view-comments" class="fixed-button" title="查看评论">
                <i class="fas fa-comment fa-fw"></i>
            </a>
        </div><link rel="stylesheet" href="/lib/katex/katex.min.css"><link rel="stylesheet" href="/lib/katex/copy-tex.min.css"><script type="text/javascript" src="/lib/smooth-scroll/smooth-scroll.min.js"></script><script type="text/javascript" src="/lib/lazysizes/lazysizes.min.js"></script><script type="text/javascript" src="/lib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="/lib/sharer/sharer.min.js"></script><script type="text/javascript" src="/lib/katex/katex.min.js"></script><script type="text/javascript" src="/lib/katex/auto-render.min.js"></script><script type="text/javascript" src="/lib/katex/copy-tex.min.js"></script><script type="text/javascript" src="/lib/katex/mhchem.min.js"></script><script type="text/javascript">window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":100},"comment":{"utterances":{"darkTheme":"github-dark","issueTerm":"pathname","label":"","lightTheme":"github-light","repo":"wtysos11/hugo-blog-comment"}},"math":{"delimiters":[{"display":true,"left":"$$","right":"$$"},{"display":true,"left":"\\[","right":"\\]"},{"display":false,"left":"$","right":"$"},{"display":false,"left":"\\(","right":"\\)"}],"strict":false}};</script><script type="text/javascript" src="/js/theme.min.js"></script></body>
</html>
