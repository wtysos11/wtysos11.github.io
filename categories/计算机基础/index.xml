<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算机基础 on 实践出真知</title>
    <link>http://wtysos11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/</link>
    <description>Recent content in 计算机基础 on 实践出真知</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sun, 21 Jan 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://wtysos11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43;复现基础排序算法</title>
      <link>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 12 Mar 2021 09:56:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210312_c&#43;&#43;%E5%A4%8D%E7%8E%B0%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>复习一下基本的排序算法&#xA;快速排序 Link to heading 时间复杂度O(nlogn)，不稳定 这个写法是我刻在DNA里的，应该没什么大问题，除了比较抽象之外都还好。&#xA;#include &amp;lt;string&amp;gt; #include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; using namespace std; void quickSort(vector&amp;lt;int&amp;gt;&amp;amp; arr,int low,int high){ if(low==high) return cout&amp;lt;&amp;lt;low&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;high&amp;lt;&amp;lt;endl; int i = low; int j = high; int mid = (i+j)/2; int v = arr[mid]; do{ while(arr[i]&amp;lt;v) i++; while(arr[j]&amp;gt;v) j--; if(i&amp;lt;=j){ int temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; i++,j--; } cout&amp;lt;&amp;lt;&amp;#34;inside&amp;#34;&amp;lt;&amp;lt;i&amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;j&amp;lt;&amp;lt;endl; }while(i&amp;lt;=j); if(i&amp;lt;high){ quickSort(arr,i+1,high); } if(j&amp;gt;low){ quickSort(arr,low,j-1); } } int main(void){ vector&amp;lt;int&amp;gt; arr{2,5,3,4,1,9,7}; quickSort(arr,0,arr.</description>
    </item>
    <item>
      <title>分布式系统-CAP理论十二年回顾：规则变了</title>
      <link>http://wtysos11.github.io/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/</link>
      <pubDate>Wed, 10 Mar 2021 14:21:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210310_cap%E7%90%86%E8%AE%BA%E5%8D%81%E4%BA%8C%E5%B9%B4%E5%9B%9E%E9%A1%BE_%E8%A7%84%E5%88%99%E5%8F%98%E4%BA%86/</guid>
      <description>该文的阅读感想&#xA;CAP理论断言，最多只能满足数据一致性、可用性、分区容忍性这三要素中的两个。&#xA;REF: What is CAP&#xA;数据一致性（consistency）：所有节点访问同一份最新的数据副本。就是说所有副本之间互相同步，在任何时候保持着同一个状态 高可用性（availability）：每一个请求最终都会成功。对节点的任何读写请求都不会被拒绝。 网络容忍性(Network Partition Tolerance)：当网络断开连接的时候，系统能够继续运行。即使某些或者所有的节点都不能够互相通信。一般指的是跨区域的数据库，此时很难保证两个数据库之间相互连接。 通过显式处理分区情景，系统设计师可以做到优化数据一致性和可用性，进而取得三者的平衡。我自己对这句话的理解是这样的，假设现在存在两个节点N1和N2，所有更新操作都会互相通知，显然可以满足数据一致性C。当两者不能互相连接的时候，有三种情况：1. 两者继续服务，更新数据，此时数据必定不一致，就是放弃了C来换去A，同时维护P；2.N1和N2都不服务，放弃可用性来取得C和P。3. 只有N1服务，此时数据一致性得到部分保留，可用性得到部分保留，同时维护了P。我觉得第三种就是这种所谓的权衡。&#xA;作者指出，三选二这样的语句本身是不严谨的。实际上，只有在分区存在的前提下呈现完美的数据一致性和可用性这种很少见的情况是CAP理论所不允许出现的。因此在实际设计中有着很多的变通方案和灵活度。&#xA;三选二公式的误导性 Link to heading 分区很少发生，那么在系统不存在分区的情况下没理由去牺牲C和A。 C和A之间的取舍可以在同一系统中以非常细小的粒度反复发生，每一次的决策可能因为具体的操作，或者牵涉到特定的数据或用户而有所不同。 这三种性质都可以在程度上衡量，并不是非黑即白的有或者无，可用性是一个百分比，一致性也分很多级别，分区也有不同的定义。 CAP在大多数时候允许完美的C和A，那在P出现的时候，准备一些策略去处理其影响即可，包括：&#xA;探知分区发生 进入显式的分区模式以限制某些操作 启动恢复过程以恢复数据一致性并补偿分区期间发生的错误 ACID、BASE和CAP Link to heading ACID和BASE分处一致性-可用性分布图谱的两极&#xA;ACID Link to heading 数据库的传统设计思路，注重一致性，写入数据库教材的经典原则。这也是事务transaction的基本性质&#xA;原子性atom：操作要么全部成功，要么全部失败。所有的系统都受惠于原子性，这是没有理由改变的，可以极大简化分区恢复 一致性consistency：事务不能破坏任何数据库规则，如键的唯一性。（CAP的C仅指单一副本上的一致性，因此是其子集）ACID一致性不能在恢复过程中保持，因此分区恢复的时候要考虑重建一致性。 隔离性Isolation:数据库允许多个并发事务对其数据进行同时读写和修改的能力。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。这也是CAP理论的核心，如果系统要求ACID隔离性，那在分区P期间，最多可以在分区的一侧维持操作。事务的可串行性要求全局的通信，因此在分区的情况下不能成立。只有在分区恢复时进行补偿，在分区前后保持一个较弱的正确性定义是可行的。 持久性Durability：事务处理结束后，对数据的修改就是永久的。牺牲持久性也没有意义。 CAP和延迟的联系 Link to heading CAP理论的经典解释是忽略网络延迟的，但实际中延迟和分区密切相关。在操作的间隙，系统需要作出决策：&#xA;取消操作，降低系统可用性。或是 继续操作，以冒险损失系统一致性为代价 依靠多次尝试通信来达成一致性，比如Paxos算法或者两阶段事务提交，仅仅是推迟了决策时间。无限期地尝试下去，本身就是选择一致性牺牲可用性的表现。&#xA;从延迟的角度抓住了设计的核心问题：分区两侧是否在无通信的情况下继续操作？&#xA;从这个实用的观察角度导出两条推论：&#xA;分区并不是全体节点的一致见解，因为有的节点检测到分区，有的节点没有 检测到分区的节点会进入到分区模式，这是优化C和A的核心环节。 CAP之惑 Link to heading 对于可用性和一致性的作用范围的误解比较严重。&#xA;离线模式正在变得越来越重要，比如HTML5的客户端持久化存储特性。这些离线系统在C和A中会更倾向于A，此时就不得不在长时间处于分区状态后进行恢复。&#xA;“一致性的作用范围”其实反映了这样一种观念，即在一定的边界内状态是一直的，但超出了边界就无从谈起。比如在一个主分区内可以保证完备的一致性和可用性，而在分区外服务是不可用的。&#xA;管理分区 Link to heading 由于基本操作是原子的，因此分区检测一定发生在两个事务之间，然后在分区结束后执行分区恢复来恢复一致性。&#xA;当系统进入分区模式，有两种可行的策略。其一是限制部分操作，因此会削弱可用性；其二是额外记录一些有利于后面分区恢复的操作信息。系统可以通过持续尝试恢复通信来察觉分区何时结束。&#xA;哪些操作可以执行？ Link to heading 决定限制哪些操作，主要取决于系统需要维持哪几项不变性约束。</description>
    </item>
    <item>
      <title>计算机网络-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:28:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</guid>
      <description>第一章 计算机网络体系结构 Link to heading 1.1 计算机网络概述 Link to heading 分类&#xA;按分布范围可以分为广域网、城域网和局域网 按拓扑结构分类可以分为星形网络、总线形网络、环形网络和网状形网络。 按交换技术可以分为电路交换网络（传统电话网络）、报文交换网络、分组交换网络（也成为包交换网络） 1.1.6 计算机网络的性能指标 Link to heading 带宽bandwidth，表示网络的通信线路所能传输数据的能力，单位是比特每秒。&#xA;时延delay，指数据从网络的一端传送到另一端所需要的总时间，由四个部分构成：发送时延、传播时延、处理时延和排队时延。&#xA;发送时延：又称传输时延，结点将分组的所有比特推向传输链路所需要的时间，即从发送分组的第一个比特算起，到该分组最后一个比特发送完毕所需的时间。发送时延=分组长度/信道宽度 传播时延：电磁波在信道中传播一定的距离需要花费的时间，即一个比特从链路的一端到另一端传播所需的时间，传播时延=信道长度/电磁波在信道上的传播速率。 处理时延：数据在交换节点为存储转发而进行的一些必要的处理所花费的时间。 排队时延：分组在进入路由器中先在输入队列进行排队等待处理，以及确定转发端口后在输出队列等待转发。 时延带宽积：若发送端连续发送数据，在发送的第一个比特即将到达终点时，表示发送端已经发出的比特数，时延带宽积=传播时延*信道带宽&#xA;往返时延：Round-trip time,RTT。表示从发送端发送数据开始，到发送端收到来自接收端的确认总共经历的时延。&#xA;吞吐量throughput：表示在单位时间内通过某个网络的数据量，受网络的带宽或网络的额定速率限制。&#xA;速率：网络中的速率指链接在计算机网络上的主机在数字信道上传输数据的速率，也称为数据率或比特率，单位是b/s，或bps。通常把最高的数据率称为带宽。&#xA;错题 Link to heading 计算机网络从逻辑功能上可以分为通信子网和资源子网。 通信子网指网络中实现网络通信功能的设备及其软件的集合，包括通信设备、网络通信协议、通信控制软件，是网络的内层，负责信息的船速。包括中继器、集线器、网桥、路由器、网关等硬件设备。 资源子网负责全网的数据处理业务，负责向网络用户提供各种网络资源与网络服务，资源子网主要由计算机系统、终端、联网外部设备、各种软件资源和信息资源等组成。 广域网和局域网之间的差异不仅在于它们所覆盖范围的不同，还在于它们所采用的协议和网络技术的不同。广域网使用点对点等技术，局域网使用广播技术。 网络设备，中继器和桥接器通常是用于局域网的物理层和数据链路层的连网设备。局域网接入广域网主要通过路由器来实现。 网络的拓扑结构主要指通信子网的拓扑结构。通信子网包括物理层、数据链路层、网络层。集线器、交换机和路由器分别工作在物理层、链路层和网络层。 广播式网络共享广播信道，通常是局域网的一种通信方式，局域网工作在数据链路层，故不需要网络层，因而也没有路由选择的问题。但是数据链路层使用物理层的服务必须通过服务访问点来实习。 1.2 计算机网络体系结构与参考模型 Link to heading 分层的基本原则：&#xA;每一层实现一种相对独立的功能，降低大系统的复杂度。 各层之间界面自然清晰，易于理解，相互交流尽可能少。 各层功能的精确定义独立于具体的实现方法，可以采用最合适的技术来实现。 保持下层对上层的独立性，上层单向使用下层提供的服务。 整个分层结构应能促进标准化工作。 一个报文(PDU) = 数据部分(SDU)+控制信息部分(PCI)&#xA;服务数据单元SDU：为完成用户所要求的功能而应传送的数据。第n层的服务数据单元记为n-SDU。 协议控制信息PCI：控制协议操作的信息。 协议数据单元PDU：物理层的PDU叫比特，链路层的PDU叫帧，网络层的PDU叫分组，传输层的PDU叫报文。 各层间传输数据的时候，把第n+1层收到的PDU作为第n层的SDU，加上PCI后进行发送。&#xA;层次结构的定义：&#xA;第n层的实体不仅要使用第n-1层的服务，实现自身定义的功能，还要向第n+1层提供本层的服务。 最底层只提供服务，中间即是服务使用者、又是服务提供者，最上层面向用户提供服务。 1.2.2 计算机网络协议、接口、服务的概念 Link to heading 协议是规则的集合，由语法、语义、同步三部分组成。&#xA;语法：规定了传输数据的格式 语义：规定了所要完成的功能，即需要发出何种控制信息、完成何种动作以及做出何种应答。 同步：规定了执行各种操作的条件、时序关系等，即事件实现顺序的详细说明。 接口：接口是同一结点内相邻两层间交换信息的连接点，是一个系统的内部规定。在典型的接口上，同一结点相邻两层的实体通过服务访问点(Service access point,SAP)进行交互。服务是通过服务访问点提供给上层使用的。</description>
    </item>
    <item>
      <title>计算机组成-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:26:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E6%A6%82%E8%BF%B0/</guid>
      <description>第1章 计算机系统概述 Link to heading 冯诺依曼结构：运算器、控制器、存储器、输入设备和输出设备五大部件组成。现代计算机一般把控制器和运算器集成在一个芯片上，合称为中央处理器。 现代计算机一般以存储器为中心，使I/O操作尽可能绕过CPU，直接在I/O设备与存储器间完成，从而提高系统的整体运行效率。&#xA;重要设备：&#xA;地址寄存器MAR：存放访存地址，经过地址译码后可以找到所选的存储单元。 数据寄存器MDR：是主存和其他部件的中介机构，用于暂存要从存储器中读或写的信息，失序控制逻辑用于产生存储器操作所需的各种时序信号。位数和存储字长相等。 MAR和MDR虽然是存储器的一部分，但是确实在现代CPU内的。&#xA;运算器：核心是ALUM，包含若干通用寄存器用于暂存操作数和中间结果。另外还有程序状态寄存器PSW，用来保留各类运算指令或测试指令的结果的各类状态信息，以表征系统运行状态。 控制器：由程序计数器PC、指令寄存器IR、控制单元CU组成。PC存放当前欲执行指令的地址。IR用来存放当前的指令，内容来自于主存的MDR。 CPU和主存储器构成主机，计算机中除去主机的其他硬件设备统称为外部设备。&#xA;系统软件：保证计算机系统高效、正确运行的基础软件，包括操作系统、数据库管理系统、语言处理程序、分布式软件系统、网络软件系统、标准库程序、服务性程序。 应用软件：用户为解决某个应用领域中的各类问题而编制的程序。 PS：DBMS和DBS是有区别的。DBMS是系统软件，而DBS是引入DBMS后的系统。&#xA;信息流程：&#xA;取指令：PC-&amp;gt;MAR-&amp;gt;M-&amp;gt;MDR-&amp;gt;IR 分析指令：OP(IR)-&amp;gt;CU 执行指令：Ad(IR)-&amp;gt;MAR-&amp;gt;M-&amp;gt;MDR-&amp;gt;ACC 1.2.5 计算机系统的多级层次结果 Link to heading 微程序机器层。硬件层，由机器硬件直接执行微指令。 传统机器语言层。机器层，由微程序解释机器指令系统。 操作系统层。由操作系统定义和解释软件指令，作为广义指令。以及机器指令组成。 汇编语言层。 高级语言层。 应用层。 层次之间，下层是上层的基础，上层是下层的扩展。&#xA;1.3 计算机的性能指标 Link to heading 机器字长：计算机进行一次整数运算所能处理的二进制数据的位数。 数据通路带宽：数据总线一次能并行传送信息的位数 贮存容量：主存储器所能存储信息的最大容量。MAR的位数反应了存储单元的个数，MDR的位数反应了可寻址范围的最大值。 吞吐量：系统在单位时间内处理请求的数目。 CPU时钟周期：CPU中最小的时间单位，每个动作至少需要一个时钟周期。 CPU时钟主频：CPU时钟周期的倒数。主频越高，完成指令的一个执行步骤所需要的时间越短。 CPI：指执行一条指令所需的时钟周期数 CPU执行时间= CPU周期数/主频=（指令条数*CPI）/主频 MIPS(million instructions per second)：每秒执行多少百万条指令。有MIPS=指令条数/(执行时间*10^6)=主频/CPI&#xA;MFLOPS，每秒执行多少百万次浮点运算，重要的性能判断标志。&#xA;平均指令周期 = 1/MIPS 平均每条指令的时钟周期数(CPI)=平均指令周期/CPU时钟周期=1/(MIPS*主频) 题目 17.C 解析：基准程序的CPI=2*0.5+3*0.2+4*0.1+5*0.2=3。计算机的主频为1.2GHz，即1200MHz，故该机器的MIPS=1200/3=400 18.D 解析：程序A的运行时间为100秒，除去CPU时间90秒，剩下10秒为I/O时间。CPU提速后运行基准程序A所耗费的时间T=90/1.5+10秒 19.D 解析：假设原来指令条数为x，那么原CPI就为20*f/x（注：f为CPU的时钟频率），经过编译优化后，指令条数减少到原来的70%，即指令条数为0.7x，而CPI增加到原来的1.2倍，即24*f/x，那么现在P在M上的执行时间就为：（指令条数*CPI）/f=(0.7x*24*f/x)/f=16.8秒 20.C 运行时间=指令数*CPI/主频。M1的时间=指令数*21.5，M2的时间=指令数*1/1.2，两者之比为(2/1.5):(1/1.2)=1.6&#xA;透明性：在计算机领域中，站在某一类用户的角度，如果感觉不到某个事物或属性的存在，则称“对该用户而言，某个事物或属性是透明的”。这与日常生活中透明的概念刚好相反。&#xA;例如，对于高级语言程序员而言，浮点数格式、乘法指令等这些语言的格式、数据如何在运算器中运算都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。&#xA;码距：任意两个合法码字之间最少变化的二进制位数，称为数据校验码的码距。&#xA;奇偶校验，最高位为校验位，剩下的是信息位</description>
    </item>
    <item>
      <title>操作系统-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:24:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/</guid>
      <description>整理磁盘时发现的408笔记&#xA;第一章 操作系统概述 Link to heading 1.1 操作系统的基本概念 Link to heading 操作系统是控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境的程序集合。&#xA;1.1.2 操作系统的特征 Link to heading 并发、共享、虚拟和异步，其中现代操作系统最基本的特征是并发和共享。&#xA;并发：两个或多个事件在同一时间间隔内发生。（并行是同一时刻内发生）单处理机环境的并发在微观上表现为程序分时交替执行，操作系统的并发性是通过分时得以实现的。 共享：系统中的资源可供多个并发执行的进程共同使用。 虚拟：将物理的实体变为若干逻辑上的对应物 异步：在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行是以不可预知的速度向前推进。 操作系统的接口：&#xA;命令接口：用户利用这些操作命令来组织和控制作业的执行。 程序接口：程序员用其来请求操作系统服务（系统调用） 命令接口分为联机命令接口和脱机命令接口。联机命令接口用于分时系统，脱机命令接口用于批处理系统。&#xA;程序接口由一组系统调用命令（广义指令）组成，包括图形接口等。 PS：系统调用是操作系统提供给应用程序使用内核功能的接口。库函数是高级语言中提供的与系统调用对应的函数（部分与系统调用无关），目的是隐藏访管指令的细节，更加抽象、透明。&#xA;1.2 操作系统的发展与分类 Link to heading 1.2.1 手工操作阶段（此阶段无操作系统） Link to heading 略过&#xA;1.2.2 批处理阶段 Link to heading 单道批处理系统：内存中始终保持一道作业 多道批处理系统：可以允许多个程序同时进入内存进行作业。&#xA;多道程序设计特点：&#xA;多道：计算机内存中同时存放多道相互独立的程序 宏观上并行：同时进入系统的多道程序都处于运行状态，即它们先后开始了各自的运行，但都未完成。 微观上串行：内存中的多道程序轮流占有CPU。 在分时系统中，时间片一定的时候，用户数量越多，每个用户分到的时间片就越少，响应时间自然就变长。&#xA;实时系统为了保证高响应时间，一般内存调度使用抢占式的优先级高者优先算法。&#xA;1.2.3 分时操作系统 Link to heading 分配时间片给进程。 实现分时系统最关键的问题是如何使用户能与自己的作业进行交互。&#xA;多道程序设计的基本特征： 引入多道程序设计后，程序的执行就失去了封闭性和顺序性&#xA;多道程序系统通过组织作业使CPU总有一个作业可以执行，从而提高了CPU的利用率、系统吞吐量和IO设备利用率，但是系统要付出额外的开销来组织作业和切换作业，所以开销会比单道程序系统更大。&#xA;1.3 操作系统的运行环境 Link to heading 用户态与核心态，使用访管指令进行切换，切换时会引起一次中断。 中断处理功能需要在核心态下进行。</description>
    </item>
    <item>
      <title>数据结构-概述</title>
      <link>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</link>
      <pubDate>Tue, 09 Mar 2021 14:21:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210309_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%A6%82%E8%BF%B0/</guid>
      <description>整理磁盘时发现考研408时自己的笔记&#xA;第一章 绪论 Link to heading 1.1 数据结构的基本概念 Link to heading 数据：信息的载体 数据元素：数据的基本单位。一个数据元素可由若干个数据项组成 数据对象：具有相同性质的数据元素的集合 数据类型：是一个值的集合和定义在此集合上一组操作的总称。原子类型：值不可再分的数据类型；结构类型：值可以再分解的若干类型；抽象数据类型：抽象数据组织和与之相关的操作。 抽象数据类型：ADT，指一个数学模型以及定义在该模型上的一组操作。 数据结构=逻辑结构+存储结构+数据的运算 1.1.2 数据结构的三要素 Link to heading 逻辑结构：指数据元素之间的逻辑关系，如集合、线性结构、树形结构、图状结构或网状结构 数据的存储结构：指数据结构在计算机中的表示，也称物理结构。包括顺序存储、链式存储、索引存储和散列存储。 数据的运算：施加在数据上的运算包括运算的定义和实现。 第2章 线性表 Link to heading 2.1 线性表的定义和基本操作 Link to heading 线性表是具有相同数据类型的n个数据元素的有限序列。 逻辑上，每个元素有且只有一个直接前驱，有且只有一个直接后继（表头表尾元素例外）&#xA;使用顺序存储的时候即为顺序表。 使用链式存储即为链表。&#xA;2.2 线性表的顺序表示 Link to heading 线性表的顺序存储又称为顺序表，是一组地址连续的存储单元。特点是表中元素的逻辑顺序与物理顺序相同。 PS：动态分配并不是链式存储，同样属于顺序存储结构，只是分配的空间大小可以在运行时决定。 最主要的特点是随机访问，而且逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量的元素。&#xA;插入，平均时间复杂度O(n) 删除，平均时间复杂度O(n) 按值顺序查找O(n)，二分可以到O(logn) 错题：线性表的顺序存储结构是一种顺序存取的存储结构。 这个是错误的，是随机存取的存储结构。顺序存取是一种读写方式，不是存储方式，有别于顺序存储。 PPS：表的元素从1开始计数，C中的数组从0开始计算。&#xA;题目： [2010真题]1. 设将n(n&amp;gt;1)个整数存放到1维数组R中。试设计一个在时间和空间两方面都尽可能高效的算法。将R中保存的序列循环左移p(0&amp;lt;p&amp;lt;n)个位置，即将R中的数据由(X0,X1,&amp;hellip;,Xn-1)变换为(Xp,Xp+1,&amp;hellip;,Xn-1,X0,X1,&amp;hellip;,Xp-1)。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度 [2011年真题]2.一个长度为L（L&amp;gt;=1）的升序序列S，处在L/2个位置的数被称为中位数。例如，若序列S1=（11,13,15,17,19），则S1的中位数是15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若S2=(2,4,6,8,20)，则S1和S2的中位数是11。现在由两个等长升序序列A和B，试设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列A和B的中位数。要求： (1)给出算法的基本思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;[2013年真题]3.已知一个整数序列A=(a0,a1,&amp;hellip;,an-1),其中0&amp;lt;=ai&amp;lt;n(0&amp;lt;i&amp;lt;n)。若存在ap1=ap2=&amp;hellip;=apm=x且m&amp;gt;n/2(0&amp;lt;=pk&amp;lt;n,1&amp;lt;=k&amp;lt;=m)，则称x为A的主元素。例如A=(0,5,5,3,5,7,5,5)，则5为主元素；又如A=(0,5,5,3,5,1,5,7)，则A中没有主元素。假设A中的n个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出A的主元素。若存在主元素，则输出该元素；否则输出-1。要求： (1)给出算法的基本设计思想 (2)根据设计思想，采用C或C++或java语言描述算法，关键之处给出注释 (3)说明你所设计算法的时间复杂度和空间复杂度&#xA;注释有感： 读注释的效果应当同读伪代码的效果一样 如果代码的内容无法直观表述，就需要写注释。 题目答案： 1.</description>
    </item>
    <item>
      <title>现代人工智能课程复习</title>
      <link>http://wtysos11.github.io/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Sat, 09 Jan 2021 14:14:04 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20210109_%E7%8E%B0%E4%BB%A3%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E8%AF%BE%E7%A8%8B%E5%A4%8D%E4%B9%A0/</guid>
      <description>中山大学研一上学期现代人工智能技术复习的相关资料，主要内容为神经网络基础知识，可能涉及到线性代数、概率论、线性模型、卷积神经网络和CV进展&#xA;距离度量，重点记忆Mahalanobis距离和Minkowski距离 过拟合 Link to heading 训练集误差减小的时候，测试集误差增大。 解决方案：正则化，给误差函数增加一个惩罚项（L1/L2）&#xA;概率论 Link to heading 全概率公式，P(A) = P(A|Bi)P(Bi) 贝叶斯公式，P(Bi|A) = P(ABi)/P(A)&#xA;贝叶斯概率 Link to heading 后验概率= 先验概率*似然函数&#xA;bootstrap，自助法，频率学派使用。假设原始数据集有N个数据，可以采取随机抽取N个点的做法来生成新的数据集（可重复，可缺失）。这样可以在多个产生的数据集中评估参数估计的结果。&#xA;高斯分布 Link to heading 一元与多元的表示&#xA;交叉验证 Link to heading 信息准则：AIC与BIC&#xA;决策论 Link to heading 或者说贝叶斯决策/贝叶斯推断&#xA;最小化错误分类率。对于二分类问题，降低错误发生的概率，即把类1分给类2与类2分给类1两个事件。 最小化期望损失。使用损失函数来量化错误分类的代价。 拒绝选项 判别器 Link to heading 概率分布 Link to heading 二项分布（伯努利分布） Link to heading E = p, V = p(1-p)&#xA;高斯分布 Link to heading 对于多元实值向量，使熵取最大值的是高斯分布&#xA;中心极限定理：&#xA;独立同分布的中心极限定理。当n个随机变量独立同分布且n足够大的时候，可以将独立同分布的随机变量之和当作正态变量。 对于要定义的高斯分布，其协方差的酥油特征值要严格大于零，不然不能被正确的归一化。如果一个或多个特征值为零，则该高斯分布将是奇异的，被限制在一个低维的子空间上。 高斯分布的局限性在于它是单峰的，因此难以逼近多峰分布。解决方法是使用混合高斯分布，使用足够多的高斯分布，并调整它们的均值和方差以及线性组合的系数，几乎可以以任意精度近似所有的连续概率密度。</description>
    </item>
    <item>
      <title>数据结构与算法复习</title>
      <link>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Tue, 07 Apr 2020 16:11:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200407_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;内容上主要是复习了B树和红黑树，其他的因为太简单所以就只是过了一下，没记录下来&#xA;数据结构与算法复习 Link to heading 不包括全部内容 基础部分包括大O记号和小o记号的意义，P问题和NP问题和NP hard问题 B树和B+树 AVL平衡树和红黑树 KMP&#xA;资料：&#xA;B站-内功心法，红黑树、平衡树、B树和B+树 清华大学邓俊辉-数据结构与算法，我计划把这篇与它的计算几何做两个观后笔记。 B树和B+树 Link to heading 资料来源：&#xA;MIT6.046 博客 M阶B树的特征：&#xA;非叶子结点最多只有M个分支 除根节点以外的非叶子结点分支数为上取整(M/2)到M。 关键字个数=分支数-1 所有叶子结点位于同一层 区别：&#xA;B树的关键字集合分布在整棵树中，而B+树的实际数据只在叶子节点中。因此B树的搜索有可能在非叶子结点结束。 因为B+树的所有数据都在叶子节点中，所以B+树的叶子节点会依据关键字的大小自小而大的顺序链接，可以进行顺序遍历。非叶子结点可以看作是索引，结点中仅含有子树中的最大或最小关键字。同一个数字会在不同结点中重复出现。 B+树的查询优势：&#xA;B+树的中间结点不保存数据，所以磁盘也能够容纳更多结点元素 B+树的查询必须查找到叶子节点，B树不必，因此B+树查找更加稳定，但并不慢 对于范围查找来说，B+树只需要遍历叶子节点链表（因为是顺序链接的），而B树需要重复进行中序遍历。 红黑树 Link to heading 参考资料2：简书-30张图了解红黑树 参考资料3：清华大学邓俊辉-红黑树演示 参考资料4：使用2-4树看待红黑树&#xA;AVL树：平衡二叉树，每个节点平衡因子的绝对值不超过1，即左右子树高度差不超过1。 最大的作用是使得二叉查找树更平衡，本质上是特殊的二叉查找树。 红黑树的性质：&#xA;每个结点不是红色就是黑色 不可能有连在一起的红色节点。 根节点一定是黑色root 每个红色节点的两个子节点都是黑色。叶子节点都是黑色。 为了满足性质，有三种变化：&#xA;红变黑，黑变红，保证根节点是黑色 左旋 右旋 所有插入的点默认为红色。（PS：叶子节点为黑色）为什么这么规定：因为红黑树中所有的点都是黑色，也是满足要求的，这样可能会造成问题。&#xA;变颜色的情况：当前结点的父亲是红色，且它的祖父结点的另一个子节点也是红色（叔叔结点）。 把父结点设为黑色 把叔叔也设为黑色 把祖父结点，也就是父节点的父节点设为红色 把指针定义到祖父结点设为当前要操作的分析的点变换的规则 左旋：当前父结点是红色，叔叔结点是黑色，且当前结点是右子树。左旋以父节点为左旋。 右旋：当前父结点是红色，叔叔结点是黑色，且当前的结点是左子树。右旋 把父节点变为黑色 把祖父节点变为红色 以租父节点旋转 重要例子： 红黑树 Link to heading 根据邓俊辉老师的思路来，之前那个人很多没有讲 3+4重构，AVL保持平衡的方式，因为涉及到3个结点和4个子树，被称为3+4重构。</description>
    </item>
    <item>
      <title>软件测试复习</title>
      <link>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Mon, 06 Apr 2020 20:15:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200406_%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%E5%A4%8D%E4%B9%A0/</guid>
      <description>原文地址&#xA;软件测试复习 Link to heading 对大三下学期的软件测试课程进行复习&#xA;第一章 Link to heading 计算机软件体系结构 Link to heading 软件体系结构是软件系统的结构、行为和属性的高级抽象，给出系统的组织结构和拓扑结构，规定系统需求和构成系统的元素之间的对应关系。&#xA;Layered Architecture：n层模型，比如TCP\IP使用的那种。例子：Presentation Layer-&amp;gt;Business Layer-&amp;gt; Persistent Layer-&amp;gt; Database Layer。核心思想是组件间的分离与功能上的聚合。 Event-Driven Architecture：常用于异步通信架构，由高度解耦合且单一目的的事件处理组件所构成。 MicroKernal Architecture：用于实现基于产品的应用的自然表示，即将大量第三方库插入进核心代码中。Core system提供了核心功能，plug-in module则可以是第三方库等能够轻松调换的代码。通过分离可以实现应用特性和具体实现的分离。 Microservices Architecture：微服务架构，面向服务的架构。按照单元分解，采用分布式架构，一般具有统一的用户交互层。 Space-Based Architecture：特定于解决扩展与并发问题。应用数据统一存储于内存中，同时通过扩展处理单元的方式实现应用处理能力的增加。 软件=程序+数据+文档+服务、 是能够完成预定性能和功能的、可执行的计算机指令。 软件需要有描述程序的操作和使用的文档。 1976: Algorithm+Data Structure = Programs&#xA;生产软件产品的基本步骤：软件规格说明、设计与实现、确认、演进。&#xA;软件开发方法：&#xA;面向数据流的结构化程序开发方法。指导思想是自顶向下，逐步求精；基本原则是功能的分解与抽象。很适合数据处理领域的问题。 面向数据结构的开发方法(Jackson方法)：描述问题的输入、输出数据结构，分析其对应性，设计相应的程序结构，从而给出问题的软件过程描述。以数据结构为驱动。 基于模型的方法，支持程序开发的形式化方法，把软件系统当作模型来给予描述，把软件的输入、输出看作模型对象，把这些对象在计算机内的状态看作该模型在对象上的操作。 面向对象的开发方法：指导思想是尽量按照人类认识世界的方法和思维方式来分析和解决问题。 第一章 1.2 软件工程生命周期 Link to heading 软件生命周期的6个阶段：&#xA;可行性分析与计划阶段：确认软件开发的总体目标、估计可利用的开发资源，最后提交可行性分析报告。 需求分析阶段：分析用户提出的要求 设计阶段：概要设计/逻辑设计（把各项软件需求转换成软件的体系结构）、详细设计/物理设计（按照概要设计分解的每个模块所要完成的工作进行具体的描述）、提交概要结构设计说明书等文档 实现阶段：完成源程序的编码、编译和运行调试、编写进度日报周报、测试计划、提交用户手册等 测试阶段：全面测试目标软件系统，并检查审阅已编制的文档。 运行与维护阶段：软件提交给用户后，在运行使用中得到持续的维护；改正性维护、适应性维护和完善性维护。 前五个阶段合称开发阶段。&#xA;软件生命周期模型 Link to heading 包括瀑布模型、VW模型、快速应用开发模型、原型模型、迭代模型、螺旋模型、喷泉模型、基于构建的开发模型、Rational统一过程模型、敏捷开发模型与极限编程。&#xA;瀑布模型 Link to heading 特征：</description>
    </item>
    <item>
      <title>中山大学考研复试内容复习</title>
      <link>http://wtysos11.github.io/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/</link>
      <pubDate>Sat, 04 Apr 2020 20:15:14 +0800</pubDate>
      <guid>http://wtysos11.github.io/posts/20200404_%E5%A4%8D%E8%AF%95%E5%86%85%E5%AE%B9%E5%A4%8D%E4%B9%A0/</guid>
      <description>中山大学考研复试内容复习 Link to heading 原文地址&#xA;复试复习以基本概念为主，重点概念为主，偏题怪题一律不考虑。&#xA;计算机网络 Link to heading 网络基础 Link to heading OSI七层模型&#xA;OSI七层模型 Link to heading OSI七层模型，从下到上依次为物理层、数据链路层、网络层、运输层、会话层、表示层、应用层。&#xA;其中底下三层称为通信子网，是为了联网而附加上去的通信设备，完成数据传输功能。顶三层称为资源子网，相当于计算机系统，完成数据的处理等功能。&#xA;物理层：传输单位比特，功能是在物理媒体上为数据端设备透明的传输原始比特流。主要定义数据终端设备DTE和数据通信设备DCE的物理和逻辑连接方法。 物理层主要研究以下内容：&#xA;通信链路与通信结点之间的连接需要的电路接口的参数（机械形状、尺寸、交换电路的数量与排列） 通信链路上传输的信号的意义和电气特征，比如高低电平的规定，信号的规定等。 PS：传输信息所利用的一些物理媒体，比如双绞线、光缆、无线信道等，并不在物理层协议之内。&#xA;数据链路层：传输单位是帧，任务是将网络层传下来的IP数据组装成帧。功能为：成帧、差错控制、流量控制和传输管理。 差错控制：检测物理层发生的差错，并丢弃收到的错误信息。 流量控制：协调相邻物理结点之间的速度。 数据链路层协议：SDLC、HDLC、PPP、STP和帧中继&#xA;网络层：传输单位是数据报（分组、包），主要任务是把网络层协议数据单元（分组）从源端传到目的端，为分组交换网上的不同主机提供通信服务。关键问题是路由选择，并实现流量控制、拥塞控制、差错控制和网际互联等功能。 差错控制：同上 拥塞控制：如果拥塞状态使得网络层中的两个结点无法正常通信，则采用一些措施缓解拥塞。 网络层协议：IP、IPX、ICMP、IGMP、ARP、RARP、OSPF&#xA;传输层：传输单位是报文段TCP或用户数据包UDP(报文)，任务是负责主机中两个进程之间的通信，功能为端到端提供可靠的传输服务；为端到端连接提供流量控制、差错控制、服务质量、数据传输管理等服务。 传输层协议：TCP、UDP&#xA;会话层：允许不同主机上各进程之间的绘画，利用传输层提供的端到端服务，管理主机之间的会话进程，包括建立、管理以及终止进程间的绘画。 表示层：主要用于处理在两个通信系统中交换信息的表示方式。比如不同机器会采用不同的编码和表示方式，以及数据结构。 应用层：最高层，包括FTP、SMTP、HTTP等协议。 TCP模型 Link to heading 网络接口层：对应于OSI的物理层和数据链路层，表示与物理网络的接口 网际层：（主机-主机），即OSI的网络层，将分组发往任何网络并独立选择合适的路由。 传输层：与OSI的传输层类似，使发送端和目的端的主机上的对等实体可以进行会话，主要使用TCP和UDP。 应用层：用户-用户，包含所有高层协议，对应于OSI的应用层呢个、表示层和会话层。 介质访问控制相关 Link to heading CSMA相关模型&#xA;3.5.1 信道划分介质访问控制 Link to heading 使用介质的每个设备与来自同一通信信道上的其他设备的通信隔离开，把时域和频域资源合理地分配给网络上的设备。&#xA;多路复用技术：传输介质的带宽超过了传输单个信号所需的带宽时，在一条介质上同时携带多个传输信号的方法来提高传输系统的利用率。即将多个输入通道的信息整合到一个复用通道，然后在接收端把收到的信息分离出来传送到对应的输出通道中。&#xA;信道划分的实质是通过分时、分频、分码等方法，把原来的一条广播信道，逻辑上分为几条用于两个结点之间通信的互不干扰的子信道。&#xA;频分多路复用FDM：将多路基带信号调制到不同频率载波上再进行叠加形成一个复合信号的多路复用技术。即将物理信道的总带宽分割成若干格传输单个信号带宽相同（略宽）的子信道 时分多路复用TDM：将一条物理信道按时间分成若干个时间片，轮流地分配给多个信号使用。每一个时间片复用的一个信号占用。利用每个信号在时间上的交叉，在一条物理信道上传输多个信号。改进：STDM，统计时分多路复用，可以动态地分配时隙，提高线路的利用率。 波分多路复用WDM：光的频分多路复用，在一根光纤中传输多种不同波长的光信号，最后用波长分解复用器将各路波长分解出来。 码分多路复用CDM：靠不同的编码来区分各路原始信号，既共享信道的频率、又共享时间。码分多址CDMA是码分复用的一种方式。（要求各个站点的芯片序列是相互正交的）优点：抗干扰能力强、保密性强、语音质量好，主要用于无线通信特别是移动通信领域。 3.5.2 随机访问介质访问控制 Link to heading 随机访问协议中，如果有两个或多个用户同时发送信息，就会造成冲突，产生帧的碰撞，导致所有冲突用户的发送均以失败告终。</description>
    </item>
  </channel>
</rss>
